diff --git a/Makefile b/Makefile
index a3d2ef0..70a6052 100644
--- a/Makefile
+++ b/Makefile
@@ -16,6 +16,8 @@ DEFAULT_JAVA := /home/utils/java/jdk1.8.0_131/bin/java
 DEFAULT_SYSTEMC := /usr/local/systemc-2.3.0/
 DEFAULT_VERILATOR := verilator
 DEFAULT_CLANG     := clang
+DEFAULT_CLANGXX   := clang++
+DEFAULT_LLVM_PROFDATA := llvm-profdata-10
 DEFAULT_PROJ := nv_full
 
 $(TREE_MAKE): Makefile
@@ -58,6 +60,12 @@ $(TREE_MAKE): Makefile
 	@echo "  																  " >> $@ 	
 	@echo "## clang: used to build Verilated binaries (optional)" >> $@
 	@read -p "OPTIONAL: Enter clang path     (Press ENTER to use: $(DEFAULT_CLANG)):" opt_clang; if [ "_$$opt_clang" = "_" ]; then echo "CLANG := $(DEFAULT_CLANG)" >> $@;  else echo "CLANG := $$opt_clang" >> $@; fi
+	@echo "  																  " >> $@
+	@echo "## clang++: used to build Verilated binaries (optional)" >> $@
+	@read -p "OPTIONAL: Enter clang++ path     (Press ENTER to use: $(DEFAULT_CLANGXX)):" opt_clangxx; if [ "_$$opt_clangxx" = "_" ]; then echo "CLANGXX := $(DEFAULT_CLANGXX)" >> $@;  else echo "CLANGXX := $$opt_clangxx" >> $@; fi
+	@echo "  																  " >> $@
+	@echo "## llvm-profdata: used to build Verilated binaries (optional)" >> $@
+	@read -p "OPTIONAL: Enter llvm-profdata path     (Press ENTER to use: $(DEFAULT_LLVM_PROFDATA)):" opt_llvm_profdata; if [ "_$$opt_clang" = "_" ]; then echo "LLVM_PROFDATA := $(DEFAULT_LLVM_PROFDATA)" >> $@;  else echo "LLVM_PROFDATA := $$opt_llvm_profdata" >> $@; fi
 	@echo
 	@echo "====================================================================="
 	@echo "$@ is created successfully, and you can edit $@ manually if necessary"
diff --git a/cmod/Makefile b/cmod/Makefile
index f2022d0..788c656 100644
--- a/cmod/Makefile
+++ b/cmod/Makefile
@@ -150,8 +150,8 @@ LD_DIRS := \
 INC_FLAGS := $(addprefix -I,$(INC_DIRS))
 LD_FLAGS  := $(addprefix -L,$(LD_DIRS))
 
-CPPFLAGS ?= $(INC_FLAGS) -MMD -MP -fPIC -Wall -Werror -DSC_INCLUDE_DYNAMIC_PROCESSES -Wp,-w -std=c++11
-LDFLAGS ?= -shared $(addprefix -l,$($(notdir $(SYSTEMC_LIBRARIES)):lib%.so=%)) $(LD_FLAGS)
+CPPFLAGS ?= $(INC_FLAGS) -MMD -MP -fPIC -Wall -Werror -DSC_INCLUDE_DYNAMIC_PROCESSES -Wp,-w -std=c++11 -O3 -Ofast
+LDFLAGS ?= -O3 -shared $(addprefix -l,$($(notdir $(SYSTEMC_LIBRARIES)):lib%.so=%)) $(LD_FLAGS)
 
 $(BUILD_DIR)/$(TARGET): $(OBJS) 
 	$(GCC) $(OBJS) -o $@ $(LDFLAGS) -L$(BUILD_DIR)
diff --git a/cmod/bdma/BdmaCore.cpp b/cmod/bdma/BdmaCore.cpp
index 9e674d7..0e826f0 100644
--- a/cmod/bdma/BdmaCore.cpp
+++ b/cmod/bdma/BdmaCore.cpp
@@ -111,7 +111,7 @@ BdmaCore::~BdmaCore () {
 
 void BdmaCore::ResetThread() {
     is_idle.write(true);
-    cslInfo(("BdmaCore::ResetThread\n"));
+    //cslInfo(("BdmaCore::ResetThread\n"));
 }
 
 void BdmaCore::ReadRequestSequenceGeneratorThread() {
@@ -131,15 +131,15 @@ void BdmaCore::ReadRequestSequenceGeneratorThread() {
     while (true) {
         // Blocking FIFO read
         bdma_core_int_fifo->read(bdma_int);
-        cslInfo(("BdmaCore::ReadRequestSequenceGeneratorThread, one bdma operation group starts. int_ptr=%d op_count=%d\n", bdma_int.int_ptr, bdma_int.op_count));
+        //cslInfo(("BdmaCore::ReadRequestSequenceGeneratorThread, one bdma operation group starts. int_ptr=%d op_count=%d\n", bdma_int.int_ptr, bdma_int.op_count));
         is_idle.write(false);
 
         for (i=0;i<bdma_int.op_count;i++) {
             core_config_in->read(core_config);
 
-            cslInfo(("BdmaCore::ReadRequestSequenceGeneratorThread, before notify_get_config.\n"));
+            //cslInfo(("BdmaCore::ReadRequestSequenceGeneratorThread, before notify_get_config.\n"));
             notify_get_config.write(true);
-            cslInfo(("BdmaCore::ReadRequestSequenceGeneratorThread, before write_config_fifo_.\n"));
+            //cslInfo(("BdmaCore::ReadRequestSequenceGeneratorThread, before write_config_fifo_.\n"));
             if (i==(uint32_t)(bdma_int.op_count-1)) {
                 if (bdma_int.int_ptr == 0) {
                     core_config.cfg_launch0_grp0_launch_ = 1;
@@ -165,9 +165,9 @@ void BdmaCore::ReadRequestSequenceGeneratorThread() {
             if (src_ram_type_curr_ != src_ram_type_next_) {
                 // Source switch, wait until credit back to initial value
                 while (read_credit_sent_ != read_credit_recv_) {
-                    cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, switch source, wait until all read response back.\n"));
+                    //cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, switch source, wait until all read response back.\n"));
                     wait(read_credit_granted_);
-                    cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, sent_credit=%ld, recv_credit=%ld\n", read_credit_sent_, read_credit_recv_));
+                    //cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, sent_credit=%ld, recv_credit=%ld\n", read_credit_sent_, read_credit_recv_));
                 }
                 read_credit_sent_ = 0;
                 read_credit_recv_ = 0;
@@ -177,9 +177,9 @@ void BdmaCore::ReadRequestSequenceGeneratorThread() {
             cube_base_addr = uint64_t(core_config.cfg_src_addr_high_v8_) << 32 | uint64_t(core_config.cfg_src_addr_low_v32_) << 5;
             // Surface Loop
             for (surface_iter = 0; surface_iter < core_config.cfg_surf_repeat_number_; surface_iter ++) {
-                cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, surface_iter=%d start\n", surface_iter));
+                //cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, surface_iter=%d start\n", surface_iter));
                 surface_base_addr = cube_base_addr + uint64_t(surface_iter * (core_config.cfg_src_surf_stride_ << 5));
-                cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, surf_stride=%x\n", core_config.cfg_src_surf_stride_));
+                //cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, surf_stride=%x\n", core_config.cfg_src_surf_stride_));
                 //if (true == is_line_packed) {    //deprecated routine
                 if (0) { /*
                     surface_size = core_config.cfg_line_repeat_number_ * core_config.cfg_line_size_ * 32;
@@ -192,16 +192,16 @@ void BdmaCore::ReadRequestSequenceGeneratorThread() {
                     //read_credit_mutex_.lock();
                     //read_credit_ = read_credit_ - payload_atom_num;
                     read_credit_sent_ += payload_atom_num;
-                    cslDebug((50, "BdmaCore::sent_credit=%d.\n", read_credit_sent_));
+                    //cslDebug((50, "BdmaCore::sent_credit=%d.\n", read_credit_sent_));
                     SendDmaReadRequest(rd_req_cmd_payload, dma_delay_, core_config.cfg_cmd_src_ram_type_);
                     //read_credit_mutex_.unlock(); */
                 } else {
                     // Line loop
                     for (line_iter = 0; line_iter < core_config.cfg_line_repeat_number_; line_iter ++) {
-                        cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, line_iter=%d start\n", line_iter));
+                        //cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, line_iter=%d start\n", line_iter));
                         line_size = core_config.cfg_line_size_ * 32;
                         payload_addr = surface_base_addr + line_iter * (core_config.cfg_src_line_stride_ << 5);
-                        cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, line_size=%d, addr=%lx\n", line_size, payload_addr));
+                        //cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, line_size=%d, addr=%lx\n", line_size, payload_addr));
                         payload_size = line_size;
                         payload_atom_num = (payload_size+DMA_ATOM_SIZE-1)/DMA_ATOM_SIZE;
                         rd_req_cmd_payload->pd.dma_read_cmd.addr = payload_addr;
@@ -210,21 +210,21 @@ void BdmaCore::ReadRequestSequenceGeneratorThread() {
                         //read_credit_mutex_.lock();
                         //read_credit_ = read_credit_ - payload_atom_num;
                         read_credit_sent_ += payload_atom_num;
-                        cslDebug((50, "BdmaCore::sent_credit=%ld.\n", read_credit_sent_));
+                        //cslDebug((50, "BdmaCore::sent_credit=%ld.\n", read_credit_sent_));
                         SendDmaReadRequest(rd_req_cmd_payload, dma_delay_, core_config.cfg_cmd_src_ram_type_);
                         //read_credit_mutex_.unlock();
-                        cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, line_iter=%d end\n", line_iter));
+                        //cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, line_iter=%d end\n", line_iter));
                     }
                 }
-                cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, surface_iter=%d end\n", surface_iter));
+                //cslDebug((50, "BdmaCore::ReadRequestSequenceGeneratorThread, surface_iter=%d end\n", surface_iter));
             }
-            cslInfo(("BdmaCore::ReadRequestSequenceGeneratorThread, read sequence end.\n"));
+            //cslInfo(("BdmaCore::ReadRequestSequenceGeneratorThread, read sequence end.\n"));
         }
     }
 }
 
 void BdmaCore::mcif2bdma_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* payload, sc_time& delay) {
-    cslDebug((50, "BdmaCore::mcif2bdma_rd_rsp_b_transport, begin.\n"));
+    //cslDebug((50, "BdmaCore::mcif2bdma_rd_rsp_b_transport, begin.\n"));
 #pragma CTC SKIP
     if ( NVDLA_BDMA_CFG_CMD_0_SRC_RAM_TYPE_MC != src_ram_type_curr_ ) {
         FAIL(("BdmaCore::mcif2bdma_rd_rsp_b_transport, src config is not mc"));
@@ -254,10 +254,10 @@ void BdmaCore::mcif2bdma_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* payload,
         //read_credit_ ++;
         read_credit_recv_++;
     }
-    cslDebug((50, "BdmaCore::mcif2bdma_rd_rsp_b_transport, recv_credit=%ld\n", read_credit_recv_));
+    //cslDebug((50, "BdmaCore::mcif2bdma_rd_rsp_b_transport, recv_credit=%ld\n", read_credit_recv_));
     read_credit_granted_.notify();
     //read_credit_mutex_.unlock();    
-    cslDebug((50, "BdmaCore::mcif2bdma_rd_rsp_b_transport, end.\n"));
+    //cslDebug((50, "BdmaCore::mcif2bdma_rd_rsp_b_transport, end.\n"));
 }
 
 void BdmaCore::cvif2bdma_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* payload, sc_time& delay) {
@@ -290,7 +290,7 @@ void BdmaCore::cvif2bdma_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* payload,
         //read_credit_ ++;
         read_credit_recv_++;
     }
-    cslDebug((50, "BdmaCore::cvif2bdma_rd_rsp_b_transport, recv_credit=%ld\n", read_credit_recv_));
+    //cslDebug((50, "BdmaCore::cvif2bdma_rd_rsp_b_transport, recv_credit=%ld\n", read_credit_recv_));
     read_credit_granted_.notify();
     //read_credit_mutex_.unlock();
 }
@@ -311,7 +311,7 @@ void BdmaCore::WriteRequestSequenceGeneratorThread() {
     uint32_t    payload_atom_num, payload_atom_num_sent; //, payload_atom_num_req;
     while (true) {
         write_config_fifo_->read(core_config);
-        cslInfo(("BdmaCore::WriteRequestSequenceGeneratorThread, write sequence start.\n"));
+        //cslInfo(("BdmaCore::WriteRequestSequenceGeneratorThread, write sequence start.\n"));
         dst_ram_type_ = core_config.cfg_cmd_dst_ram_type_;
         wr_req_cmd_payload->pd.dma_write_cmd.require_ack = 0;
         //bdma_core_int = new BdmaCoreInt();
@@ -332,7 +332,7 @@ void BdmaCore::WriteRequestSequenceGeneratorThread() {
         cube_base_addr = uint64_t(core_config.cfg_dst_addr_high_v8_) << 32 | uint64_t(core_config.cfg_dst_addr_low_v32_) << 5;
         // Surface Loop
         for (surface_iter = 0; surface_iter < core_config.cfg_surf_repeat_number_; surface_iter ++) {
-            cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, surface_iter=%d start\n", surface_iter));
+            //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, surface_iter=%d start\n", surface_iter));
             surface_base_addr = cube_base_addr + uint64_t(surface_iter * (core_config.cfg_dst_surf_stride_ << 5));
             //if (true == is_line_packed) {    //deprecated routine
             if (0) { /*
@@ -374,16 +374,16 @@ void BdmaCore::WriteRequestSequenceGeneratorThread() {
             } else {
                 // Line loop
                 for (line_iter = 0; line_iter < core_config.cfg_line_repeat_number_; line_iter ++) {
-                    cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, line_iter=%d start\n", line_iter));
+                    //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, line_iter=%d start\n", line_iter));
                     line_size = core_config.cfg_line_size_ * 32;
-                    cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, line_size=%d\n", line_size));
+                    //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, line_size=%d\n", line_size));
                     payload_addr = surface_base_addr + line_iter * (core_config.cfg_dst_line_stride_ << 5 );
                     line_size_sent = 0;
                     while (line_size_sent < line_size) {
                         // payload_size = min( uint32_t(line_size - line_size_sent), uint32_t(MEM_TRANSACTION_MAX_SIZE - payload_addr%MEM_TRANSACTION_MAX_SIZE) );
                         payload_size = line_size;
                         payload_atom_num = (payload_size+DMA_ATOM_SIZE-1)/DMA_ATOM_SIZE;
-                        cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, DMA_ATOM_SIZE-1=%d, payload_atom_num=%d\n", DMA_ATOM_SIZE-1, payload_atom_num));
+                        //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, DMA_ATOM_SIZE-1=%d, payload_atom_num=%d\n", DMA_ATOM_SIZE-1, payload_atom_num));
                         wr_req_cmd_payload->pd.dma_write_cmd.addr = payload_addr;
                         wr_req_cmd_payload->pd.dma_write_cmd.size = payload_atom_num - 1;
                         //WaitUntilAtomFifoAvailableEntryGreaterThan(payload_atom_num);
@@ -406,30 +406,30 @@ void BdmaCore::WriteRequestSequenceGeneratorThread() {
 		                    bdma_ack_fifo_->write(ack);
                         }
                         SendDmaWriteRequest(wr_req_cmd_payload, dma_delay_, core_config.cfg_cmd_dst_ram_type_);
-                        cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, sent dma write request, command.\n"));
+                        //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, sent dma write request, command.\n"));
                         payload_atom_num_sent = 0;
                         while (payload_atom_num_sent < payload_atom_num) {
-                            cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, payload_atom_num_sent=0x%x payload_atom_num=0x%x\n", payload_atom_num_sent, payload_atom_num));
+                            //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, payload_atom_num_sent=0x%x payload_atom_num=0x%x\n", payload_atom_num_sent, payload_atom_num));
                             PrepareWriteDataPayload(wr_req_data_payload,min(2,int32_t(payload_atom_num-payload_atom_num_sent)));
-                            cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, PrepareWriteDataPayload done\n"));
+                            //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, PrepareWriteDataPayload done\n"));
                             SendDmaWriteRequest(wr_req_data_payload, dma_delay_, core_config.cfg_cmd_dst_ram_type_);
-                            cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, sent dma write request, data\n"));
+                            //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, sent dma write request, data\n"));
                             payload_atom_num_sent += min(2,int32_t(payload_atom_num-payload_atom_num_sent));
                         }
                         payload_addr += payload_size;
                         line_size_sent += payload_size;
                     }
-                    cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, line_iter=%d end\n", line_iter));
+                    //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, line_iter=%d end\n", line_iter));
                 }
             }
-            cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, surface_iter=%d end\n", surface_iter));
+            //cslDebug((50, "BdmaCore::WriteRequestSequenceGeneratorThread, surface_iter=%d end\n", surface_iter));
         }
-        cslInfo(("BdmaCore::WriteRequestSequenceGeneratorThread, write sequence end.\n"));
+        //cslInfo(("BdmaCore::WriteRequestSequenceGeneratorThread, write sequence end.\n"));
     }
 }
 
 void BdmaCore::WriteResponseMethodMc() {
-    cslInfo(("BdmaCore::WriteResponseThreadMc is called\n"));
+    //cslInfo(("BdmaCore::WriteResponseThreadMc is called\n"));
     if ( true == mcif2bdma_wr_rsp.read() ) {
         is_mc_ack_done_ = true;
         bdma_mc_ack_.notify();
@@ -437,7 +437,7 @@ void BdmaCore::WriteResponseMethodMc() {
 }
 
 void BdmaCore::WriteResponseMethodCv() {
-    cslInfo(("BdmaCore::WriteResponseThreadCv is called\n"));
+    //cslInfo(("BdmaCore::WriteResponseThreadCv is called\n"));
     if ( true == cvif2bdma_wr_rsp.read() ) {
         is_cv_ack_done_ = true;
         bdma_cv_ack_.notify();
@@ -495,9 +495,9 @@ void BdmaCore::WaitUntilAtomFifoFreeEntryGreaterThan(uint8_t num) {
 // Check available entry numbers in atom fifo
 void BdmaCore::WaitUntilAtomFifoAvailableEntryGreaterThan(uint8_t num) {
     while (dma_atom_fifo_->num_available() < num) {
-        cslInfo(("BdmaCore::WaitUntilAtomFifoAvailableEntryGreaterThan, num=%d\n", num ));
+        //cslInfo(("BdmaCore::WaitUntilAtomFifoAvailableEntryGreaterThan, num=%d\n", num ));
         wait( dma_atom_fifo_->data_written_event() );
-        cslInfo(("BdmaCore::WaitUntilAtomFifoAvailableEntryGreaterThan, avail=%d\n", dma_atom_fifo_->num_available() ));
+        //cslInfo(("BdmaCore::WaitUntilAtomFifoAvailableEntryGreaterThan, avail=%d\n", dma_atom_fifo_->num_available() ));
     }
 }
 #pragma CTC ENDSKIP
@@ -519,10 +519,10 @@ void BdmaCore::PrepareWriteDataPayload(nvdla_dma_wr_req_t * payload, uint8_t num
 // Send DMA read request
 void BdmaCore::SendDmaReadRequest(nvdla_dma_rd_req_t* payload, sc_time& delay, uint8_t src_ram_type) {
     if ( NVDLA_BDMA_CFG_CMD_0_SRC_RAM_TYPE_MC == src_ram_type ) {
-        cslDebug((50, "BdmaCore::SendDmaReadRequest, send read request to MC Address=0x%lx Size=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size));
+        //cslDebug((50, "BdmaCore::SendDmaReadRequest, send read request to MC Address=0x%lx Size=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size));
         bdma2mcif_rd_req_b_transport(payload, dma_delay_);
     } else {
-        cslDebug((50, "BdmaCore::SendDmaReadRequest, send read request to CV Address=0x%lx Size=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size));
+        //cslDebug((50, "BdmaCore::SendDmaReadRequest, send read request to CV Address=0x%lx Size=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size));
         bdma2cvif_rd_req_b_transport(payload, dma_delay_);
     }
 }
@@ -531,16 +531,16 @@ void BdmaCore::SendDmaReadRequest(nvdla_dma_rd_req_t* payload, sc_time& delay, u
 void BdmaCore::SendDmaWriteRequest(nvdla_dma_wr_req_t* payload, sc_time& delay, uint8_t dst_ram_type) {
     if (NVDLA_BDMA_CFG_CMD_0_DST_RAM_TYPE_MC == dst_ram_type) {
         if(TAG_CMD == payload->tag) {
-            cslDebug((50, "BdmaCore::SendDmaWriteRequest, send write request to MC command. Address=0x%lx Size=0x%x\n", payload->pd.dma_write_cmd.addr, payload->pd.dma_write_cmd.size));
+            //cslDebug((50, "BdmaCore::SendDmaWriteRequest, send write request to MC command. Address=0x%lx Size=0x%x\n", payload->pd.dma_write_cmd.addr, payload->pd.dma_write_cmd.size));
         } else {
-            cslDebug((50, "BdmaCore::SendDmaWriteRequest, send write request to MC, data.\n"));
+            //cslDebug((50, "BdmaCore::SendDmaWriteRequest, send write request to MC, data.\n"));
         }
         bdma2mcif_wr_req_b_transport(payload, dma_delay_);
     } else {
         if(TAG_CMD == payload->tag) {
-            cslDebug((50, "BdmaCore::SendDmaWriteRequest, send write request to CV command. Address=0x%lx Size=0x%x\n", payload->pd.dma_write_cmd.addr, payload->pd.dma_write_cmd.size));
+            //cslDebug((50, "BdmaCore::SendDmaWriteRequest, send write request to CV command. Address=0x%lx Size=0x%x\n", payload->pd.dma_write_cmd.addr, payload->pd.dma_write_cmd.size));
         } else {
-            cslDebug((50, "BdmaCore::SendDmaWriteRequest, send write request to CV, data.\n"));
+            //cslDebug((50, "BdmaCore::SendDmaWriteRequest, send write request to CV, data.\n"));
         }
         bdma2cvif_wr_req_b_transport(payload, dma_delay_);
     }
diff --git a/cmod/cacc/NV_NVDLA_cacc.cpp b/cmod/cacc/NV_NVDLA_cacc.cpp
index 210216f..3bb9563 100644
--- a/cmod/cacc/NV_NVDLA_cacc.cpp
+++ b/cmod/cacc/NV_NVDLA_cacc.cpp
@@ -103,7 +103,7 @@ void NV_NVDLA_cacc::CaccConsumerThread () {
         while(CaccGetOpeartionEnable(cacc_register_group_0) != NVDLA_CACC_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_cacc_reg_group_0_operation_enable);
         }
-        cslInfo(("NV_NVDLA_cacc::CaccConsumerThread, group 0 opeartion start\n"));
+        //cslInfo(("NV_NVDLA_cacc::CaccConsumerThread, group 0 opeartion start\n"));
         saturation_num_perlayer_ =0;
         cacc_reg_model::CaccUpdateWorkingStatus(0,1);
         cacc_reg_model::CaccUpdateVariables(cacc_register_group_0);
@@ -111,12 +111,12 @@ void NV_NVDLA_cacc::CaccConsumerThread () {
         cacc_reg_model::CaccUpdateStatRegisters(0, saturation_num_perlayer_);  //stepheng.20170724
         cacc_reg_model::CaccUpdateWorkingStatus(0,0);
         cacc_reg_model::CaccClearOpeartionEnable(cacc_register_group_0);
-        cslInfo(("NV_NVDLA_cacc::CaccConsumerThread, group 0 opeartion done\n"));
+        //cslInfo(("NV_NVDLA_cacc::CaccConsumerThread, group 0 opeartion done\n"));
 
         while(CaccGetOpeartionEnable(cacc_register_group_1) != NVDLA_CACC_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_cacc_reg_group_1_operation_enable);
         }
-        cslInfo(("NV_NVDLA_cacc::CaccConsumerThread, group 1 opeartion start\n"));
+        //cslInfo(("NV_NVDLA_cacc::CaccConsumerThread, group 1 opeartion start\n"));
         saturation_num_perlayer_ =0;
         cacc_reg_model::CaccUpdateWorkingStatus(1,1);
         cacc_reg_model::CaccUpdateVariables(cacc_register_group_1);
@@ -124,7 +124,7 @@ void NV_NVDLA_cacc::CaccConsumerThread () {
         cacc_reg_model::CaccUpdateStatRegisters(1, saturation_num_perlayer_);  //stepheng,20170724      
         cacc_reg_model::CaccUpdateWorkingStatus(1,0);
         cacc_reg_model::CaccClearOpeartionEnable(cacc_register_group_1);
-        cslInfo(("NV_NVDLA_cacc::CaccConsumerThread, group 1 opeartion done\n"));
+        //cslInfo(("NV_NVDLA_cacc::CaccConsumerThread, group 1 opeartion done\n"));
     }
 }
 
@@ -205,9 +205,9 @@ void NV_NVDLA_cacc::CaccHardwareLayerExecutionTrigger () {
         assembly2send_config_fifo_->write(cacc_config_send);
     }
     cacc_kickoff_.notify();
-    cslInfo(("cacc before wait cacc_done_\n"));
+    //cslInfo(("cacc before wait cacc_done_\n"));
     wait(cacc_done_);
-    cslInfo(("cacc after wait cacc_done_\n"));
+    //cslInfo(("cacc after wait cacc_done_\n"));
 }
 
 void NV_NVDLA_cacc::mac_a2accu_b_transport(int ID, nvdla_mac2accu_data_if_t* payload, sc_time& delay) {
@@ -217,9 +217,9 @@ void NV_NVDLA_cacc::mac_a2accu_b_transport(int ID, nvdla_mac2accu_data_if_t* pay
     dst_ptr = (uint8_t*) payload_copy;
     memcpy(dst_ptr, src_ptr, sizeof(nvdla_mac2accu_data_if_t));
     // mac_a2acc_fifo_->write(payload);
-    cslDebug((50, "MARKFIFO: before write to mac_a2acc_fifo_\n"));
+    //cslDebug((50, "MARKFIFO: before write to mac_a2acc_fifo_\n"));
     mac_a2acc_fifo_->write(payload_copy);
-    cslDebug((50, "MARKFIFO: after write to mac_a2acc_fifo_\n"));
+    //cslDebug((50, "MARKFIFO: after write to mac_a2acc_fifo_\n"));
 }
 
 void NV_NVDLA_cacc::mac_b2accu_b_transport(int ID, nvdla_mac2accu_data_if_t* payload, sc_time& delay) {
@@ -251,10 +251,10 @@ void NV_NVDLA_cacc::CmacDataConcatThread() {
         half_payload = mac_a2acc_fifo_->read();
 
         mac2accu_payload.mask |= half_payload->mask;
-        cslDebug((50, "NV_NVDLA_cacc::CmacDataConcatThread, from A part\n"));
+        //cslDebug((50, "NV_NVDLA_cacc::CmacDataConcatThread, from A part\n"));
         for(int element_iter = 0; element_iter < HALF_MAC_CELL_NUM*RESULT_NUM_PER_MACCELL; element_iter++) {
             mac2accu_payload.data[element_iter] = half_payload->data[element_iter];
-            cslDebug((70, "half_payload.data[0x%x]:0x%08x\n", element_iter, (uint32_t)(half_payload->data[element_iter])));
+            //cslDebug((70, "half_payload.data[0x%x]:0x%08x\n", element_iter, (uint32_t)(half_payload->data[element_iter])));
         }
         mac2accu_payload.pd.nvdla_stripe_info = half_payload->pd.nvdla_stripe_info;
         delete half_payload;
@@ -266,10 +266,10 @@ void NV_NVDLA_cacc::CmacDataConcatThread() {
         half_payload = mac_b2acc_fifo_->read();
 
         mac2accu_payload.mask |= half_payload->mask << HALF_MAC_CELL_NUM;
-        cslDebug((50, "NV_NVDLA_cacc::CmacDataConcatThread, from B part\n"));
+        //cslDebug((50, "NV_NVDLA_cacc::CmacDataConcatThread, from B part\n"));
         for(int element_iter = 0; element_iter < HALF_MAC_CELL_NUM*RESULT_NUM_PER_MACCELL; element_iter++) {
             mac2accu_payload.data[element_iter+offset] = half_payload->data[element_iter];
-            cslDebug((70, "half_payload.data[0x%x]:0x%08x\n", element_iter, (uint32_t)(half_payload->data[element_iter])));
+            //cslDebug((70, "half_payload.data[0x%x]:0x%08x\n", element_iter, (uint32_t)(half_payload->data[element_iter])));
         }
         // check strip info is the same or not
         // if (!memcmp(&mac2accu_payload.pd.nvdla_stripe_info, &half_payload->pd.nvdla_stripe_info, sizeof(mac2accu_payload.pd.nvdla_stripe_info))) {
@@ -285,25 +285,25 @@ void NV_NVDLA_cacc::CmacDataConcatThread() {
 
 void NV_NVDLA_cacc::ReshapeSequenceThread () {
     while (true) {
-        cslDebug((30, "NV_NVDLA_cacc::ReshapeSequenceThread before ReshapeSequencerDirectConvCommon\n"));
+        //cslDebug((30, "NV_NVDLA_cacc::ReshapeSequenceThread before ReshapeSequencerDirectConvCommon\n"));
         ReshapeSequencerDirectConvCommon();
-        cslDebug((30, "NV_NVDLA_cacc::ReshapeSequenceThread after ReshapeSequencerDirectConvCommon\n"));
+        //cslDebug((30, "NV_NVDLA_cacc::ReshapeSequenceThread after ReshapeSequencerDirectConvCommon\n"));
     }
 }
 
 void NV_NVDLA_cacc::DeliverSequenceThread () {
     while (true) {
-        cslDebug((30, "NV_NVDLA_cacc::DeliverSequenceThread before DeliverSequencerDirectConvCommon\n"));
+        //cslDebug((30, "NV_NVDLA_cacc::DeliverSequenceThread before DeliverSequencerDirectConvCommon\n"));
         DeliverSequencerDirectConvCommon();
-        cslDebug((30, "NV_NVDLA_cacc::DeliverSequenceThread after DeliverSequencerDirectConvCommon\n"));
+        //cslDebug((30, "NV_NVDLA_cacc::DeliverSequenceThread after DeliverSequencerDirectConvCommon\n"));
     }
 }
 
 void NV_NVDLA_cacc::SendToSDPThread () {
     while (true) {
-        cslDebug((30, "NV_NVDLA_cacc::SendToSDPThread Layer begin\n"));
+        //cslDebug((30, "NV_NVDLA_cacc::SendToSDPThread Layer begin\n"));
         SendToSDPCommon();
-        cslDebug((30, "NV_NVDLA_cacc::SendToThread Layer end\n"));
+        //cslDebug((30, "NV_NVDLA_cacc::SendToThread Layer end\n"));
     }
 }
 
@@ -346,7 +346,7 @@ void NV_NVDLA_cacc::SendToSDPCommon () {
     cacc2sdp_payload.pd.nvdla_cc2pp_pkg.layer_end = 0;
 
     assembly2send_config_fifo_->read(cacc_config);
-    cslDebug((70, "after read assembly2send_config_fifo_\n"));
+    //cslDebug((70, "after read assembly2send_config_fifo_\n"));
 
     precision    = cacc_config->cacc_proc_precision_;
     cube_width   = cacc_config->cacc_dataout_width_ + 1;
@@ -361,8 +361,8 @@ void NV_NVDLA_cacc::SendToSDPCommon () {
     cacc_consumer = cacc_config->cacc_consumer_;
     delete cacc_config;
 
-    cslDebug((70, "WxHxC=%dx%dx%d, precision:%d, batch_num:%d, line_packed:%d, surf_packed:%d, conv_mode:%d\n",
-                cube_width, cube_height, cube_channel, precision, batch_num, line_packed, surf_packed, conv_mode));
+    //cslDebug((70, "WxHxC=%dx%dx%d, precision:%d, batch_num:%d, line_packed:%d, surf_packed:%d, conv_mode:%d\n",
+                //cube_width, cube_height, cube_channel, precision, batch_num, line_packed, surf_packed, conv_mode));
 
     switch (precision) {
         case DATA_FORMAT_INT8:
@@ -405,19 +405,19 @@ void NV_NVDLA_cacc::SendToSDPCommon () {
         else
             atom_num_batch_2sdp = batch_num;
     }
-    cslDebug((50, "batch_num=%d atom_num=0x%lx atom_num_batch_2sdp=0x%x trans_num=%d\n", batch_num, atom_num, atom_num_batch_2sdp, trans_num));
+    //cslDebug((50, "batch_num=%d atom_num=0x%lx atom_num_batch_2sdp=0x%x trans_num=%d\n", batch_num, atom_num, atom_num_batch_2sdp, trans_num));
 
     while (atom_num_sent < batch_atom_num) {
         // Read atoms from to_sdp_fifo_. The number of atom is atom_num_batch_2sdp
         for(i=0;i<atom_num_batch_2sdp*trans_num*atom_per_mac_cell;i++) {
             to_sdp_atom[i] = to_sdp_fifo_->read();  // Each entry of to_sdp_fifo_ contains data for an output atom of sdp
 #if LOG_DETAIL
-            cslDebug((50, "%s: [HYZ] to_sdp_atom init = %d\n", __FUNCTION__, i));
-            cslDebug((50, "%s: deliver buffer for atom:%d\n", __FUNCTION__, i));
+            //cslDebug((50, "%s: [HYZ] to_sdp_atom init = %d\n", __FUNCTION__, i));
+            //cslDebug((50, "%s: deliver buffer for atom:%d\n", __FUNCTION__, i));
             for(int m = 0; m < element_per_payload; m++) {
-                cslDebug((50, "%04x \n", to_sdp_atom[i][m].to_int()));
+                //cslDebug((50, "%04x \n", to_sdp_atom[i][m].to_int()));
             }
-            cslDebug((50, "\n" ));
+            //cslDebug((50, "\n" ));
 #endif
         }
 
@@ -435,9 +435,9 @@ void NV_NVDLA_cacc::SendToSDPCommon () {
                             cacc2sdp_payload.pd.nvdla_cc2pp_pkg.batch_end = 0;  // Note: batch_end is not used by SDP cmodel??
                             cacc2sdp_payload.pd.nvdla_cc2pp_pkg.layer_end = 1;
                         }
-                        cslDebug((50, "before cacc2sdp_payload\n"));
+                        //cslDebug((50, "before cacc2sdp_payload\n"));
                         cacc2sdp_b_transport(&cacc2sdp_payload, b_transport_delay_);
-                        cslDebug((50, "cacc2sdp_count=%d\n", cacc2sdp_count));
+                        //cslDebug((50, "cacc2sdp_count=%d\n", cacc2sdp_count));
                         cacc2sdp_count++;
                     }
                     atom_num_sent++;
@@ -450,7 +450,7 @@ void NV_NVDLA_cacc::SendToSDPCommon () {
                     }
                     delete [] to_sdp_atom[i*trans_num+trans_iter];
                     cacc2sdp_b_transport(&cacc2sdp_payload, b_transport_delay_);
-                    cslDebug((50, "cacc2sdp_count=%d\n", cacc2sdp_count));
+                    //cslDebug((50, "cacc2sdp_count=%d\n", cacc2sdp_count));
                     cacc2sdp_count++;
                 }
                 atom_num_sent++;
@@ -466,7 +466,7 @@ void NV_NVDLA_cacc::SendToSDPCommon () {
                         cacc2sdp_payload.pd.nvdla_cc2pp_pkg.layer_end = 1;
                     }
                     cacc2sdp_b_transport(&cacc2sdp_payload, b_transport_delay_);
-                    cslDebug((50, "cacc2sdp_count=%d\n", cacc2sdp_count));
+                    //cslDebug((50, "cacc2sdp_count=%d\n", cacc2sdp_count));
                     cacc2sdp_count++;
                 }
                 atom_num_sent++;
@@ -541,7 +541,7 @@ void NV_NVDLA_cacc::DeliverSequencerDirectConvCommon() {
     cacc2sdp_payload.pd.nvdla_cc2pp_pkg.layer_end = 0;
 
     assembly2delivery_config_fifo_->read(cacc_config);
-    cslDebug((70, "after read assembly2delivery_config_fifo_\n"));
+    //cslDebug((70, "after read assembly2delivery_config_fifo_\n"));
 
     precision    = cacc_config->cacc_proc_precision_;
     cube_width   = cacc_config->cacc_dataout_width_ + 1;
@@ -553,8 +553,8 @@ void NV_NVDLA_cacc::DeliverSequencerDirectConvCommon() {
     surf_packed  = cacc_config->cacc_surf_packed_;
     delete cacc_config;
 
-    cslDebug((70, "WxHxC=%dx%dx%d, precision:%d, batch_num:%d, line_packed:%d, surf_packed:%d, conv_mode:%d\n",
-                cube_width, cube_height, cube_channel, precision, batch_num, line_packed, surf_packed, conv_mode));
+    //cslDebug((70, "WxHxC=%dx%dx%d, precision:%d, batch_num:%d, line_packed:%d, surf_packed:%d, conv_mode:%d\n",
+                //cube_width, cube_height, cube_channel, precision, batch_num, line_packed, surf_packed, conv_mode));
 
     // Evaluated
     switch (precision) {
@@ -586,7 +586,7 @@ void NV_NVDLA_cacc::DeliverSequencerDirectConvCommon() {
 
     atom_num_sent = 0;
 
-    cslDebug((50, "batch_num=%d atom_num=0x%lx\n", batch_num, atom_num));
+    //cslDebug((50, "batch_num=%d atom_num=0x%lx\n", batch_num, atom_num));
     while (atom_num_sent < batch_atom_num) {
         WaitUntilThereIsAvaliableDataInDeliveryGroup();
         if (delivery_first_layer) {     // first layer and first atom
@@ -612,9 +612,9 @@ void NV_NVDLA_cacc::DeliverSequencerDirectConvCommon() {
                 }
             }
         }
-        cslDebug((50, "atom_num_sent=%ld batch_atom_num=%ld\n", atom_num_sent, batch_atom_num));
-        cslDebug((50, "delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
-        cslDebug((50, "delivery_sram_group_idx_fetched_=0x%x\n", delivery_sram_group_idx_fetched_));
+        //cslDebug((50, "atom_num_sent=%ld batch_atom_num=%ld\n", atom_num_sent, batch_atom_num));
+        //cslDebug((50, "delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
+        //cslDebug((50, "delivery_sram_group_idx_fetched_=0x%x\n", delivery_sram_group_idx_fetched_));
         // Each playload to SDP contains 16 32bits elements. For INT8, there are two transactions to SDP for one ouput atom
         switch (precision) {
             case DATA_FORMAT_INT8:
@@ -630,7 +630,7 @@ void NV_NVDLA_cacc::DeliverSequencerDirectConvCommon() {
                         if (element_per_payload_prepared % element_per_payload == 0) {
 #if LOG_DETAIL
                             for (int i=0;i<element_per_payload;i++) {
-                                cslDebug((70, "prepared_sdp_atom[%d]=0x%08x\n", i, prepared_sdp_atom[i].to_int()));
+                                //cslDebug((70, "prepared_sdp_atom[%d]=0x%08x\n", i, prepared_sdp_atom[i].to_int()));
                             }
 #endif
                             to_sdp_fifo_->write(prepared_sdp_atom); // FIXME(skip-t194): can be optimized to not use fifo to improve cmod performance
@@ -653,11 +653,11 @@ void NV_NVDLA_cacc::DeliverSequencerDirectConvCommon() {
                         element_per_payload_prepared += 1;
                         if (element_per_payload_prepared % element_per_payload == 0) {
 #if LOG_DETAIL
-                            cslDebug((70, "prepared_sdp_atom for atom:%d:\n", atom_per_mac_cell_iter));
+                            //cslDebug((70, "prepared_sdp_atom for atom:%d:\n", atom_per_mac_cell_iter));
                             for (int i=0;i<element_per_payload;i++) {
-                                cslDebug((70, "0x%04x, ", prepared_sdp_atom[i].to_int()));
+                                //cslDebug((70, "0x%04x, ", prepared_sdp_atom[i].to_int()));
                             }
-                            cslDebug((70, "\n"));
+                            //cslDebug((70, "\n"));
 #endif
                             to_sdp_fifo_->write(prepared_sdp_atom);
                         }
@@ -676,10 +676,10 @@ void NV_NVDLA_cacc::DeliverSequencerDirectConvCommon() {
 
     deliver_prev_conv_mode_ = conv_mode;
     deliver_prev_precision_ = precision;
-    cslDebug((50, "NV_NVDLA_cacc::DeliverSequencerDirectConvCommon delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
-    cslDebug((50, "NV_NVDLA_cacc::DeliverSequencerDirectConvCommon delivery_sram_group_idx_fetched_=0x%x\n", delivery_sram_group_idx_fetched_));
+    //cslDebug((50, "NV_NVDLA_cacc::DeliverSequencerDirectConvCommon delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
+    //cslDebug((50, "NV_NVDLA_cacc::DeliverSequencerDirectConvCommon delivery_sram_group_idx_fetched_=0x%x\n", delivery_sram_group_idx_fetched_));
 
-    cslDebug((50, "CACC delivery Done. consumer pointer is %d\n", cacc_consumer_));
+    //cslDebug((50, "CACC delivery Done. consumer pointer is %d\n", cacc_consumer_));
 }
 
 void NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon() {
@@ -792,9 +792,9 @@ void NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon() {
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_idx_fetched_=0x%x\n", assembly_sram_group_idx_fetched_));
-        cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
-        cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, before truncation\n"));
+        //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_idx_fetched_=0x%x\n", assembly_sram_group_idx_fetched_));
+        //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
+        //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, before truncation\n"));
         for (mac_cell_iter = 0; mac_cell_iter < MAC_CELL_NUM; mac_cell_iter ++) {
             switch (precision) {
                 case DATA_FORMAT_INT8:
@@ -824,9 +824,9 @@ void NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon() {
 
                             truncated_result = (int64_t)(out > 0 ? out+0.5 : out-0.5);
 #endif
-                            cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_[0x%x] is 0x%016lx\n", assembly_idx, (uint64_t)(assembly_value.to_uint64())));
-                            cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_[0x%x][ACCU_ASSEMBLY_BIT_WIDTH_INT16-1] is 0x%x\n", assembly_idx, (uint32_t)(assembly_value[ACCU_ASSEMBLY_BIT_WIDTH_INT16-1])));
-                            cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, truncated_result is 0x%16x\n", (uint32_t)(truncated_result.to_int())));
+                            //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_[0x%x] is 0x%016lx\n", assembly_idx, (uint64_t)(assembly_value.to_uint64())));
+                            //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_[0x%x][ACCU_ASSEMBLY_BIT_WIDTH_INT16-1] is 0x%x\n", assembly_idx, (uint32_t)(assembly_value[ACCU_ASSEMBLY_BIT_WIDTH_INT16-1])));
+                            //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, truncated_result is 0x%16x\n", (uint32_t)(truncated_result.to_int())));
                             if ( truncated_result.to_int64() > (int64_t)INT32_MAX ) {
                                 // Overflow
                                 delivery_sram_group_[delivery_idx] = INT32_MAX;
@@ -838,7 +838,7 @@ void NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon() {
                             } else {
                                 delivery_sram_group_[delivery_idx] = truncated_result.range(ACCU_DELIVERY_BIT_WIDTH_INT16 - 1, 0);
                             }
-                            cslDebug((50, "    delivery_sram_group_[0x%x]: 0x%08x\n", delivery_idx, (uint32_t)delivery_sram_group_[delivery_idx].to_int()));
+                            //cslDebug((50, "    delivery_sram_group_[0x%x]: 0x%08x\n", delivery_idx, (uint32_t)delivery_sram_group_[delivery_idx].to_int()));
                         }
                     }
                     break;
@@ -868,9 +868,9 @@ void NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon() {
 
                         truncated_result = (int64_t)(out > 0 ? out+0.5 : out-0.5);
 #endif
-                        cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_[0x%x] is 0x%016lx\n", assembly_idx, (int64_t)(assembly_value.to_int64())));
-                        cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_[0x%x][ACCU_ASSEMBLY_BIT_WIDTH_INT16-1] is 0x%x\n", assembly_idx, (uint32_t)(assembly_value[ACCU_ASSEMBLY_BIT_WIDTH_INT16-1])));
-                        cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, truncated_result is 0x%16lx\n", (uint64_t)(truncated_result.to_uint64())));
+                        //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_[0x%x] is 0x%016lx\n", assembly_idx, (int64_t)(assembly_value.to_int64())));
+                        //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, assembly_sram_group_[0x%x][ACCU_ASSEMBLY_BIT_WIDTH_INT16-1] is 0x%x\n", assembly_idx, (uint32_t)(assembly_value[ACCU_ASSEMBLY_BIT_WIDTH_INT16-1])));
+                        //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, truncated_result is 0x%16lx\n", (uint64_t)(truncated_result.to_uint64())));
                         if ( truncated_result.to_int64() > (int64_t)INT32_MAX ) {
                             // Overflow
                             delivery_sram_group_[delivery_idx] = INT32_MAX;
@@ -882,7 +882,7 @@ void NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon() {
                         } else {
                             delivery_sram_group_[delivery_idx] = truncated_result.range(ACCU_DELIVERY_BIT_WIDTH_INT16 - 1, 0);
                         }
-                        cslDebug((50, "    delivery_sram_group_[0x%x]: 0x%08x, saturation_num_perlayer_:%d\n", delivery_idx, (uint32_t)delivery_sram_group_[delivery_idx].to_int(), saturation_num_perlayer_));
+                        //cslDebug((50, "    delivery_sram_group_[0x%x]: 0x%08x, saturation_num_perlayer_:%d\n", delivery_idx, (uint32_t)delivery_sram_group_[delivery_idx].to_int(), saturation_num_perlayer_));
                     }
                     break;
                 case DATA_FORMAT_FP16:
@@ -906,8 +906,8 @@ void NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon() {
     // prev_layer_delivery_sram_group_idx_available_ = delivery_sram_group_idx_available_;
     reshape_prev_conv_mode_ = conv_mode;
     reshape_prev_precision_ = precision;
-    cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, end of layer, assembly_sram_group_idx_fetched_=0x%x\n", assembly_sram_group_idx_fetched_));
-    cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, end of layer, delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
+    //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, end of layer, assembly_sram_group_idx_fetched_=0x%x\n", assembly_sram_group_idx_fetched_));
+    //cslDebug((50, "NV_NVDLA_cacc::ReshapeSequencerDirectConvCommon, end of layer, delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
 }
 
 // Data from MAC, target socket
@@ -949,12 +949,12 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
 
     payload_data_ptr = payload->data;
     mac2cacc_count++;
-    cslDebug((50, "mac2cacc_count = %d\n", mac2cacc_count));
-    cslDebug((50, "payload->pd.nvdla_stripe_info.stripe_end = %d\n", (unsigned int)payload->pd.nvdla_stripe_info.stripe_end));
-    cslDebug((50, "payload->pd.nvdla_stripe_info.channel_end = %d\n", (unsigned int)payload->pd.nvdla_stripe_info.channel_end));
+    //cslDebug((50, "mac2cacc_count = %d\n", mac2cacc_count));
+    //cslDebug((50, "payload->pd.nvdla_stripe_info.stripe_end = %d\n", (unsigned int)payload->pd.nvdla_stripe_info.stripe_end));
+    //cslDebug((50, "payload->pd.nvdla_stripe_info.channel_end = %d\n", (unsigned int)payload->pd.nvdla_stripe_info.channel_end));
 #if LOG_DETAIL
     for (int i=0;i<MAC_CELL_NUM*8;i++)    // each element is sc_int<22>
-        cslDebug((70, "    mac2cacc payload[%d]: 0x%08x\n", i, (uint32_t)payload_data_ptr[i].to_int()));
+        //cslDebug((70, "    mac2cacc payload[%d]: 0x%08x\n", i, (uint32_t)payload_data_ptr[i].to_int()));
 #endif
 
     if (is_assembly_working_ == false) {
@@ -1006,13 +1006,13 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
     //     sc_int<22> data [16*8];
     //     union nvdla_mac2accu_data_if_u pd ;
     // } nvdla_mac2accu_data_if_t;
-    cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, assembly_sram_group_idx_working_ is 0x%x\n", assembly_sram_group_idx_working_));
+    //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, assembly_sram_group_idx_working_ is 0x%x\n", assembly_sram_group_idx_working_));
     if (assembly_sram_group_idx_working_ <= prev_layer_assembly_sram_group_idx_available_)
         FAIL(("The value of assembly_sram_group_idx_working_ is wrong. assembly_sram_group_idx_working_=0x%x prev_layer_assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_working_, prev_layer_assembly_sram_group_idx_available_));
     if (false == has_ongoing_channel_operation_) {
         // has_ongoing_channel_operation_ = true;
         // Start of a new output stripe, directly write mac data to ACCU
-        cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, assembly, the first stripe of a channel operation\n"));
+        //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, assembly, the first stripe of a channel operation\n"));
         for (mac_cell_iter = 0; mac_cell_iter < MAC_CELL_NUM; mac_cell_iter ++) {
             for (atom_iter=0; atom_iter<atom_per_mac_cell; atom_iter++) {
                 switch (precision) {
@@ -1022,10 +1022,10 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                         int8_mac_data  = payload_data_ptr[payload_idx];
                         assembly_sram_group_[assembly_idx] = int8_mac_data;
 #if LOG_DETAIL
-                        cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
-                        cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
-                        cslDebug((50, "    int8_mac_data: 0x%016x\n", (uint32_t)int8_mac_data.to_int()));
-                        cslDebug((50, "    int8 assembly_sram_group_[%d]: 0x%016x\n", assembly_idx, (uint32_t)assembly_sram_group_[assembly_idx].to_int()));
+                        //cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
+                        //cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
+                        //cslDebug((50, "    int8_mac_data: 0x%016x\n", (uint32_t)int8_mac_data.to_int()));
+                        //cslDebug((50, "    int8 assembly_sram_group_[%d]: 0x%016x\n", assembly_idx, (uint32_t)assembly_sram_group_[assembly_idx].to_int()));
 #endif
                         // Second element of the mac_cell for INT8
                         payload_idx ++;
@@ -1033,8 +1033,8 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                         int8_mac_data  = payload_data_ptr[payload_idx];
                         assembly_sram_group_[assembly_idx] = int8_mac_data;
 #if LOG_DETAIL
-                        cslDebug((50, "    int8_cmac_data: 0x%016x\n", (uint32_t)int8_mac_data.to_int()));
-                        cslDebug((50, "    int8 assembly_sram_group_[%d]: 0x%016x\n", assembly_idx, (uint32_t)assembly_sram_group_[assembly_idx].to_int()));
+                        //cslDebug((50, "    int8_cmac_data: 0x%016x\n", (uint32_t)int8_mac_data.to_int()));
+                        //cslDebug((50, "    int8 assembly_sram_group_[%d]: 0x%016x\n", assembly_idx, (uint32_t)assembly_sram_group_[assembly_idx].to_int()));
 #endif
                         break;
                     case DATA_FORMAT_INT16:
@@ -1043,10 +1043,10 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                         int16_mac_data  = (payload_data_ptr[payload_idx+1], payload_data_ptr[payload_idx]);
                         assembly_sram_group_[assembly_idx] = int16_mac_data;
 #if LOG_DETAIL
-                        cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
-                        cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
-                        cslDebug((50, "    int16_cmac_data is 0x%016lx\n", (int64_t)int16_mac_data.to_int64()));
-                        cslDebug((50, "    int16 assembly_sram_group_[%d]: 0x%016lx\n", assembly_idx, (int64_t)assembly_sram_group_[assembly_idx].to_int64()));
+                        //cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
+                        //cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
+                        //cslDebug((50, "    int16_cmac_data is 0x%016lx\n", (int64_t)int16_mac_data.to_int64()));
+                        //cslDebug((50, "    int16 assembly_sram_group_[%d]: 0x%016lx\n", assembly_idx, (int64_t)assembly_sram_group_[assembly_idx].to_int64()));
 #endif
                         break;
                     case DATA_FORMAT_FP16:
@@ -1057,10 +1057,10 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                         cacc_fp16_add(&fp16_accu_data, fp16_mac_data);
                         assembly_sram_group_[assembly_idx] = fp16_accu_data;
 #if LOG_DETAIL
-                        cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
-                        cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
-                        cslDebug((50, "    int16_cmac_data is 0x%016lx\n", (int64_t)fp16_mac_data.to_int64()));
-                        cslDebug((50, "    int16 assembly_sram_group_[%d]: 0x%016lx\n", assembly_idx, (int64_t)assembly_sram_group_[assembly_idx].to_int64()));
+                        //cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
+                        //cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
+                        //cslDebug((50, "    int16_cmac_data is 0x%016lx\n", (int64_t)fp16_mac_data.to_int64()));
+                        //cslDebug((50, "    int16 assembly_sram_group_[%d]: 0x%016lx\n", assembly_idx, (int64_t)assembly_sram_group_[assembly_idx].to_int64()));
 #endif
                         break;
                 }
@@ -1068,7 +1068,7 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
         }
     } else {
         // Not the start of a new output stripe, accumulate mac data to ACCU
-        cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, assembly, not the first stripe of a channel operation\n"));
+        //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, assembly, not the first stripe of a channel operation\n"));
         for (mac_cell_iter = 0; mac_cell_iter < MAC_CELL_NUM; mac_cell_iter ++) {
             for (atom_iter=0; atom_iter<atom_per_mac_cell; atom_iter++) {
                 switch (precision) {
@@ -1084,10 +1084,10 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                             sum_tmp = MIN_INT_48BITS;
                         assembly_sram_group_[assembly_idx] = sum_tmp;
 #if LOG_DETAIL
-                        cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
-                        cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
-                        cslDebug((50, "    int8_mac_data: 0x%016x\n", (uint32_t)int8_mac_data.to_int()));
-                        cslDebug((50, "    int8 assembly_sram_group_[%d]: 0x%016x\n", assembly_idx, (uint32_t)assembly_sram_group_[assembly_idx].to_int()));
+                        //cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
+                        //cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
+                        //cslDebug((50, "    int8_mac_data: 0x%016x\n", (uint32_t)int8_mac_data.to_int()));
+                        //cslDebug((50, "    int8 assembly_sram_group_[%d]: 0x%016x\n", assembly_idx, (uint32_t)assembly_sram_group_[assembly_idx].to_int()));
 #endif
                         // Second element of the mac_cell for INT8
                         payload_idx ++;
@@ -1101,8 +1101,8 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                             sum_tmp = MIN_INT_48BITS;
                         assembly_sram_group_[assembly_idx] = sum_tmp;
 #if LOG_DETAIL
-                        cslDebug((50, "    int8_mac_data: 0x%016x\n", (uint32_t)int8_mac_data.to_int()));
-                        cslDebug((50, "    int8 assembly_sram_group_[%d]: 0x%016x\n", assembly_idx, (uint32_t)assembly_sram_group_[assembly_idx].to_int()));
+                        //cslDebug((50, "    int8_mac_data: 0x%016x\n", (uint32_t)int8_mac_data.to_int()));
+                        //cslDebug((50, "    int8 assembly_sram_group_[%d]: 0x%016x\n", assembly_idx, (uint32_t)assembly_sram_group_[assembly_idx].to_int()));
 #endif
                         break;
                     case DATA_FORMAT_INT16:
@@ -1117,10 +1117,10 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                             sum_tmp = MIN_INT_48BITS;
                         assembly_sram_group_[assembly_idx] = sum_tmp;
 #if LOG_DETAIL
-                        cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
-                        cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
-                        cslDebug((50, "    int16_mac_data is 0x%016lx\n", (int64_t)int16_mac_data.to_int64()));
-                        cslDebug((50, "    int16 assembly_sram_group_[%d]: 0x%016lx\n", assembly_idx, (int64_t)assembly_sram_group_[assembly_idx].to_int64()));
+                        //cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
+                        //cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
+                        //cslDebug((50, "    int16_mac_data is 0x%016lx\n", (int64_t)int16_mac_data.to_int64()));
+                        //cslDebug((50, "    int16 assembly_sram_group_[%d]: 0x%016lx\n", assembly_idx, (int64_t)assembly_sram_group_[assembly_idx].to_int64()));
 #endif
                         break;
                     case DATA_FORMAT_FP16:
@@ -1132,10 +1132,10 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                         cacc_fp16_add(&fp16_accu_data, fp16_mac_data);
                         assembly_sram_group_[assembly_idx] = fp16_accu_data;
 #if LOG_DETAIL
-                        cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
-                        cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
-                        cslDebug((50, "    fp16_mac_data is 0x%016lx\n", (int64_t)fp16_mac_data.to_int64()));
-                        cslDebug((50, "    fp16 assembly_sram_group_[%d]: 0x%016lx\n", assembly_idx, (int64_t)assembly_sram_group_[assembly_idx].to_int64()));
+                        //cslDebug((50, "    mac_cell_iter is 0x%x\n", mac_cell_iter));
+                        //cslDebug((50, "    atom_iter is 0x%x\n", atom_iter));
+                        //cslDebug((50, "    fp16_mac_data is 0x%016lx\n", (int64_t)fp16_mac_data.to_int64()));
+                        //cslDebug((50, "    fp16 assembly_sram_group_[%d]: 0x%016lx\n", assembly_idx, (int64_t)assembly_sram_group_[assembly_idx].to_int64()));
 #endif
                         break;
                     default:
@@ -1148,7 +1148,7 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
     if (1 == payload->pd.nvdla_stripe_info.channel_end) {   // The last stripe of current channel
         // Come to a channel end. Finish current stripe. We got the sums of current stripe.
         assembly_sram_group_idx_available_ = assembly_sram_group_idx_working_;
-        cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of channel operation, assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
+        //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of channel operation, assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
         assembly_sram_group_idx_available_incr_.notify();
         if ((assembly_sram_group_idx_available_ - assembly_sram_group_idx_fetched_) > SRAM_GROUP_SIZE)   // In unit of 16 entries in buffer
             FAIL(("cacc assembly group will overflow. assembly_sram_group_idx_available_=%d assembly_sram_group_idx_fetched_=%d\n", assembly_sram_group_idx_available_, assembly_sram_group_idx_fetched_));
@@ -1157,10 +1157,10 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
             assembly_sram_group_idx_working_ += 2 * atom_per_mac_cell;
         else
             assembly_sram_group_idx_working_ += atom_per_mac_cell;
-        cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of channel operation, assembly_sram_group_idx_working_=0x%x\n", assembly_sram_group_idx_working_));
+        //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of channel operation, assembly_sram_group_idx_working_=0x%x\n", assembly_sram_group_idx_working_));
         if (1 == payload->pd.nvdla_stripe_info.stripe_end) {
             has_ongoing_channel_operation_ = false;
-            cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of channel operation and end of stripe operation\n"));
+            //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of channel operation and end of stripe operation\n"));
         }
         input_first_channel = false;
     } else {
@@ -1180,8 +1180,8 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                     assembly_sram_group_idx_working_ = assembly_sram_group_idx_available_ + atom_per_mac_cell;
             }
             has_ongoing_channel_operation_ = true;
-            cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of stripe operation, assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
-            cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of stripe operation, assembly_sram_group_idx_working_=0x%x\n", assembly_sram_group_idx_working_));
+            //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of stripe operation, assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
+            //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of stripe operation, assembly_sram_group_idx_working_=0x%x\n", assembly_sram_group_idx_working_));
         }
         else {  // Not stripe end and not channel end
             //assembly_sram_group_idx_working_ points to the next entry for process
@@ -1189,17 +1189,17 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
                 assembly_sram_group_idx_working_ += 2 * atom_per_mac_cell;
             else
                 assembly_sram_group_idx_working_ += atom_per_mac_cell;
-            cslDebug((50, "atom_per_mac_cell=%d, working:%d\n", atom_per_mac_cell, assembly_sram_group_idx_working_));
-            cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, not end of stripe operation, assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
-            cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, not end of stripe operation, assembly_sram_group_idx_working_=0x%x\n", assembly_sram_group_idx_working_));
+            //cslDebug((50, "atom_per_mac_cell=%d, working:%d\n", atom_per_mac_cell, assembly_sram_group_idx_working_));
+            //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, not end of stripe operation, assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
+            //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, not end of stripe operation, assembly_sram_group_idx_working_=0x%x\n", assembly_sram_group_idx_working_));
         }
     }
 
     if ((1 == payload->pd.nvdla_stripe_info.stripe_end) && (1 == payload->pd.nvdla_stripe_info.layer_end)) {
         mac2cacc_count=0;
-        cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of layer.\n"));
-        cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of layer, assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
-        cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of layer, assembly_sram_group_idx_working_=0x%x\n", assembly_sram_group_idx_working_));
+        //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of layer.\n"));
+        //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of layer, assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
+        //cslDebug((50, "NV_NVDLA_cacc::mac2accu_b_transport, end of layer, assembly_sram_group_idx_working_=0x%x\n", assembly_sram_group_idx_working_));
 
         is_assembly_working_ = false;
         input_first_channel  = true;    // For next layer
@@ -1208,15 +1208,15 @@ void NV_NVDLA_cacc::mac2accu_b_transport(nvdla_mac2accu_data_concat_if_t* payloa
         saved_assembly_sram_group_idx_working_ = assembly_sram_group_idx_working_;
         // notify event cacc_done_, cacc can switch to next layer
         cacc_done_.notify();
-        cslInfo(("cacc after cacc_done_.notify\n"));
+        //cslInfo(("cacc after cacc_done_.notify\n"));
         prev_layer_assembly_sram_group_idx_available_ = assembly_sram_group_idx_available_;
     }
 }
 
 void NV_NVDLA_cacc::WaitUntilThereIsAvaliableDataInAssemblyGroup () {
     while (true) {
-        cslDebug((50, "assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
-        cslDebug((50, "assembly_sram_group_idx_fetched_=0x%x\n", assembly_sram_group_idx_fetched_));
+        //cslDebug((50, "assembly_sram_group_idx_available_=0x%x\n", assembly_sram_group_idx_available_));
+        //cslDebug((50, "assembly_sram_group_idx_fetched_=0x%x\n", assembly_sram_group_idx_fetched_));
         if (assembly_sram_group_idx_available_ <= assembly_sram_group_idx_fetched_) {
             wait (assembly_sram_group_idx_available_incr_);
         }
@@ -1228,8 +1228,8 @@ void NV_NVDLA_cacc::WaitUntilThereIsAvaliableDataInAssemblyGroup () {
 
 void NV_NVDLA_cacc::WaitUntilThereIsAvaliableDataInDeliveryGroup () {
     while (true) {
-        cslDebug((50, "delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
-        cslDebug((50, "delivery_sram_group_idx_fetched_=0x%x\n", delivery_sram_group_idx_fetched_));
+        //cslDebug((50, "delivery_sram_group_idx_available_=0x%x\n", delivery_sram_group_idx_available_));
+        //cslDebug((50, "delivery_sram_group_idx_fetched_=0x%x\n", delivery_sram_group_idx_fetched_));
         if (delivery_sram_group_idx_available_ <= delivery_sram_group_idx_fetched_) {
             wait (delivery_sram_group_idx_available_incr_);
         }
@@ -1294,8 +1294,8 @@ void NV_NVDLA_cacc::cacc_fp16_add(sc_uint<FP16_ALEN> *fp16_accu_data, sc_uint<44
     mac_in_mantisa = mac_in_mantisa_u; 
     accu_in_mantisa = accu_in_mantisa_u;
 
-    cslDebug((50, "  input FP44 is  : 0x%016lx\n",(int64_t)fp16_mac_data ));
-    cslDebug((50, "  input FP48/FP39 is  : 0x%016lx\n",(int64_t)(fp16_accu_data->range(FP16_ALEN-1,0)) ));
+    //cslDebug((50, "  input FP44 is  : 0x%016lx\n",(int64_t)fp16_mac_data ));
+    //cslDebug((50, "  input FP48/FP39 is  : 0x%016lx\n",(int64_t)(fp16_accu_data->range(FP16_ALEN-1,0)) ));
 
     if(FP16DEBUG_DETAIL){
         //cout <<"step0:input original FP44 is "<<hex<< fp16_mac_data <<endl;
@@ -1436,7 +1436,7 @@ void NV_NVDLA_cacc::cacc_fp16_add(sc_uint<FP16_ALEN> *fp16_accu_data, sc_uint<44
 			 real_sum_exp = bigger_exp;
 		}
 		else {
-		cslDebug((50, "NV_NVDLA_cacc::cacc_fp16_add, error path!! need debug.\n"));	
+		//cslDebug((50, "NV_NVDLA_cacc::cacc_fp16_add, error path!! need debug.\n"));
 	}
 
 
@@ -1487,7 +1487,7 @@ void NV_NVDLA_cacc::cacc_fp16_add(sc_uint<FP16_ALEN> *fp16_accu_data, sc_uint<44
 
 	*fp16_accu_data =(sum_exp,sum_mantisa_final);
     //if(FP16DEBUG_DETAIL){cout<< "step5:the output FP48/FP39 is "<<hex<<fp16_accu_data->range(FP16_ALEN-1,0)<<endl;}
-    cslDebug((50, " ***output FP48/FP39 is  : 0x%016lx\n",(int64_t)(fp16_accu_data->range(FP16_ALEN-1,0)) ));
+    //cslDebug((50, " ***output FP48/FP39 is  : 0x%016lx\n",(int64_t)(fp16_accu_data->range(FP16_ALEN-1,0)) ));
 
 
 //high level checker, for debug,transfer FP48/FP39 output to float
@@ -1536,7 +1536,7 @@ void NV_NVDLA_cacc::cacc_fp48_to_fp32(sc_int<32> *fp32_to_sdp, sc_uint<FP16_ALEN
     sc_uint<8> out_exp;
     sc_uint<24> out_mantisa_u;
 
-    cslDebug((50, " FP48-2-32, input FP48/FP39 is  : 0x%016lx\n", (int64_t)fp16_accu_data ));
+    //cslDebug((50, " FP48-2-32, input FP48/FP39 is  : 0x%016lx\n", (int64_t)fp16_accu_data ));
     accu_in_mantisa = accu_in_mantisa_u;
 	//is NaN
 	if(accu_in_exp.and_reduce()){
@@ -1595,7 +1595,7 @@ void NV_NVDLA_cacc::cacc_fp48_to_fp32(sc_int<32> *fp32_to_sdp, sc_uint<FP16_ALEN
     //cout <<"step6:the FP48/FP39 input is "<<hex<< fp16_accu_data.range(FP16_ALEN-1,0)<<endl;
     //cout <<"* the FP32 output is * 0x"<<hex<< fp32_to_sdp->range(31,0) <<endl;
     }
-    cslDebug((50, "FP48-2-32, output FP32 is  : 0x%016lx\n", (int64_t)(fp32_to_sdp->range(31,0)) ));
+    //cslDebug((50, "FP48-2-32, output FP32 is  : 0x%016lx\n", (int64_t)(fp32_to_sdp->range(31,0)) ));
 
 
 // pure C high level checker.
diff --git a/cmod/cacc/gen/cacc_reg_model.cpp b/cmod/cacc/gen/cacc_reg_model.cpp
index 07e0452..337c053 100644
--- a/cmod/cacc/gen/cacc_reg_model.cpp
+++ b/cmod/cacc/gen/cacc_reg_model.cpp
@@ -85,7 +85,7 @@ bool cacc_reg_model::CaccAccessRegister(uint32_t reg_addr, uint32_t & data, bool
                 cacc_register_group_0->SetWritable(offset, data);
                 if (cacc_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_cacc_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cacc_reg_model::CaccAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "cacc_reg_model::CaccAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -97,7 +97,7 @@ bool cacc_reg_model::CaccAccessRegister(uint32_t reg_addr, uint32_t & data, bool
                 cacc_register_group_1->SetWritable(offset, data);
                 if (cacc_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_cacc_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cacc_reg_model::CaccAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "cacc_reg_model::CaccAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/cbuf/NV_NVDLA_cbuf.cpp b/cmod/cbuf/NV_NVDLA_cbuf.cpp
index 1f68359..38d2924 100644
--- a/cmod/cbuf/NV_NVDLA_cbuf.cpp
+++ b/cmod/cbuf/NV_NVDLA_cbuf.cpp
@@ -56,12 +56,12 @@ void NV_NVDLA_cbuf::cdma2buf_dat_wr_b_transport(int ID, nvdla_ram_wr_port_WADDR_
     if (payload->addr >= (CBUF_BANK_NUM - 1) * CBUF_ENTRY_PER_BANK ) {
         FAIL(("NV_NVDLA_cbuf::sc2buf_dat_wr_b_transport, data address shall not access the last bank."));
     }
-    cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_dat_wr_b_transport, payload->addr=0x%x\n", uint32_t (payload->addr)));
-    cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_dat_wr_b_transport, payload->hsel=%d\n", uint32_t (payload->hsel)));
-    cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_dat_wr_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
-    cslDebug((70, "NV_NVDLA_cbuf::cdma2buf_dat_wr_b_transport, payload->data:\n"));
+    //cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_dat_wr_b_transport, payload->addr=0x%x\n", uint32_t (payload->addr)));
+    //cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_dat_wr_b_transport, payload->hsel=%d\n", uint32_t (payload->hsel)));
+    //cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_dat_wr_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
+    //cslDebug((70, "NV_NVDLA_cbuf::cdma2buf_dat_wr_b_transport, payload->data:\n"));
     for (idx = 0; idx < CBUF_HALF_ENTRY_SIZE; idx ++) {
-        cslDebug((70, "    0x%02x\n", uint32_t (payload_data_ptr[idx])));
+        //cslDebug((70, "    0x%02x\n", uint32_t (payload_data_ptr[idx])));
     } 
     memcpy(&cbuf_ram_[cbuf_ram_byte_addr], payload_data_ptr, CBUF_HALF_ENTRY_SIZE);
 }
@@ -78,12 +78,12 @@ void NV_NVDLA_cbuf::cdma2buf_wt_wr_b_transport(int ID, nvdla_ram_wr_port_WADDR_1
     else if (payload->addr >= CBUF_BANK_NUM * CBUF_ENTRY_PER_BANK) {
         FAIL(("NV_NVDLA_cbuf::sc2buf_wt_wr_b_transport, weight address is larger than the number of entries of cbuf"));
     }
-    cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_wt_wr_b_transport, payload->addr=0x%x\n", uint32_t (payload->addr)));
-    cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_wt_wr_b_transport, payload->hsel=%d\n", uint32_t (payload->hsel)));
-    cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_wt_wr_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
-    cslDebug((70, "NV_NVDLA_cbuf::cdma2buf_wt_wr_b_transport, payload->data:\n"));
+    //cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_wt_wr_b_transport, payload->addr=0x%x\n", uint32_t (payload->addr)));
+    //cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_wt_wr_b_transport, payload->hsel=%d\n", uint32_t (payload->hsel)));
+    //cslDebug((50, "NV_NVDLA_cbuf::cdma2buf_wt_wr_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
+    //cslDebug((70, "NV_NVDLA_cbuf::cdma2buf_wt_wr_b_transport, payload->data:\n"));
     for (idx = 0; idx < CBUF_HALF_ENTRY_SIZE; idx ++) {
-        cslDebug((70, "    0x%02x\n", uint32_t (payload_data_ptr[idx])));
+        //cslDebug((70, "    0x%02x\n", uint32_t (payload_data_ptr[idx])));
     } 
     memcpy(&cbuf_ram_[cbuf_ram_byte_addr], payload_data_ptr, CBUF_HALF_ENTRY_SIZE);
 }
@@ -98,13 +98,13 @@ void NV_NVDLA_cbuf::sc2buf_dat_rd_b_transport(int ID, nvdla_ram_rd_valid_port_RA
     if (payload_addr >= (CBUF_BANK_NUM - 1) * CBUF_ENTRY_PER_BANK ) {
         FAIL(("NV_NVDLA_cbuf::sc2buf_dat_rd_b_transport, data address shall not access the last bank."));
     }
-    cslDebug((50, "NV_NVDLA_cbuf::sc2buf_dat_rd_b_transport, payload_addr=0x%x\n", uint32_t (payload_addr)));
-    cslDebug((50, "NV_NVDLA_cbuf::sc2buf_dat_rd_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
+    //cslDebug((50, "NV_NVDLA_cbuf::sc2buf_dat_rd_b_transport, payload_addr=0x%x\n", uint32_t (payload_addr)));
+    //cslDebug((50, "NV_NVDLA_cbuf::sc2buf_dat_rd_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
     payload_data_ptr = reinterpret_cast <uint8_t *> (payload->nvdla_ram_data_valid_DATA_WIDTH_1024_ECC_SIZE_1.data);
     memcpy(payload_data_ptr, &cbuf_ram_[cbuf_ram_byte_addr], CBUF_ENTRY_SIZE);
-    cslDebug((70, "NV_NVDLA_cbuf::sc2buf_dat_rd_b_transport, cbuf_ram_ data is\n"));
+    //cslDebug((70, "NV_NVDLA_cbuf::sc2buf_dat_rd_b_transport, cbuf_ram_ data is\n"));
     for (idx = 0; idx < CBUF_ENTRY_SIZE; idx ++) {
-        cslDebug((70, "    0x%02x\n", uint32_t (cbuf_ram_[cbuf_ram_byte_addr + idx])));
+        //cslDebug((70, "    0x%02x\n", uint32_t (cbuf_ram_[cbuf_ram_byte_addr + idx])));
     }
 }
 
@@ -121,13 +121,13 @@ void NV_NVDLA_cbuf::sc2buf_wt_rd_b_transport(int ID, nvdla_ram_rd_valid_port_RAD
     else if (payload_addr >= CBUF_BANK_NUM * CBUF_ENTRY_PER_BANK) {
         FAIL(("NV_NVDLA_cbuf::sc2buf_wt_rd_b_transport, weight address is larger than the number of entries of cbuf"));
     }
-    cslDebug((50, "NV_NVDLA_cbuf::sc2buf_wt_rd_b_transport, payload_addr=0x%x\n", uint32_t (payload_addr)));
-    cslDebug((50, "NV_NVDLA_cbuf::sc2buf_wt_rd_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
+    //cslDebug((50, "NV_NVDLA_cbuf::sc2buf_wt_rd_b_transport, payload_addr=0x%x\n", uint32_t (payload_addr)));
+    //cslDebug((50, "NV_NVDLA_cbuf::sc2buf_wt_rd_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
     payload_data_ptr = reinterpret_cast <uint8_t *> (payload->nvdla_ram_data_valid_DATA_WIDTH_1024_ECC_SIZE_1.data);
     memcpy(payload_data_ptr, &cbuf_ram_[cbuf_ram_byte_addr], CBUF_ENTRY_SIZE);
-    cslDebug((70, "NV_NVDLA_cbuf::sc2buf_wt_rd_b_transport, cbuf_ram_ data is\n"));
+    //cslDebug((70, "NV_NVDLA_cbuf::sc2buf_wt_rd_b_transport, cbuf_ram_ data is\n"));
     for (idx = 0; idx < CBUF_ENTRY_SIZE; idx ++) {
-        cslDebug((70, "    0x%02x\n", uint32_t (cbuf_ram_[cbuf_ram_byte_addr + idx])));
+        //cslDebug((70, "    0x%02x\n", uint32_t (cbuf_ram_[cbuf_ram_byte_addr + idx])));
     }
 }
 
@@ -143,13 +143,13 @@ void NV_NVDLA_cbuf::sc2buf_wmb_rd_b_transport(int ID, nvdla_ram_rd_valid_port_RA
     if ((payload_addr < (CBUF_BANK_NUM - 1) * CBUF_ENTRY_PER_BANK) || (payload_addr >= CBUF_BANK_NUM * CBUF_ENTRY_PER_BANK)) {
         FAIL(("NV_NVDLA_cbuf::sc2buf_wmb_rd_b_transport, wmb address should access the last bank."));
     }
-    cslDebug((50, "NV_NVDLA_cbuf::sc2buf_wmb_rd_b_transport, payload_addr=0x%x\n", uint32_t (payload_addr)));
-    cslDebug((50, "NV_NVDLA_cbuf::sc2buf_wmb_rd_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
+    //cslDebug((50, "NV_NVDLA_cbuf::sc2buf_wmb_rd_b_transport, payload_addr=0x%x\n", uint32_t (payload_addr)));
+    //cslDebug((50, "NV_NVDLA_cbuf::sc2buf_wmb_rd_b_transport, cbuf_ram_byte_addr is 0x%x\n", cbuf_ram_byte_addr));
     payload_data_ptr = reinterpret_cast <uint8_t *> (payload->nvdla_ram_data_valid_DATA_WIDTH_1024_ECC_SIZE_1.data);
     memcpy(payload_data_ptr, &cbuf_ram_[cbuf_ram_byte_addr], CBUF_ENTRY_SIZE);
-    cslDebug((70, "NV_NVDLA_cbuf::sc2buf_wmb_rd_b_transport, cbuf_ram_ data is\n"));
+    //cslDebug((70, "NV_NVDLA_cbuf::sc2buf_wmb_rd_b_transport, cbuf_ram_ data is\n"));
     for (idx = 0; idx < CBUF_ENTRY_SIZE; idx ++) {
-        cslDebug((70, "    0x%02x\n", uint32_t (cbuf_ram_[cbuf_ram_byte_addr + idx])));
+        //cslDebug((70, "    0x%02x\n", uint32_t (cbuf_ram_[cbuf_ram_byte_addr + idx])));
     }
 }
 
diff --git a/cmod/cdma/NV_NVDLA_cdma.cpp b/cmod/cdma/NV_NVDLA_cdma.cpp
index 7d29b05..75e8c1c 100644
--- a/cmod/cdma/NV_NVDLA_cdma.cpp
+++ b/cmod/cdma/NV_NVDLA_cdma.cpp
@@ -215,16 +215,16 @@ void NV_NVDLA_cdma::CdmaHardwareLayerExecutionTrigger () {
     cdma_wgs_fetch_done_fifo_->read();
     cdma_wmb_fetch_done_fifo_->read();
     cdma_weight_fetch_done_fifo_->read();
-    cslInfo(("NV_NVDLA_cdma::CdmaHardwareLayerExecutionTrigger. HW Layer done\n"));
+    //cslInfo(("NV_NVDLA_cdma::CdmaHardwareLayerExecutionTrigger. HW Layer done\n"));
 }
 
 void NV_NVDLA_cdma::ActDataReadRequestSequenceThread () {
     uint32_t cdma_act_data_operation_mode;
     uint8_t  cdma_input_data_format_;
     while (true) {
-        cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, before cdma_kickoff_\n"));
+        //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, before cdma_kickoff_\n"));
         wait(cdma_kickoff_);
-        cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, after cdma_kickoff_\n"));
+        //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, after cdma_kickoff_\n"));
 
         if (cdma_conv_mode_ == NVDLA_CDMA_D_MISC_CFG_0_CONV_MODE_DIRECT) {
             if (cdma_datain_format_ == NVDLA_CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_FEATURE)
@@ -242,30 +242,30 @@ void NV_NVDLA_cdma::ActDataReadRequestSequenceThread () {
             // if (cdma_data_reuse_)
             //    FAIL(("Can't reuse data when first layer\n"));
 
-            cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread dat_first_layer. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
+            //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread dat_first_layer. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
         }
         else if ((cdma_req_prev_conv_mode_ != cdma_conv_mode_) || (cdma_req_prev_data_bank_ != cdma_data_bank_) || (cdma_req_prev_weight_bank_ != cdma_weight_bank_) || (cdma_req_prev_input_data_format_ != cdma_input_data_format_)) {
             // Not reuse data of previous layer. wait until cbuf is empty
             if (cdma_req_prev_data_bank_ != cdma_data_bank_) {
-                cslInfo(("Before WaitUntilDataEntryPlanedIndexEqualEntryFreeIndex\n"));
+                //cslInfo(("Before WaitUntilDataEntryPlanedIndexEqualEntryFreeIndex\n"));
                 WaitUntilDataEntryPlanedIndexEqualEntryFreeIndex();
-                cslInfo(("After WaitUntilDataEntryPlanedIndexEqualEntryFreeIndex\n"));
+                //cslInfo(("After WaitUntilDataEntryPlanedIndexEqualEntryFreeIndex\n"));
                 data_entry_idx_free_    = (cdma_data_bank_ + 1) * CBUF_ENTRY_PER_BANK - 1;
                 data_entry_idx_working_ = 0;
                 data_entry_idx_planed_  = -1;
-                cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread not dat_first_layer. Bank changed, not reuse data. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
+                //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread not dat_first_layer. Bank changed, not reuse data. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
             } else {
                 // Continue to use cbuf following the end of previous layer
                 // data_entry_idx_free_ will be updated by sc2cdma
                 data_entry_idx_working_ = data_entry_idx_planed_ + 1;
-                cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread not dat_first_layer. Not reuse data. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
+                //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread not dat_first_layer. Not reuse data. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
             }
         }
         else if (cdma_req_prev_skip_data_rls_ && cdma_data_reuse_ && (cdma_req_prev_conv_mode_ == cdma_conv_mode_) && (cdma_req_prev_data_bank_ == cdma_data_bank_) && 
             (cdma_req_prev_weight_bank_ == cdma_weight_bank_) && (cdma_req_prev_input_data_format_ == cdma_input_data_format_)) {
             // Reuse all data of previous layer. Skip fetching new data.
             cdma_req_prev_skip_data_rls_= cdma_skip_data_rls_;
-            cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread not dat_first_layer. Reuse all data of previous layer. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
+            //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread not dat_first_layer. Reuse all data of previous layer. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
             continue;
         }
         else {
@@ -273,7 +273,7 @@ void NV_NVDLA_cdma::ActDataReadRequestSequenceThread () {
             // Continue to use cbuf following the end of previous layer
             // data_entry_idx_free_ will be updated by sc2cdma
             data_entry_idx_working_ = data_entry_idx_planed_ + 1;
-            cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread not dat_first_layer. Partial resue or not reuse data. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
+            //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread not dat_first_layer. Partial resue or not reuse data. data_entry_idx_free_=0x%x data_entry_idx_working_=0x%x data_entry_idx_planed_=0x%x\n", data_entry_idx_free_, data_entry_idx_working_, data_entry_idx_planed_));
         }
 
         if ( NVDLA_CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_FEATURE == cdma_datain_format_) {
@@ -316,19 +316,19 @@ void NV_NVDLA_cdma::ActDataReadRequestSequenceThread () {
         switch(cdma_act_data_operation_mode) {
             case ACT_MODE_DIRECT_CONV_NONE_BATCH:
             case ACT_MODE_DIRECT_CONV_BATCH:
-                cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, before DirectConvDataRequestSequencerCommon\n"));
+                //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, before DirectConvDataRequestSequencerCommon\n"));
                 DirectConvDataRequestSequencerCommon();
-                cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, after DirectConvDataRequestSequencerCommon\n"));
+                //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, after DirectConvDataRequestSequencerCommon\n"));
                 break;
             case ACT_MODE_WINOGRAD_CONV:
-                cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, before WinotConvDataRequestSequencerCommon\n"));
+                //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, before WinotConvDataRequestSequencerCommon\n"));
                 WinoConvDataRequestSequencerCommon();
-                cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, after WinoConvDataRequestSequencerCommon\n"));
+                //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, after WinoConvDataRequestSequencerCommon\n"));
                 break;
             case ACT_MODE_DIRECT_PIXEL:
-                cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, before ImageConvDataRequestSequencerCommon\n"));
+                //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, before ImageConvDataRequestSequencerCommon\n"));
                 ImageConvDataRequestSequencerCommon();
-                cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, after ImageConvDataRequestSequencerCommon\n"));
+                //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, after ImageConvDataRequestSequencerCommon\n"));
                 break;
 #pragma CTC SKIP
             default:
@@ -347,7 +347,7 @@ void NV_NVDLA_cdma::ActDataReadRequestSequenceThread () {
                 cdma_req_prev_input_data_format_ = INPUT_DATA_FORMAT_IMAGE;
         } else
             cdma_req_prev_input_data_format_ = INPUT_DATA_FORMAT_WINO;
-        cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, end of current layer\n"));
+        //cslInfo(("NV_NVDLA_cdma::ActDataReadRequestSequenceThread, end of current layer\n"));
     }
 }
 
@@ -371,10 +371,10 @@ void NV_NVDLA_cdma::ActDataReadResponseSequenceThread () {
             cdma_resp_prev_skip_data_rls_= cdma_skip_data_rls_;
             cdma_dat2glb_done_intr[cdma_consumer_].write(true);
             cdma_data_fetch_done_fifo_->write(true);
-            cslInfo(("NV_NVDLA_cdma::ActDataReadResponseSequenceThread Begin. Reuse all data. CDMA Data Fetch Done. consumer pointer is %d\n", cdma_consumer_));
+            //cslInfo(("NV_NVDLA_cdma::ActDataReadResponseSequenceThread Begin. Reuse all data. CDMA Data Fetch Done. consumer pointer is %d\n", cdma_consumer_));
             continue;
         } else {
-            cslInfo(("NV_NVDLA_cdma::ActDataReadResponseSequenceThread Begin. Not reuse all data.\n"));
+            //cslInfo(("NV_NVDLA_cdma::ActDataReadResponseSequenceThread Begin. Not reuse all data.\n"));
         }
 
         if ( NVDLA_CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_FEATURE == cdma_datain_format_) {
@@ -436,20 +436,20 @@ void NV_NVDLA_cdma::ActDataReadResponseSequenceThread () {
         if (act_data_read_rsp_fifo_->num_available() != 0)
             FAIL(("act_data_read_rsp_fifo_ should be empty in the end of NV_NVDLA_cdma::ActDataReadResponseSequenceThread. act_data_read_rsp_fifo_->num_available()=0x%x\n", act_data_read_rsp_fifo_->num_available()));
 #pragma CTC ENDSKIP
-        cslInfo(("NV_NVDLA_cdma::ActDataReadResponseSequenceThread end of layer\n"));
+        //cslInfo(("NV_NVDLA_cdma::ActDataReadResponseSequenceThread end of layer\n"));
 
         cdma_dat2glb_done_intr[cdma_consumer_].write(true);
         cdma_data_fetch_done_fifo_->write(true);
-        cslInfo(("CDMA Data Fetch Done. consumer pointer is %d\n", cdma_consumer_));
+        //cslInfo(("CDMA Data Fetch Done. consumer pointer is %d\n", cdma_consumer_));
     }
 }
 
 void NV_NVDLA_cdma::WeightReadRequestSequenceThread () {
     uint8_t wt_req_input_data_format_;
     while (true) {
-        cslInfo(("before wait cdma_kickoff_\n"));
+        //cslInfo(("before wait cdma_kickoff_\n"));
         wait(cdma_kickoff_);
-        cslInfo(("wait cdma_kickoff_ done\n"));
+        //cslInfo(("wait cdma_kickoff_ done\n"));
 
         if (cdma_conv_mode_ == NVDLA_CDMA_D_MISC_CFG_0_CONV_MODE_DIRECT) {
             if (cdma_datain_format_ == NVDLA_CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_FEATURE)
@@ -468,7 +468,7 @@ void NV_NVDLA_cdma::WeightReadRequestSequenceThread () {
             //if (cdma_weight_reuse_)
             //    FAIL(("Can't reuse weight when first layer\n"));
 
-            cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread wt_first_layer. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
+            //cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread wt_first_layer. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
         }
         else if ((wt_req_cdma_prev_conv_mode_ != cdma_conv_mode_) || (wt_req_cdma_prev_weight_bank_ != cdma_weight_bank_) || (wt_req_cdma_prev_data_bank_ != cdma_data_bank_) || (wt_req_prev_input_data_format_ != wt_req_input_data_format_)) {
             if ((wt_req_cdma_prev_weight_bank_ != cdma_weight_bank_) || (wt_req_cdma_prev_data_bank_ != cdma_data_bank_)) {
@@ -479,23 +479,23 @@ void NV_NVDLA_cdma::WeightReadRequestSequenceThread () {
                 weight_entry_idx_planed_    = -1;
                 weight_byte_idx_planed_     = 0;
 
-                cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread not first_layer. BANK Changed. Not reuse weight. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
+                //cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread not first_layer. BANK Changed. Not reuse weight. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
             }
             else {
                 weight_entry_idx_working_ = weight_entry_idx_planed_ + 1;
-                cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread not first_layer. Not reuse weight. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
+                //cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread not first_layer. Not reuse weight. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
             }
         }
         else if (wt_req_cdma_prev_skip_weight_rls_ && cdma_weight_reuse_ && (wt_req_cdma_prev_conv_mode_ == cdma_conv_mode_)
                 && (wt_req_cdma_prev_data_bank_ == cdma_data_bank_) && (wt_req_cdma_prev_weight_bank_ == cdma_weight_bank_) && (wt_req_prev_input_data_format_ == wt_req_input_data_format_)) {
             // reuse entire weight of previous layer. Skip fetching new weight
             wt_req_cdma_prev_skip_weight_rls_ = cdma_skip_weight_rls_;
-            cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread not first_layer. Reuse entire weight. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
+            //cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread not first_layer. Reuse entire weight. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
             continue;
         }
         else { // not reuse weight of previous layer, Continue to use cbuf following the end of previous layer
             weight_entry_idx_working_ = weight_entry_idx_planed_ + 1;
-            cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread not first_layer. Not reuse weight. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
+            //cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread not first_layer. Not reuse weight. weight_entry_idx_free_=0x%x weight_entry_idx_working_=0x%x weight_entry_idx_planed_=0x%x weight_byte_idx_planed_=0x%x\n", weight_entry_idx_free_, weight_entry_idx_working_, weight_entry_idx_planed_, weight_byte_idx_planed_));
 
 #pragma CTC SKIP
             // Check reuse
@@ -513,9 +513,9 @@ void NV_NVDLA_cdma::WeightReadRequestSequenceThread () {
         // For UVM:  the WGS read request should begin before weight read request to make sure that wgs_buffer_ is initialzed
         cdma_wgs2wt_sync_fifo_->read();
 
-        cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread, before DirectConvWeightRequestSequencerCommon\n"));
+        //cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread, before DirectConvWeightRequestSequencerCommon\n"));
         DirectConvWeightRequestSequencerCommon();
-        cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread, after DirectConvWeightRequestSequencerCommon\n"));
+        //cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread, after DirectConvWeightRequestSequencerCommon\n"));
 
         wt_req_cdma_prev_skip_weight_rls_ = cdma_skip_weight_rls_;
         wt_req_cdma_prev_weight_bank_     = cdma_weight_bank_;
@@ -529,7 +529,7 @@ void NV_NVDLA_cdma::WeightReadRequestSequenceThread () {
                 wt_req_prev_input_data_format_ = INPUT_DATA_FORMAT_IMAGE;
         } else
             wt_req_prev_input_data_format_ = INPUT_DATA_FORMAT_WINO;
-        cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread HW layer done\n"));
+        //cslInfo(("NV_NVDLA_cdma::WeightReadRequestSequenceThread HW layer done\n"));
     }
 }
 
@@ -556,11 +556,11 @@ void NV_NVDLA_cdma::WeightReadResponseSequenceThread () {
             cdma_wmb_fetch_done2wt_fifo_->read();
             cdma_wt2glb_done_intr[cdma_consumer_].write(true);
             cdma_weight_fetch_done_fifo_->write(true);
-            cslInfo(("Reuse weight. CDMA Weight Fetch Done. consumer pointer is %d\n", cdma_consumer_));
+            //cslInfo(("Reuse weight. CDMA Weight Fetch Done. consumer pointer is %d\n", cdma_consumer_));
             continue;
         }
         else {
-            cslInfo(("NV_NVDLA_cdma::WeightReadResponseSequenceThread. Not reuse weight. \n"));
+            //cslInfo(("NV_NVDLA_cdma::WeightReadResponseSequenceThread. Not reuse weight. \n"));
         }
 
         if ( NVDLA_CDMA_D_DATAIN_FORMAT_0_DATAIN_FORMAT_FEATURE == cdma_datain_format_) {
@@ -612,7 +612,7 @@ void NV_NVDLA_cdma::WeightReadResponseSequenceThread () {
         cdma_wmb_fetch_done2wt_fifo_->read();
         cdma_wt2glb_done_intr[cdma_consumer_].write(true);
         cdma_weight_fetch_done_fifo_->write(true);
-        cslInfo(("CDMA Weight Fetch Done. consumer pointer is %d\n", cdma_consumer_));
+        //cslInfo(("CDMA Weight Fetch Done. consumer pointer is %d\n", cdma_consumer_));
     }
 }
 
@@ -644,7 +644,7 @@ void NV_NVDLA_cdma::WGSReadRequestSequenceThread () {
         // Not reuse previous layer's wgs
 
         if(cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED) {
-            cslInfo(("NV_NVDLA_cdma::WGSReadRequestSequenceThread, weight is compressed\n"));
+            //cslInfo(("NV_NVDLA_cdma::WGSReadRequestSequenceThread, weight is compressed\n"));
             weight_kernel       = cdma_weight_kernel_ + 1;
             wgs_total_bytes     = weight_kernel * 4;
             if(wgs_buffer_)
@@ -658,7 +658,7 @@ void NV_NVDLA_cdma::WGSReadRequestSequenceThread () {
             ConvWGSRequestSequencerCommon();
         }
         else {
-            cslInfo(("NV_NVDLA_cdma::WGSReadRequestSequenceThread, weight is not compressed\n"));
+            //cslInfo(("NV_NVDLA_cdma::WGSReadRequestSequenceThread, weight is not compressed\n"));
             if (cdma_wt_dma_arbiter_override_enable)
                 cdma_wgs2wt_sync_fifo_->write(true);
         }
@@ -697,18 +697,18 @@ void NV_NVDLA_cdma::WGSReadResponseSequenceThread () {
             // reuse entire weight of previous layer. Skip fetching wgs
             wgs_resp_cdma_prev_skip_weight_rls_ = cdma_skip_weight_rls_;
             cdma_wgs_fetch_done_fifo_->write(true);
-            cslInfo(("CDMA WGS Fetch Done\n"));
+            //cslInfo(("CDMA WGS Fetch Done\n"));
             continue;
         }
 
         // Not reuse previous layer's wgs
 
         if(cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED) {
-            cslInfo(("NV_NVDLA_cdma::WGSReadResponseSequenceThread, weight is compressed\n"));
+            //cslInfo(("NV_NVDLA_cdma::WGSReadResponseSequenceThread, weight is compressed\n"));
             ConvWGSResponseSequencerCommon();
         }
         else {
-            cslInfo(("NV_NVDLA_cdma::WGSReadResponseSequenceThread, weight is not compressed\n"));
+            //cslInfo(("NV_NVDLA_cdma::WGSReadResponseSequenceThread, weight is not compressed\n"));
         }
 
         wgs_resp_cdma_prev_skip_weight_rls_ = cdma_skip_weight_rls_;
@@ -727,7 +727,7 @@ void NV_NVDLA_cdma::WGSReadResponseSequenceThread () {
         cdma_wgs_fetch_done_fifo_->write(true);
         if (!cdma_wt_dma_arbiter_override_enable)   // In SCVE
             cdma_wgs2wt_sync_fifo_->write(true);
-        cslInfo(("CDMA WGS Fetch Done\n"));
+        //cslInfo(("CDMA WGS Fetch Done\n"));
     }
 }
 
@@ -750,27 +750,27 @@ void NV_NVDLA_cdma::WMBReadRequestSequenceThread () {
             wmb_entry_idx_working_ = 0;
             wmb_entry_idx_planed_ = -1;
             wmb_byte_idx_planed_  = 0;
-            cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, wmb_first_layer\n"));
+            //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, wmb_first_layer\n"));
             if(cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED) {
-                cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, weight is compressed\n"));
+                //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, weight is compressed\n"));
                 ConvWMBRequestSequencerCommon();
             }
             else {
-                cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, weight is not compressed\n"));
+                //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, weight is not compressed\n"));
             }
         }
         else if (cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED) {    //current layer is weight compression
-            cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not first layer. weight is compressed\n"));
+            //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not first layer. weight is compressed\n"));
             if (wmb_req_cdma_prev_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED) { //prev layer is weight compression
                 if (wmb_req_cdma_prev_skip_weight_rls_ && cdma_weight_reuse_ && (wmb_req_cdma_prev_conv_mode_ == cdma_conv_mode_)
                         && (wmb_req_cdma_prev_data_bank_ == cdma_data_bank_) && (wmb_req_cdma_prev_weight_bank_ == cdma_weight_bank_) && (wmb_req_prev_input_data_format_ == wmb_req_input_data_format_)) {
                     // reuse entire weight of previous layer. Skip fetching new weight
                     wmb_req_cdma_prev_skip_weight_rls_ = cdma_skip_weight_rls_;
-                    cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, reuse entire weight\n"));
+                    //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, reuse entire weight\n"));
                     continue;
                 } else if ((wmb_req_cdma_prev_weight_bank_ != cdma_weight_bank_) || (wmb_req_cdma_prev_data_bank_ != cdma_data_bank_)) {
                     // Not reuse weight and wait until cbuf is empty and restart from the beginning of wmb banks
-                    cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change. BANK changed, rewind cbuf\n"));
+                    //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change. BANK changed, rewind cbuf\n"));
                     WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex();
                     wmb_entry_idx_free_   = CBUF_ENTRY_PER_BANK - 1;
                     wmb_entry_idx_working_ = 0;
@@ -778,14 +778,14 @@ void NV_NVDLA_cdma::WMBReadRequestSequenceThread () {
                     wmb_byte_idx_planed_  = 0;
                 } else {    // not reuse weight
                     wmb_entry_idx_working_ = wmb_entry_idx_planed_ + 1;
-                    cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change.\n"));
+                    //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change.\n"));
                 }
             } else { //prev layer is not weight compression
                 if (cdma_weight_reuse_)
                     FAIL(("Can't reuse weight when previous layer is not weight compression and current is weight compression\n"));
                 else if ((wmb_req_cdma_prev_weight_bank_ != cdma_weight_bank_) || (wmb_req_cdma_prev_data_bank_ != cdma_data_bank_)) {
                     // Not reuse weight. wait until cbuf is empty and restart from the beginning of wmb banks
-                    cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change. BANK changed, rewind cbuf\n"));
+                    //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change. BANK changed, rewind cbuf\n"));
                     WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex();
                     wmb_entry_idx_free_   = CBUF_ENTRY_PER_BANK - 1;
                     wmb_entry_idx_working_ = 0;
@@ -793,19 +793,19 @@ void NV_NVDLA_cdma::WMBReadRequestSequenceThread () {
                     wmb_byte_idx_planed_  = 0;
                 } else {
                     wmb_entry_idx_working_ = wmb_entry_idx_planed_ + 1;
-                    cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change.\n"));
+                    //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change.\n"));
                 }
             }
-            cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, weight is compressed. before ConvWMBRequestSequencerCommon\n"));
+            //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, weight is compressed. before ConvWMBRequestSequencerCommon\n"));
             ConvWMBRequestSequencerCommon();
-            cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, weight is compressed. after ConvWMBRequestSequencerCommon\n"));
+            //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, weight is compressed. after ConvWMBRequestSequencerCommon\n"));
         } else {    // //current layer is not weight compression
             if (wmb_req_cdma_prev_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED) { //prev layer is weight compression
                 if (cdma_weight_reuse_)
                     FAIL(("Can't reuse weight when previous layer is weight compression and current is not weight compression\n"));
                 else if ((wmb_req_cdma_prev_weight_bank_ != cdma_weight_bank_) || (wmb_req_cdma_prev_data_bank_ != cdma_data_bank_)) {
                     // Not reuse weight and wait until cbuf is empty and restart from the beginning of wmb banks
-                    cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change. BANK changed, rewind cbuf\n"));
+                    //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change. BANK changed, rewind cbuf\n"));
                     WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex();
                     wmb_entry_idx_free_   = CBUF_ENTRY_PER_BANK - 1;
                     wmb_entry_idx_working_ = 0;
@@ -813,12 +813,12 @@ void NV_NVDLA_cdma::WMBReadRequestSequenceThread () {
                     wmb_byte_idx_planed_  = 0;
                 } else {
                     wmb_entry_idx_working_ = wmb_entry_idx_planed_ + 1;
-                    cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change.\n"));
+                    //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change.\n"));
                 }
             } else {    //prev layer is not weight compression
                 if ((wmb_req_cdma_prev_weight_bank_ != cdma_weight_bank_) || (wmb_req_cdma_prev_data_bank_ != cdma_data_bank_)) {
                     // Not reuse weight and wait until cbuf is empty and restart from the beginning of wmb banks
-                    cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change. BANK changed, rewind cbuf\n"));
+                    //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change. BANK changed, rewind cbuf\n"));
                     WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex();
                     wmb_entry_idx_free_   = CBUF_ENTRY_PER_BANK - 1;
                     wmb_entry_idx_working_ = 0;
@@ -826,7 +826,7 @@ void NV_NVDLA_cdma::WMBReadRequestSequenceThread () {
                     wmb_byte_idx_planed_  = 0;
                 } else {
                     wmb_entry_idx_working_ = wmb_entry_idx_planed_ + 1;
-                    cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change.\n"));
+                    //cslInfo(("NV_NVDLA_cdma::WMBReadRequestSequenceThread, not reuse wmb due to config change.\n"));
                 }
             }
         }
@@ -845,7 +845,7 @@ void NV_NVDLA_cdma::WMBReadRequestSequenceThread () {
         } else
             wmb_req_prev_input_data_format_ = INPUT_DATA_FORMAT_WINO;
 
-        cslInfo(("NV_NVDLA_cdma::WmbReadRequestSequenceThread HW layer done\n"));
+        //cslInfo(("NV_NVDLA_cdma::WmbReadRequestSequenceThread HW layer done\n"));
     }
 }
 
@@ -869,21 +869,21 @@ void NV_NVDLA_cdma::WMBReadResponseSequenceThread () {
             wmb_resp_cdma_prev_skip_weight_rls_ = cdma_skip_weight_rls_;
             cdma_wmb_fetch_done_fifo_->write(true);
             cdma_wmb_fetch_done2wt_fifo_->write(true);
-            cslInfo(("Reuse weight. CDMA Weight Fetch Done. consumer pointer is %d\n", cdma_consumer_));
+            //cslInfo(("Reuse weight. CDMA Weight Fetch Done. consumer pointer is %d\n", cdma_consumer_));
             continue;
         }
         else {
-            cslInfo(("NV_NVDLA_cdma::WMBReadResponseSequenceThread. Not reuse weight. \n"));
+            //cslInfo(("NV_NVDLA_cdma::WMBReadResponseSequenceThread. Not reuse weight. \n"));
         }
 
         // Not reuse previous layer's wmb
 
         if(cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED) {
-            cslInfo(("NV_NVDLA_cdma::WMBReadResponseSequenceThread, weight is compressed\n"));
+            //cslInfo(("NV_NVDLA_cdma::WMBReadResponseSequenceThread, weight is compressed\n"));
             ConvWMBResponseSequencerCommon();
         }
         else {
-            cslInfo(("NV_NVDLA_cdma::WMBReadResponseSequenceThread, weight is not compressed\n"));
+            //cslInfo(("NV_NVDLA_cdma::WMBReadResponseSequenceThread, weight is not compressed\n"));
         }
 
         wmb_resp_cdma_prev_skip_weight_rls_ = cdma_skip_weight_rls_;
@@ -901,7 +901,7 @@ void NV_NVDLA_cdma::WMBReadResponseSequenceThread () {
 
         cdma_wmb_fetch_done_fifo_->write(true);
         cdma_wmb_fetch_done2wt_fifo_->write(true);
-        cslInfo(("CDMA WMB Fetch Done\n"));
+        //cslInfo(("CDMA WMB Fetch Done\n"));
     }
 }
 
@@ -914,7 +914,7 @@ void NV_NVDLA_cdma::WtReadRequestThread () {
     while (true) {
         //wait(cdma_kickoff_);
         source_id = wt_dma_rtl_source_id_fifo_->read();
-        cslDebug((50, "NV_NVDLA_cdma::WtReadRequestThread, get one req from RTL. source_id=%d\n", source_id));
+        //cslDebug((50, "NV_NVDLA_cdma::WtReadRequestThread, get one req from RTL. source_id=%d\n", source_id));
 
         if (source_id==CDMA_WEIGHT_DATA) {
             cdma_wt_req = cdma_wt_req_fifo_->read();
@@ -928,7 +928,7 @@ void NV_NVDLA_cdma::WtReadRequestThread () {
         memcpy(&payload, &(cdma_wt_req->pd), sizeof(nvdla_dma_rd_req_t));
         delete cdma_wt_req;
 
-        cslDebug((50, "NV_NVDLA_cdma::WtReadRequestThread, get one request. source_id=%d payload_addr=0x%16lx, size=0x%x\n", source_id, payload.pd.dma_read_cmd.addr, payload.pd.dma_read_cmd.size + 1));
+        //cslDebug((50, "NV_NVDLA_cdma::WtReadRequestThread, get one request. source_id=%d payload_addr=0x%16lx, size=0x%x\n", source_id, payload.pd.dma_read_cmd.addr, payload.pd.dma_read_cmd.size + 1));
 
         cdma_wt_info = new cdma_wt_info_t();
         cdma_wt_info->cdma_source = source_id;
@@ -941,32 +941,32 @@ void NV_NVDLA_cdma::WtReadRequestThread () {
             NV_NVDLA_cdma_base::cdma_wt2cvif_rd_req_b_transport(&payload, dma_delay_);
         }
 
-        cslDebug((50, "NV_NVDLA_cdma::WtReadRequestThread, request is sent.\n"));
+        //cslDebug((50, "NV_NVDLA_cdma::WtReadRequestThread, request is sent.\n"));
     }
 }
 
 void NV_NVDLA_cdma::Cdma2ScUpdateThread() {
     int32_t wt_kernels, wt_entries, wmb_entries;
     while (true) {
-        cslInfo(("wt_up_cdma2sc_b_transport start\n"));
-        cslInfo(("reading wt2sc_up_kernel_fifo_\n"));
+        //cslInfo(("wt_up_cdma2sc_b_transport start\n"));
+        //cslInfo(("reading wt2sc_up_kernel_fifo_\n"));
         wt_kernels  = wt2sc_up_kernel_fifo_->read();
-        cslInfo(("reading wt2sc_up_entry_fifo_\n"));
+        //cslInfo(("reading wt2sc_up_entry_fifo_\n"));
         wt_entries  = wt2sc_up_entry_fifo_->read();
 
         wt_up_cdma2sc_payload.wt_kernels    =  wt_kernels;
         wt_up_cdma2sc_payload.wt_entries    =  wt_entries;
         if (NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED == cdma_weight_format_) {
-            cslInfo(("reading wmb2sc_up_entry_fifo_\n"));
+            //cslInfo(("reading wmb2sc_up_entry_fifo_\n"));
             wmb_entries = wmb2sc_up_fifo_->read();
             wt_up_cdma2sc_payload.wmb_entries   =  wmb_entries;
         }
         else
             wt_up_cdma2sc_payload.wmb_entries   =  0;
 
-        cslInfo(("cdma: wt_kernels=0x%x wt_entries=0x%x wmb_entries=0x%x\n", wt_kernels, wt_entries, wmb_entries));;
+        //cslInfo(("cdma: wt_kernels=0x%x wt_entries=0x%x wmb_entries=0x%x\n", wt_kernels, wt_entries, wmb_entries));;
         wt_up_cdma2sc_b_transport(&wt_up_cdma2sc_payload, b_transport_delay_);
-        cslInfo(("wt_up_cdma2sc_b_transport done\n"));
+        //cslInfo(("wt_up_cdma2sc_b_transport done\n"));
     }
 }
 
@@ -1054,7 +1054,7 @@ void NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon() {
         FAIL(("NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon, invalid configuration cdma_line_packed_ and cdma_grains_, cdma_line_packed_ is %d,  cdma_grains_ is %d.", cdma_line_packed_, cdma_grains_));
 #pragma CTC ENDSKIP
 
-    cslInfo(("    super_normal_ratio is 0x%x fetch_slice_grain=0x%x\n", super_normal_ratio, fetch_slice_grain));
+    //cslInfo(("    super_normal_ratio is 0x%x fetch_slice_grain=0x%x\n", super_normal_ratio, fetch_slice_grain));
 
     // slice_idx_sequence_control_mutex_[cdma_consumer_].lock();
     slice_idx_available_ = 0;
@@ -1066,7 +1066,7 @@ void NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon() {
             payload_addr_1x1    = base_addr + batch_iter * batch_stride;
             data_entry_idx_planed_ += (atom_num_1x1 + 3) / 4;
             WaitUntilCBufferHasEnoughFreeDataEntry();
-            cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon(1x1), atom num calculation. atom_num_1x1 is 0x%x\n", atom_num_1x1));
+            //cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon(1x1), atom num calculation. atom_num_1x1 is 0x%x\n", atom_num_1x1));
             while (atom_sent_num_1x1 < atom_num_1x1) {
                 // Calculate payload size, payload transaction must be within a 256 byte
                 payload_size        = MAX_MEM_TRANSACTION_SIZE - payload_addr_1x1%MAX_MEM_TRANSACTION_SIZE;
@@ -1090,10 +1090,10 @@ void NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon() {
             FAIL(("NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon, invalid configuration fetch_slice_grain=0x%x cube_height=0x%x", fetch_slice_grain, cube_height));
         for (super_slice_iter = 0; super_slice_iter<super_slice_num; super_slice_iter ++) {
             current_slice_grain = ((super_slice_iter==(super_slice_num-1))? fetch_slice_grain_last: fetch_slice_grain);
-            cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon: super_slice_iter is 0x%x current_slice_grain=0x%x\n", super_slice_iter, current_slice_grain));
+            //cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon: super_slice_iter is 0x%x current_slice_grain=0x%x\n", super_slice_iter, current_slice_grain));
 
             for (batch_iter=0; batch_iter<batch_num; batch_iter++) {
-                cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon: batch_iter is 0x%x\n", batch_iter));
+                //cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon: batch_iter is 0x%x\n", batch_iter));
                 // Check free entry num is greater or equal to current slice_grain
                 data_entry_idx_planed_ += current_slice_grain*entry_per_slice;
                 WaitUntilCBufferHasEnoughFreeDataEntry();
@@ -1101,27 +1101,27 @@ void NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon() {
                     last_super_surface = super_surface_iter == (super_surface_num - 1);
                     last_super_surface_size = (cube_channel * element_size) % (CBUF_ENTRY_SIZE/2);
                     last_super_surface_size = (0==last_super_surface_size)? (CBUF_ENTRY_SIZE/2): last_super_surface_size;
-                    cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon: super_surface_iter is 0x%x\n", super_surface_iter));
+                    //cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon: super_surface_iter is 0x%x\n", super_surface_iter));
                     for (surface_iter=0; surface_iter<super_normal_ratio; surface_iter++) {
                         atom_num[surface_iter]      = cube_width * current_slice_grain;
                         if (last_super_surface && (last_super_surface_size <= surface_iter * ATOM_CUBE_SIZE))
                             atom_num[surface_iter]    = 0;
                         atom_sent_num[surface_iter] = 0;
                         payload_addr[surface_iter]    = base_addr + batch_iter * batch_stride + super_slice_iter * fetch_slice_grain * line_stride + (super_surface_iter*super_normal_ratio + surface_iter) * surface_stride;
-                        cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon, atom num calculation\n"));
-                        cslDebug((50, "    surface_iter is 0x%x\n", surface_iter));
-                        cslDebug((50, "    atom_num[surface_iter] is 0x%x\n", atom_num[surface_iter]));
-                        cslDebug((50, "    atom_sent_num[surface_iter] is 0x%x\n", atom_sent_num[surface_iter]));
-                        cslDebug((50, "    payload_addr[surface_iter] is 0x%lx\n", payload_addr[surface_iter]));
+                        //cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon, atom num calculation\n"));
+                        //cslDebug((50, "    surface_iter is 0x%x\n", surface_iter));
+                        //cslDebug((50, "    atom_num[surface_iter] is 0x%x\n", atom_num[surface_iter]));
+                        //cslDebug((50, "    atom_sent_num[surface_iter] is 0x%x\n", atom_sent_num[surface_iter]));
+                        //cslDebug((50, "    payload_addr[surface_iter] is 0x%lx\n", payload_addr[surface_iter]));
                     }
                     while ( (atom_sent_num[0] < atom_num[0]) || (atom_sent_num[1] < atom_num[1]) ) {
                         // Traverse each surface within current super
                         for (surface_iter=0; surface_iter<super_normal_ratio; surface_iter++) {
-                            cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon, transaction sending\n"));
-                            cslDebug((50, "    surface_iter is 0x%x\n", surface_iter));
-                            cslDebug((50, "    atom_num[surface_iter] is 0x%x\n", atom_num[surface_iter]));
-                            cslDebug((50, "    atom_sent_num[surface_iter] is 0x%x\n", atom_sent_num[surface_iter]));
-                            cslDebug((50, "    payload_addr[surface_iter] is 0x%lx\n", payload_addr[surface_iter]));
+                            //cslDebug((50, "NV_NVDLA_cdma::DirectConvDataRequestSequencerCommon, transaction sending\n"));
+                            //cslDebug((50, "    surface_iter is 0x%x\n", surface_iter));
+                            //cslDebug((50, "    atom_num[surface_iter] is 0x%x\n", atom_num[surface_iter]));
+                            //cslDebug((50, "    atom_sent_num[surface_iter] is 0x%x\n", atom_sent_num[surface_iter]));
+                            //cslDebug((50, "    payload_addr[surface_iter] is 0x%lx\n", payload_addr[surface_iter]));
                             if (atom_sent_num[surface_iter] < atom_num[surface_iter]) {
                                 // Calculate payload size, payload transaction must be within a 256 byte
                                 payload_size        = MAX_MEM_TRANSACTION_SIZE - payload_addr[surface_iter]%MAX_MEM_TRANSACTION_SIZE;
@@ -1284,7 +1284,7 @@ void NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon() {
             atom_num_1x1        = (cube_channel * element_size + ATOM_CUBE_SIZE - 1) /ATOM_CUBE_SIZE;
             read_atom_num_1x1   = 0;
             cdma2cbuf_data_payload_->hsel = 1;
-            cslDebug((50, "NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon(1x1), atom num calculation. atom_num_1x1 is 0x%x\n", atom_num_1x1));
+            //cslDebug((50, "NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon(1x1), atom num calculation. atom_num_1x1 is 0x%x\n", atom_num_1x1));
             while (read_atom_num_1x1 < atom_num_1x1) {
                 read_atom_iter_1x1 = 0;
                 while ( read_atom_iter_1x1 < super_normal_ratio ) {
@@ -1352,12 +1352,12 @@ void NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon() {
                 cbuf_payload_data_ptr = reinterpret_cast <uint8_t *> (cdma2cbuf_data_payload_->data);
                 cdma2cbuf_data_payload_->addr = cbuf_entry_addr;
                 memcpy (cbuf_payload_data_ptr, fetched_data_1x1_ptr, ATOM_CUBE_SIZE*2);
-                cslDebug((70, "cdma2buf_dat_wr_b_transport(1x1) addr=0x%x hsel=%d read_atom_num_1x1=%d\n", cbuf_entry_addr, (unsigned int)(cdma2cbuf_data_payload_->hsel), read_atom_num_1x1));
+                //cslDebug((70, "cdma2buf_dat_wr_b_transport(1x1) addr=0x%x hsel=%d read_atom_num_1x1=%d\n", cbuf_entry_addr, (unsigned int)(cdma2cbuf_data_payload_->hsel), read_atom_num_1x1));
 #if LOG_DETAIL
-                cslDebug((90, "data: "));
-                for(int i=0;i<64;i++)
-                    cslDebug((90, "0x%x ", cbuf_payload_data_ptr[i]));
-                cslDebug((90, "\n"));
+                //cslDebug((90, "data: "));
+                //for(int i=0;i<64;i++)
+                    //cslDebug((90, "0x%x ", cbuf_payload_data_ptr[i]));
+                //cslDebug((90, "\n"));
 #endif
                 cdma2buf_dat_wr_b_transport(cdma2cbuf_data_payload_, b_transport_delay_);
             }
@@ -1372,7 +1372,7 @@ void NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon() {
            // If line packed, fetch_slice_grain can be larger than 1.
         for (super_slice_iter = 0; super_slice_iter<super_slice_num; super_slice_iter ++) {
             current_slice_grain = ((super_slice_iter==(super_slice_num-1))? fetch_slice_grain_last: fetch_slice_grain);
-            cslDebug((50, "NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon, super_slice_iter=0x%x current_slice_grain=0x%x\n", super_slice_iter, current_slice_grain));
+            //cslDebug((50, "NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon, super_slice_iter=0x%x current_slice_grain=0x%x\n", super_slice_iter, current_slice_grain));
             for (batch_iter=0; batch_iter<batch_num; batch_iter++) {
                 for (super_surface_iter = 0; super_surface_iter<super_surface_num; super_surface_iter ++) {
                     last_super_surface = super_surface_iter == (super_surface_num - 1);
@@ -1401,12 +1401,12 @@ void NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon() {
                         // Traverse each surface within current super_surface
                         // read all the data of the super surf into super_surf_fetched_data_ptr
                         for (surface_iter=0; surface_iter<super_normal_ratio; surface_iter++) {
-                            cslDebug((50, "NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon, transaction receiving\n"));
-                            cslDebug((50, "    surface_iter is 0x%x\n", surface_iter));
-                            cslDebug((50, "    atom_num[surface_iter] is 0x%x\n", atom_num[surface_iter]));
-                            cslDebug((50, "    atom_sent_num[surface_iter] is 0x%x\n", atom_sent_num[surface_iter]));
-                            cslDebug((50, "    payload_addr[surface_iter] is 0x%lx\n", payload_addr[surface_iter]));
-                            cslDebug((50,"NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon Receiving data. super_slice_iter=%d batch_iter=%d super_surface_iter=%d surface_iter=%d\n", super_slice_iter, batch_iter, super_surface_iter, surface_iter));
+                            //cslDebug((50, "NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon, transaction receiving\n"));
+                            //cslDebug((50, "    surface_iter is 0x%x\n", surface_iter));
+                            //cslDebug((50, "    atom_num[surface_iter] is 0x%x\n", atom_num[surface_iter]));
+                            //cslDebug((50, "    atom_sent_num[surface_iter] is 0x%x\n", atom_sent_num[surface_iter]));
+                            //cslDebug((50, "    payload_addr[surface_iter] is 0x%lx\n", payload_addr[surface_iter]));
+                            //cslDebug((50,"NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon Receiving data. super_slice_iter=%d batch_iter=%d super_surface_iter=%d surface_iter=%d\n", super_slice_iter, batch_iter, super_surface_iter, surface_iter));
                             if (atom_sent_num[surface_iter] < atom_num[surface_iter]) {
                                 // Calculate payload size, payload transaction must be within a 256 byte
                                 payload_size        = MAX_MEM_TRANSACTION_SIZE - payload_addr[surface_iter]%MAX_MEM_TRANSACTION_SIZE;
@@ -1531,12 +1531,12 @@ void NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon() {
                                 atom_stored++;
                             }
                             cdma2cbuf_data_payload_->addr = cbuf_entry_addr;
-                            cslDebug((70, "cdma2buf_dat_wr_b_transport addr=0x%x hsel=%d atom_stored=%d\n", cbuf_entry_addr, (unsigned int)(cdma2cbuf_data_payload_->hsel), atom_stored));
+                            //cslDebug((70, "cdma2buf_dat_wr_b_transport addr=0x%x hsel=%d atom_stored=%d\n", cbuf_entry_addr, (unsigned int)(cdma2cbuf_data_payload_->hsel), atom_stored));
 #if LOG_DETAIL
-                            cslDebug((90, "data: "));
-                            for(int i=0;i<64;i++)
-                                cslDebug((90, "0x%x ", cbuf_payload_data_ptr[i]));
-                            cslDebug((90, "\n"));
+                            //cslDebug((90, "data: "));
+                            //for(int i=0;i<64;i++)
+                                //cslDebug((90, "0x%x ", cbuf_payload_data_ptr[i]));
+                            //cslDebug((90, "\n"));
 #endif
                             cdma2buf_dat_wr_b_transport(cdma2cbuf_data_payload_, b_transport_delay_);
                         }
@@ -1553,7 +1553,7 @@ void NV_NVDLA_cdma::DirectConvDataResponseSequencerCommon() {
                 data2sc_data_update_payload_->dat_entries = current_slice_grain * cbuf_entry_per_slice;
                 data2sc_data_update_payload_->dat_slices  = current_slice_grain;
                 dat_up_cdma2sc_b_transport(data2sc_data_update_payload_, b_transport_delay_);
-                cslDebug((50, "DirectConvDataResponseSequencerCommon. after dat_up_cdma2sc_b_transport. payload->dat_entries=0x%x, payload->dat_slices=0x%x\n", data2sc_data_update_payload_->dat_entries, data2sc_data_update_payload_->dat_slices));
+                //cslDebug((50, "DirectConvDataResponseSequencerCommon. after dat_up_cdma2sc_b_transport. payload->dat_entries=0x%x, payload->dat_slices=0x%x\n", data2sc_data_update_payload_->dat_entries, data2sc_data_update_payload_->dat_slices));
             }
         }
     }
@@ -1583,7 +1583,7 @@ void NV_NVDLA_cdma::ConvWGSRequestSequencerCommon() {
             wgs_total_bytes     = (weight_kernel + KERNEL_PER_GROUP_INT16 - 1) / KERNEL_PER_GROUP_INT16 * 4;
             break;
     }
-    cslInfo(("NV_NVDLA_cdma::ConvWGSRequestSequencerCommon, WGS total size is 0x%x\n", wgs_total_bytes));
+    //cslInfo(("NV_NVDLA_cdma::ConvWGSRequestSequencerCommon, WGS total size is 0x%x\n", wgs_total_bytes));
 
     wgs_total_bytes_fetched = 0;
     payload_addr            = base_addr;
@@ -1594,7 +1594,7 @@ void NV_NVDLA_cdma::ConvWGSRequestSequencerCommon() {
         dma_wgs_rd_req_payload_->pd.dma_read_cmd.addr = payload_addr;
         dma_wgs_rd_req_payload_->pd.dma_read_cmd.size = payload_atom_num-1;
         // Send read request to RDMA
-        cslDebug((50, "SendWGSDmaReadRequest payload_addr=0x%lx\n", payload_addr));
+        //cslDebug((50, "SendWGSDmaReadRequest payload_addr=0x%lx\n", payload_addr));
         if (cdma_wt_dma_arbiter_override_enable)
             SendWeightDmaReadRequestRTL(dma_wgs_rd_req_payload_, CDMA_WGS_DATA, dma_delay_);
         else
@@ -1603,7 +1603,7 @@ void NV_NVDLA_cdma::ConvWGSRequestSequencerCommon() {
         wgs_total_bytes_fetched += ATOM_CUBE_SIZE;
     }
     // Total weight byte index is 128 aligned
-    cslInfo(("NV_NVDLA_cdma::ConvWGSRequestSequencerCommon, end\n"));
+    //cslInfo(("NV_NVDLA_cdma::ConvWGSRequestSequencerCommon, end\n"));
 }
 
 void NV_NVDLA_cdma::ConvWGSResponseSequencerCommon() {
@@ -1626,18 +1626,18 @@ void NV_NVDLA_cdma::ConvWGSResponseSequencerCommon() {
             wgs_total_bytes     = (weight_kernel + KERNEL_PER_GROUP_INT16 - 1) / KERNEL_PER_GROUP_INT16 * 4;
             break;
     }
-    cslInfo(("NV_NVDLA_cdma::ConvWGSResponseSequencerCommon, WGS total size is 0x%x\n", wgs_total_bytes));
+    //cslInfo(("NV_NVDLA_cdma::ConvWGSResponseSequencerCommon, WGS total size is 0x%x\n", wgs_total_bytes));
 
     wgs_total_bytes_fetched = 0;
     while (wgs_total_bytes_fetched < wgs_total_bytes) {
         read_data_ptr = wgs_read_rsp_fifo_->read();
         memcpy(&wgs_buffer_[wgs_total_bytes_fetched/4], read_data_ptr, ATOM_CUBE_SIZE);
-        cslDebug((50, "Read 32B WGS data from wgs_read_rsp_fifo_\n"));
+        //cslDebug((50, "Read 32B WGS data from wgs_read_rsp_fifo_\n"));
         wgs_total_bytes_fetched += ATOM_CUBE_SIZE;
         delete [] read_data_ptr;
         wgs2wt_update_.notify();
     }
-    cslInfo(("NV_NVDLA_cdma::ConvWGSResponseSequencerCommon, end\n"));
+    //cslInfo(("NV_NVDLA_cdma::ConvWGSResponseSequencerCommon, end\n"));
 }
 
 void NV_NVDLA_cdma::ConvWMBRequestSequencerCommon() {
@@ -1672,7 +1672,7 @@ void NV_NVDLA_cdma::ConvWMBRequestSequencerCommon() {
             break;
     }
     kernel_group_wmb_size = kernel_per_group_ideal * (cdma_byte_per_kernel_+1) / element_size / 8;  // NOTE: in unit of byte. There should be no remainder
-    cslInfo(("NV_NVDLA_cdma::ConvWMBRequestSequencerCommon, WMB total size is 0x%x kernel_group_wmb_size=0x%x\n", wmb_total_bytes, kernel_group_wmb_size));
+    //cslInfo(("NV_NVDLA_cdma::ConvWMBRequestSequencerCommon, WMB total size is 0x%x kernel_group_wmb_size=0x%x\n", wmb_total_bytes, kernel_group_wmb_size));
 
     wmb_bytes_fetched = 0;
     payload_addr            = base_addr;
@@ -1689,12 +1689,12 @@ void NV_NVDLA_cdma::ConvWMBRequestSequencerCommon() {
         wmb_bytes_fetched  += payload_size;
         wmb_byte_idx_planed_     += payload_size;
         wmb_entry_idx_planed_    =  (wmb_byte_idx_planed_-1)/CBUF_ENTRY_SIZE;
-        cslDebug((50, "WaitUntilCBufferHasEnoughFreeWmbEntry start. wmb_bytes_fetched=0x%x wmb_byte_idx_planed_=0x%x\n", wmb_bytes_fetched, wmb_byte_idx_planed_));
+        //cslDebug((50, "WaitUntilCBufferHasEnoughFreeWmbEntry start. wmb_bytes_fetched=0x%x wmb_byte_idx_planed_=0x%x\n", wmb_bytes_fetched, wmb_byte_idx_planed_));
         WaitUntilCBufferHasEnoughFreeWmbEntry();
-        cslDebug((50, "WaitUntilCBufferHasEnoughFreeWmbEntry end\n"));
+        //cslDebug((50, "WaitUntilCBufferHasEnoughFreeWmbEntry end\n"));
 
         // Send read request to RDMA
-        cslDebug((50, "SendWMBDmaReadRequest payload_addr=0x%16lx, payload_atom_num=0x%x\n", payload_addr, payload_atom_num));;
+        //cslDebug((50, "SendWMBDmaReadRequest payload_addr=0x%16lx, payload_atom_num=0x%x\n", payload_addr, payload_atom_num));;
         if (cdma_wt_dma_arbiter_override_enable)
             SendWeightDmaReadRequestRTL(dma_wmb_rd_req_payload_, CDMA_WMB_DATA, dma_delay_);
         else
@@ -1717,7 +1717,7 @@ void NV_NVDLA_cdma::ConvWMBRequestSequencerCommon() {
 
     // Layer end. Align wmb_byte_idx_planed_ to 128Bytes.
     wmb_byte_idx_planed_ += ((wmb_byte_idx_planed_%CBUF_ENTRY_SIZE) == 0)? 0: (CBUF_ENTRY_SIZE - wmb_byte_idx_planed_%CBUF_ENTRY_SIZE);
-    cslInfo(("NV_NVDLA_cdma::ConvWMBRequestSequencerCommon, end\n"));
+    //cslInfo(("NV_NVDLA_cdma::ConvWMBRequestSequencerCommon, end\n"));
 }
 
 void NV_NVDLA_cdma::ConvWMBResponseSequencerCommon() {
@@ -1753,7 +1753,7 @@ void NV_NVDLA_cdma::ConvWMBResponseSequencerCommon() {
             kernel_per_group        = KERNEL_PER_GROUP_FP16;
             break;
     }
-    cslInfo(("NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, WMB total size is 0x%lx\n", wmb_total_bytes));
+    //cslInfo(("NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, WMB total size is 0x%lx\n", wmb_total_bytes));
     // Evaluated
     cdma2cbuf_payload_data_ptr      = reinterpret_cast <uint8_t *> (cdma2buf_wmb_wr_payload.data);
 
@@ -1767,12 +1767,12 @@ void NV_NVDLA_cdma::ConvWMBResponseSequencerCommon() {
         kernel_group_wmb_size = current_kernel_per_group * (cdma_byte_per_kernel_+1) * 1.0 / element_size / 8.0;
 
         read_data_ptr = wmb_read_rsp_fifo_->read();
-        cslDebug((50, "read from wmb_read_rsp_fifo_\n"));
+        //cslDebug((50, "read from wmb_read_rsp_fifo_\n"));
         memcpy (&cdma2cbuf_payload_data_ptr[wmb_bytes_fetched%(CBUF_HALF_ENTRY_SIZE)], read_data_ptr, ATOM_CUBE_SIZE);
         delete [] read_data_ptr;
         // Store to Convolution Buffer (CBUF), Half entry(64Bytes) in each transaction
         wmb_bytes_fetched  += ATOM_CUBE_SIZE;
-        cslDebug((50, "NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, wmb_bytes_fetched=0x%lx\n", wmb_bytes_fetched));
+        //cslDebug((50, "NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, wmb_bytes_fetched=0x%lx\n", wmb_bytes_fetched));
         if ( 0 == (wmb_bytes_fetched % CBUF_HALF_ENTRY_SIZE) ) {
             // Data is CBUF_ENTRY_SIZE/2 (64 byte) aligned, send half of entry data to CBUF
             cdma2buf_wmb_wr_payload.addr = ((wmb_bytes_fetched-1)/CBUF_ENTRY_SIZE + wmb_entry_idx_working_) % CBUF_ENTRY_PER_BANK + CBUF_WMB_BANK*CBUF_ENTRY_PER_BANK;
@@ -1783,12 +1783,12 @@ void NV_NVDLA_cdma::ConvWMBResponseSequencerCommon() {
                 wmb_entries_fetched_++;
             }
 
-            cslDebug((50, "NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, cdma2buf_wmb_wr_payload.addr is 0x%x\n", cdma2buf_wmb_wr_payload.addr));
-            cslDebug((50, "NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, cdma2buf_wmb_wr_payload.hsel is 0x%x\n", uint32_t(cdma2buf_wmb_wr_payload.hsel)));
-            cslDebug((70, "NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, cdma2buf_wmb_wr_payload.data are :\n"));
+            //cslDebug((50, "NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, cdma2buf_wmb_wr_payload.addr is 0x%x\n", cdma2buf_wmb_wr_payload.addr));
+            //cslDebug((50, "NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, cdma2buf_wmb_wr_payload.hsel is 0x%x\n", uint32_t(cdma2buf_wmb_wr_payload.hsel)));
+            //cslDebug((70, "NV_NVDLA_cdma::ConvWMBResponseSequencerCommon, cdma2buf_wmb_wr_payload.data are :\n"));
 #if LOG_DETAIL
             for (int32_t idx = 0; idx < sizeof(cdma2buf_wmb_wr_payload.data)/sizeof(cdma2buf_wmb_wr_payload.data[0]); idx++) {
-                cslDebug((90, " 0x%016lx\n", cdma2buf_wmb_wr_payload.data[idx]));
+                //cslDebug((90, " 0x%016lx\n", cdma2buf_wmb_wr_payload.data[idx]));
             }
 #endif
             cdma2buf_wt_wr_b_transport (&cdma2buf_wmb_wr_payload, b_transport_delay_);
@@ -1796,9 +1796,9 @@ void NV_NVDLA_cdma::ConvWMBResponseSequencerCommon() {
             if (0 == (wmb_bytes_fetched%CBUF_ENTRY_SIZE)) {
                 while ((weight_kernel_left>0) && (wmb_bytes_fetched - prev_wmb_bytes_fetched) >= kernel_group_wmb_size) { // WMB size of a kernel group may be less than 128B.
                     kg_fetched_wmb_entries = wmb_entries_fetched_ - prev_wmb_entries_fetched_;
-                    cslDebug((50, "Write to wmb2sc_up_fifo_. wmb_entries_fetched_=0x%x prev_wmb_bytes_fetched=%f kg_fetched_wmb_entries=0x%x\n", wmb_entries_fetched_, prev_wmb_bytes_fetched, kg_fetched_wmb_entries));
+                    //cslDebug((50, "Write to wmb2sc_up_fifo_. wmb_entries_fetched_=0x%x prev_wmb_bytes_fetched=%f kg_fetched_wmb_entries=0x%x\n", wmb_entries_fetched_, prev_wmb_bytes_fetched, kg_fetched_wmb_entries));
                     wmb2sc_up_fifo_->write(kg_fetched_wmb_entries);
-                    cslDebug((50, "Write to wmb2sc_up_fifo done\n"));
+                    //cslDebug((50, "Write to wmb2sc_up_fifo done\n"));
                     prev_wmb_bytes_fetched    += kernel_group_wmb_size;
                     prev_wmb_entries_fetched_ = wmb_entries_fetched_;
                     weight_kernel_left -= current_kernel_per_group;
@@ -1841,7 +1841,7 @@ void NV_NVDLA_cdma::DirectConvWeightRequestSequencerCommon(){
     byte_per_kernel     = cdma_byte_per_kernel_ + 1;
     weight_kernel       = cdma_weight_kernel_ + 1;
     proc_precision      = cdma_proc_precision_;
-    cslInfo(("NV_NVDLA_cdma::DirectConvWeightRequestSequencerCommon, weight_total_bytes is 0x%x\n", weight_total_bytes));
+    //cslInfo(("NV_NVDLA_cdma::DirectConvWeightRequestSequencerCommon, weight_total_bytes is 0x%x\n", weight_total_bytes));
 
     switch (proc_precision) {
         case DATA_FORMAT_INT8:
@@ -1889,12 +1889,12 @@ void NV_NVDLA_cdma::DirectConvWeightRequestSequencerCommon(){
         weight_bytes_fetched  += payload_size;
         weight_byte_idx_planed_     += payload_size;
         weight_entry_idx_planed_    =  (weight_byte_idx_planed_-1)/CBUF_ENTRY_SIZE;
-        cslDebug((50, "WaitUntilCBufferHasEnoughFreeWeightEntry start. weight_bytes_fetched=0x%x weight_byte_idx_planed_=0x%x\n", weight_bytes_fetched, weight_byte_idx_planed_));
+        //cslDebug((50, "WaitUntilCBufferHasEnoughFreeWeightEntry start. weight_bytes_fetched=0x%x weight_byte_idx_planed_=0x%x\n", weight_bytes_fetched, weight_byte_idx_planed_));
         WaitUntilCBufferHasEnoughFreeWeightEntry();
-        cslDebug((50, "WaitUntilCBufferHasEnoughFreeWeightEntry end\n"));
+        //cslDebug((50, "WaitUntilCBufferHasEnoughFreeWeightEntry end\n"));
 
         // Send read request to RDMA
-        cslDebug((50, "SendWeightDmaReadRequest payload_addr=0x%16lx payload_size=0x%x\n", payload_addr, payload_size));;
+        //cslDebug((50, "SendWeightDmaReadRequest payload_addr=0x%16lx payload_size=0x%x\n", payload_addr, payload_size));;
         if (cdma_wt_dma_arbiter_override_enable)
             SendWeightDmaReadRequestRTL(dma_wt_rd_req_payload_, CDMA_WEIGHT_DATA, dma_delay_);
         else
@@ -1921,7 +1921,7 @@ void NV_NVDLA_cdma::DirectConvWeightRequestSequencerCommon(){
 
     if ((weight_byte_idx_planed_ % CBUF_ENTRY_SIZE) != 0)
         FAIL(("weight_byte_idx_planed_ should be multiple of CBUF_ENTRY_SIZE at the end of layer\n"));
-    cslInfo(("NV_NVDLA_cdma::DirectConvWeightRequestSequencerCommon, end\n"));
+    //cslInfo(("NV_NVDLA_cdma::DirectConvWeightRequestSequencerCommon, end\n"));
 }
 
 void NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon() {
@@ -1984,13 +1984,13 @@ void NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon() {
 
     while (weight_bytes_fetched < weight_total_bytes) {
         read_data_ptr = weight_read_rsp_fifo_->read();
-        cslDebug((50, "read from weight_read_rsp_fifo_\n"));
+        //cslDebug((50, "read from weight_read_rsp_fifo_\n"));
         memcpy (&cdma2cbuf_payload_data_ptr[weight_bytes_fetched%CBUF_HALF_ENTRY_SIZE], read_data_ptr, ATOM_CUBE_SIZE);
         delete [] read_data_ptr;
 
         // Store a half entry(64B) to Convolution Buffer (CBUF)
         weight_bytes_fetched  += ATOM_CUBE_SIZE;
-        cslDebug((50, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon. weight_bytes_fetched=0x%lx\n", weight_bytes_fetched));
+        //cslDebug((50, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon. weight_bytes_fetched=0x%lx\n", weight_bytes_fetched));
         if ( 0 == (weight_bytes_fetched % CBUF_HALF_ENTRY_SIZE) ) {
             cdma2buf_wt_wr_payload.addr = ((weight_bytes_fetched-1)/CBUF_ENTRY_SIZE + weight_entry_idx_working_) % weight_entry_addr_aperture + weight_entry_addr_start;
             if ((weight_bytes_fetched % CBUF_ENTRY_SIZE) == 64)
@@ -2012,14 +2012,14 @@ void NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon() {
                 }
             }
 
-            cslDebug((50, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, cdma2buf_wt_wr_payload.addr is 0x%x\n", cdma2buf_wt_wr_payload.addr));
-            cslDebug((50, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, cdma2buf_wt_wr_payload.hsel is 0x%x\n", uint32_t(cdma2buf_wt_wr_payload.hsel)));
-            cslDebug((70, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, cdma2buf_wt_wr_payload.data are :\n"));
+            //cslDebug((50, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, cdma2buf_wt_wr_payload.addr is 0x%x\n", cdma2buf_wt_wr_payload.addr));
+            //cslDebug((50, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, cdma2buf_wt_wr_payload.hsel is 0x%x\n", uint32_t(cdma2buf_wt_wr_payload.hsel)));
+            //cslDebug((70, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, cdma2buf_wt_wr_payload.data are :\n"));
 #if LOG_DETAIL
             for (idx = 0; idx < sizeof(cdma2buf_wt_wr_payload.data)/sizeof(uint8_t); idx++) { // Should loop 128 times. Type of cdma2buf_wt_wr_payload.data is uint64_t.
-                cslDebug((90, "0x%02x ", cdma2cbuf_payload_data_ptr[idx]));
+                //cslDebug((90, "0x%02x ", cdma2cbuf_payload_data_ptr[idx]));
             }
-            cslDebug((90, "\n"));
+            //cslDebug((90, "\n"));
 #endif
             cdma2buf_wt_wr_b_transport (&cdma2buf_wt_wr_payload, b_transport_delay_);
 
@@ -2031,24 +2031,24 @@ void NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon() {
             if (0 == (weight_bytes_fetched % CBUF_ENTRY_SIZE)) {
                 while ((weight_kernel_left > 0) && (weight_bytes_fetched > weight_bytes_fetched_prev)) { // Update entry usage info for each kernel group
                     current_kernel_per_group = (weight_kernel_left < kernel_per_group)? weight_kernel_left: kernel_per_group;
-                    cslDebug((70, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon current_kernel_per_group =%d\n", current_kernel_per_group));
+                    //cslDebug((70, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon current_kernel_per_group =%d\n", current_kernel_per_group));
                     if (cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_UNCOMPRESSED)
                         wt_up_cdma2sc_en = ((weight_bytes_fetched - weight_bytes_fetched_prev) >= current_kernel_per_group * byte_per_kernel);
                     else
                         wt_up_cdma2sc_en = ((weight_bytes_fetched - weight_bytes_fetched_prev) >= wgs_buffer_[kernel_group_idx]);
 
                     if (wt_up_cdma2sc_en) {
-                        cslInfo(("NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, wt_up_cdma2sc_en is true\n"));
+                        //cslInfo(("NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, wt_up_cdma2sc_en is true\n"));
                         int32_t kg_wt_kernels    =  current_kernel_per_group;
                         int32_t kg_wt_entries    =  wt_entries_fetched - prev_wt_entries_fetched;
                         wt2sc_up_kernel_fifo_->write(kg_wt_kernels);
                         wt2sc_up_entry_fifo_->write(kg_wt_entries);
 
-                        if (cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED)
-                            cslDebug((70, "cdma: weight_bytes_fetched=0x%lx weight_bytes_fetched_prev=0x%lx wgs_buffer_[%d]=0x%x\n", weight_bytes_fetched, weight_bytes_fetched_prev, kernel_group_idx, wgs_buffer_[kernel_group_idx]));
-                        else
-                            cslDebug((70, "cdma: weight_bytes_fetched=0x%lx weight_bytes_fetched_prev=0x%lx\n", weight_bytes_fetched, weight_bytes_fetched_prev ));
-                        cslDebug((70, "cdma: kg_wt_kernels=0x%x kg_wt_entries=0x%x wt_entries_fetched=0x%x prev_wt_entries_fetched=0x%x\n", kg_wt_kernels, kg_wt_entries, wt_entries_fetched, prev_wt_entries_fetched));
+                        //if (cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED)
+                            //cslDebug((70, "cdma: weight_bytes_fetched=0x%lx weight_bytes_fetched_prev=0x%lx wgs_buffer_[%d]=0x%x\n", weight_bytes_fetched, weight_bytes_fetched_prev, kernel_group_idx, wgs_buffer_[kernel_group_idx]));
+                        //else
+                            //cslDebug((70, "cdma: weight_bytes_fetched=0x%lx weight_bytes_fetched_prev=0x%lx\n", weight_bytes_fetched, weight_bytes_fetched_prev ));
+                        //cslDebug((70, "cdma: kg_wt_kernels=0x%x kg_wt_entries=0x%x wt_entries_fetched=0x%x prev_wt_entries_fetched=0x%x\n", kg_wt_kernels, kg_wt_entries, wt_entries_fetched, prev_wt_entries_fetched));
 
                         weight_bytes_fetched_prev += (cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_UNCOMPRESSED)?
                                                      (current_kernel_per_group * byte_per_kernel): wgs_buffer_[kernel_group_idx];  // Align to the size of one kernel group
@@ -2063,7 +2063,7 @@ void NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon() {
             }
         }
     }
-    cslInfo(("End of DirectConvWeightResponseSequencerCommon: weight_bytes_fetched=0x%lx wt_entries_fetched=0x%x\n", weight_bytes_fetched, wt_entries_fetched));;
+    //cslInfo(("End of DirectConvWeightResponseSequencerCommon: weight_bytes_fetched=0x%lx wt_entries_fetched=0x%x\n", weight_bytes_fetched, wt_entries_fetched));;
 
     // All weight fetch is done, but some wgs may be not fetched yet
     while ( true ) {
@@ -2072,23 +2072,23 @@ void NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon() {
         if (!cdma_wt_dma_arbiter_override_enable || (cdma_weight_format_ == NVDLA_CDMA_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_UNCOMPRESSED))
             FAIL(("If weight uncompressed, all cdma2sc_wt should have been sent\n"));
 
-        cslDebug((70, "before wait wgs2wt_update_\n"));
+        //cslDebug((70, "before wait wgs2wt_update_\n"));
         wait(wgs2wt_update_);
-        cslDebug((70, "after wait wgs2wt_update_\n"));
+        //cslDebug((70, "after wait wgs2wt_update_\n"));
         while ((weight_kernel_left > 0) && (weight_bytes_fetched > weight_bytes_fetched_prev)) { // Update entry usage info for each kernel group
             current_kernel_per_group = (weight_kernel_left < kernel_per_group)? weight_kernel_left: kernel_per_group;
-            cslDebug((70, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon current_kernel_per_group =%d\n", current_kernel_per_group));
+            //cslDebug((70, "NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon current_kernel_per_group =%d\n", current_kernel_per_group));
             wt_up_cdma2sc_en = ((weight_bytes_fetched - weight_bytes_fetched_prev) >= wgs_buffer_[kernel_group_idx]);
 
             if (wt_up_cdma2sc_en) {
-                cslInfo(("NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, wt_up_cdma2sc_en is true\n"));
+                //cslInfo(("NV_NVDLA_cdma::DirectConvWeightResponseSequencerCommon, wt_up_cdma2sc_en is true\n"));
                 int32_t kg_wt_kernels    =  current_kernel_per_group;
                 int32_t kg_wt_entries    =  wt_entries_fetched - prev_wt_entries_fetched;
                 wt2sc_up_kernel_fifo_->write(kg_wt_kernels);
                 wt2sc_up_entry_fifo_->write(kg_wt_entries);
 
-                cslDebug((70, "cdma: weight_bytes_fetched=0x%lx weight_bytes_fetched_prev=0x%lx wgs_buffer_[%d]=0x%x\n", weight_bytes_fetched, weight_bytes_fetched_prev, kernel_group_idx, wgs_buffer_[kernel_group_idx]));
-                cslDebug((70, "cdma: kg_wt_kernels=0x%x kg_wt_entries=0x%x wt_entries_fetched=0x%x prev_wt_entries_fetched=0x%x\n", kg_wt_kernels, kg_wt_entries, wt_entries_fetched, prev_wt_entries_fetched));
+                //cslDebug((70, "cdma: weight_bytes_fetched=0x%lx weight_bytes_fetched_prev=0x%lx wgs_buffer_[%d]=0x%x\n", weight_bytes_fetched, weight_bytes_fetched_prev, kernel_group_idx, wgs_buffer_[kernel_group_idx]));
+                //cslDebug((70, "cdma: kg_wt_kernels=0x%x kg_wt_entries=0x%x wt_entries_fetched=0x%x prev_wt_entries_fetched=0x%x\n", kg_wt_kernels, kg_wt_entries, wt_entries_fetched, prev_wt_entries_fetched));
 
                 weight_bytes_fetched_prev += wgs_buffer_[kernel_group_idx];  // Align to the size of one kernel group
                 prev_wt_entries_fetched    = wt_entries_fetched;
@@ -2188,7 +2188,7 @@ void NV_NVDLA_cdma::ImageConvDataRequestSequencerCommon() {
         p1_line_st = 17 - p1_line_st_minus;         //for pitch linear, unit is burst 
         for (height_iter=0; height_iter<cube_height; height_iter++) {       // read data line by line
             planar0_bytes_fetched = planar1_bytes_fetched = 0;
-            cslDebug((50, "pitch linear, planar0_to_fetch_bytes=0x%x planar1_to_fetch_bytes=0x%x height_iter=0x%x\n", planar0_to_fetch_bytes, planar1_to_fetch_bytes, height_iter));
+            //cslDebug((50, "pitch linear, planar0_to_fetch_bytes=0x%x planar1_to_fetch_bytes=0x%x height_iter=0x%x\n", planar0_to_fetch_bytes, planar1_to_fetch_bytes, height_iter));
             while ((planar0_bytes_fetched < planar0_to_fetch_bytes) || ((2==planar_num) && (planar1_bytes_fetched < planar1_to_fetch_bytes))) {
                 // Send one read transaction for planar0
                 if (planar0_bytes_fetched < planar0_to_fetch_bytes) {
@@ -2197,7 +2197,7 @@ void NV_NVDLA_cdma::ImageConvDataRequestSequencerCommon() {
                     else
                         payload_size        = min((planar0_to_fetch_bytes - planar0_bytes_fetched), (uint32_t)(8*ATOM_CUBE_SIZE));
                     payload_atom_num    = (payload_size + ATOM_CUBE_SIZE -1)/ATOM_CUBE_SIZE;
-                    cslDebug((50, "Pitch Linear Request: planar0_bytes_fetched=0x%x payload_size=0x%x payload_atom_num=0x%x\n", planar0_bytes_fetched, payload_size, payload_atom_num));
+                    //cslDebug((50, "Pitch Linear Request: planar0_bytes_fetched=0x%x payload_size=0x%x payload_atom_num=0x%x\n", planar0_bytes_fetched, payload_size, payload_atom_num));
                     payload_size        = payload_atom_num * ATOM_CUBE_SIZE;
                     payload_addr        = planar0_base_addr + height_iter * line_stride + planar0_bytes_fetched;
                     dma_act_rd_req_payload_->pd.dma_read_cmd.addr = payload_addr;
@@ -2214,7 +2214,7 @@ void NV_NVDLA_cdma::ImageConvDataRequestSequencerCommon() {
                         payload_size        = min((planar1_to_fetch_bytes - planar1_bytes_fetched), (uint32_t)(16*ATOM_CUBE_SIZE));
                     payload_atom_num    = (payload_size + ATOM_CUBE_SIZE -1)/ATOM_CUBE_SIZE;
                     payload_size        = payload_atom_num * ATOM_CUBE_SIZE;
-                    cslDebug((50, "Pitch Linear Request: planar1_bytes_fetched=0x%x payload_size=0x%x payload_atom_num=0x%x\n", planar1_bytes_fetched, payload_size, payload_atom_num));
+                    //cslDebug((50, "Pitch Linear Request: planar1_bytes_fetched=0x%x payload_size=0x%x payload_atom_num=0x%x\n", planar1_bytes_fetched, payload_size, payload_atom_num));
                     payload_addr        = planar1_base_addr + height_iter * uv_line_stride + planar1_bytes_fetched;
                     dma_act_rd_req_payload_->pd.dma_read_cmd.addr = payload_addr;
                     dma_act_rd_req_payload_->pd.dma_read_cmd.size = payload_atom_num-1;
@@ -2336,7 +2336,7 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
         p1_line_st_minus = (p1_pad_left_tail > p1_x_offset_byte) ? p1_pad_left_main + 1 : p1_pad_left_main;
     }
 
-    cslInfo(("p0_pad_left_main=%d p0_pad_left_tail=%d p0_x_offset_byte=%d p0_line_st_minus=%d\n", p0_pad_left_main, p0_pad_left_tail, p0_x_offset_byte, p0_line_st_minus));
+    //cslInfo(("p0_pad_left_main=%d p0_pad_left_tail=%d p0_x_offset_byte=%d p0_line_st_minus=%d\n", p0_pad_left_main, p0_pad_left_tail, p0_x_offset_byte, p0_line_st_minus));
 
     // The cube after conversion and with left and right padding
     uint32_t pad_line_bytes = (pad_left + cube_width + pad_right) * converted_bytes_per_pixel;
@@ -2368,7 +2368,7 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
                 planar1_pixel_idx = ATOM_CUBE_SIZE / (2 * element_size);
             else
                 planar1_pixel_idx = 0;
-            cslDebug((50, "pitch linear, planar0_to_fetch_bytes=0x%x planar1_to_fetch_bytes=0x%x height_iter=0x%x planar1_pixel_idx=%d\n", planar0_to_fetch_bytes, planar1_to_fetch_bytes, height_iter, planar1_pixel_idx));
+            //cslDebug((50, "pitch linear, planar0_to_fetch_bytes=0x%x planar1_to_fetch_bytes=0x%x height_iter=0x%x planar1_pixel_idx=%d\n", planar0_to_fetch_bytes, planar1_to_fetch_bytes, height_iter, planar1_pixel_idx));
 
             // One read transaction for planar0
             while ((planar0_bytes_fetched < planar0_to_fetch_bytes) || ((2==planar_num) && (planar1_bytes_fetched < planar1_to_fetch_bytes))) {
@@ -2379,7 +2379,7 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
                     else
                         payload_size        = min((planar0_to_fetch_bytes - planar0_bytes_fetched), (uint32_t)(8*ATOM_CUBE_SIZE));
                     payload_atom_num    = (payload_size + ATOM_CUBE_SIZE -1)/ATOM_CUBE_SIZE;
-                    cslDebug((50, "Pitch Linear Request: planar0_bytes_fetched=0x%x payload_size=0x%x payload_atom_num=0x%x\n", planar0_bytes_fetched, payload_size, payload_atom_num));
+                    //cslDebug((50, "Pitch Linear Request: planar0_bytes_fetched=0x%x payload_size=0x%x payload_atom_num=0x%x\n", planar0_bytes_fetched, payload_size, payload_atom_num));
                     // Get atoms from read port
                     received_atoms = 0;
                     while (received_atoms < payload_atom_num) {
@@ -2407,7 +2407,7 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
                     payload_atom_num    = (payload_size + ATOM_CUBE_SIZE -1)/ATOM_CUBE_SIZE;
                     // Get atoms from read port
                     received_atoms = 0;
-                    cslDebug((50, "Pitch Linear Request: planar1_bytes_fetched=0x%x payload_size=0x%x payload_atom_num=0x%x\n", planar1_bytes_fetched, payload_size, payload_atom_num));
+                    //cslDebug((50, "Pitch Linear Request: planar1_bytes_fetched=0x%x payload_size=0x%x payload_atom_num=0x%x\n", planar1_bytes_fetched, payload_size, payload_atom_num));
                     while (received_atoms < payload_atom_num) {
                         read_data_ptr = act_data_read_rsp_fifo_->read();
                         for (i=0; i<ATOM_CUBE_SIZE;) {
@@ -2424,7 +2424,7 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
                 }
             }
         }
-        cslInfo(("ImageConvDataResponseSequencerCommon pitch_linear fetched to pitch_buffer\n"));
+        //cslInfo(("ImageConvDataResponseSequencerCommon pitch_linear fetched to pitch_buffer\n"));
 
         // Flush NaN to zero
         //if (flush_nan2zero&&(DATA_FORMAT_FP16 == precision)) {
@@ -2447,8 +2447,8 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
         }
     }   // end of pitch_linear
 
-    cslInfo(("pad_value_8=0x%x pad_value_16=0x%x\n", pad_value_8, pad_value_16));
-    cslInfo(("pad_left=0x%x pad_right=0x%x pixel_format=0x%x element_num=%d\n", pad_left, pad_right, pixel_format, element_num));
+    //cslInfo(("pad_value_8=0x%x pad_value_16=0x%x\n", pad_value_8, pad_value_16));
+    //cslInfo(("pad_left=0x%x pad_right=0x%x pixel_format=0x%x element_num=%d\n", pad_left, pad_right, pixel_format, element_num));
     // Perform conversion and append padding values
     for (height_iter=0; height_iter<cube_height; height_iter++) {     // read data line by line and assemble into pad_buffer
         uint32_t  i, element_idx;
@@ -2465,11 +2465,11 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
         }
         uint8_t  *pad_buffer_8  = (uint8_t*)pad_buffer[height_iter];
         uint16_t *pad_buffer_16 = (uint16_t*)pad_buffer[height_iter];
-        cslDebug((70, "height_iter=0x%x of fetch_buffer:\n", height_iter));
+        //cslDebug((70, "height_iter=0x%x of fetch_buffer:\n", height_iter));
 #if 0
-        for(i=0;i<512;i++)
-            cslDebug((70, " 0x%02x ", fetch_buffer_8[i]));
-        cslDebug((70, "\n"));
+        //for(i=0;i<512;i++)
+            //cslDebug((70, " 0x%02x ", fetch_buffer_8[i]));
+        //cslDebug((70, "\n"));
 #endif
         // Fill left padding values
         for (pixel_idx=0; pixel_idx<pad_left; pixel_idx++) {    // pad_left is in pixel, not byte
@@ -2803,17 +2803,17 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
             }
         }
     }
-    cslInfo(("ImageConvDataResponseSequencerCommon converted and saved to pad_buffer\n"));
+    //cslInfo(("ImageConvDataResponseSequencerCommon converted and saved to pad_buffer\n"));
 
     // Write all image data to cbuf (not include pad_top and pad_bottom)
     cbuf_entry_addr = data_entry_idx_working_ % ((cdma_data_bank_+1) * CBUF_ENTRY_PER_BANK);
     for (height_iter=0; height_iter<cube_height; height_iter++) {
-        cslDebug((70, "Writing image data to cbuf height_iter=%d\n", height_iter));
+        //cslDebug((70, "Writing image data to cbuf height_iter=%d\n", height_iter));
 #if 0
-        cslDebug((70, " pad_buffer[%d]:\n", height_iter));
-        for(i=0;i<512;i++)
-            cslDebug((70, " 0x%02x ", pad_buffer[height_iter][i]));
-        cslDebug((70, "\n"));
+        //cslDebug((70, " pad_buffer[%d]:\n", height_iter));
+        //for(i=0;i<512;i++)
+            //cslDebug((70, " 0x%02x ", pad_buffer[height_iter][i]));
+        //cslDebug((70, "\n"));
 #endif
 
         uint32_t write_line_bytes = 0;
@@ -2832,7 +2832,7 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
             write_line_bytes += curr_cbuf_entry_size;
         }
     }
-    cslInfo(("ImageConvDataResponseSequencerCommon All image data are written into CBUF\n"));
+    //cslInfo(("ImageConvDataResponseSequencerCommon All image data are written into CBUF\n"));
 
     for (i=0; i < cube_height; i++) {
         delete [] pad_buffer[i];
@@ -2850,7 +2850,7 @@ void NV_NVDLA_cdma::ImageConvDataResponseSequencerCommon() {
     data2sc_data_update_payload_->dat_entries = cbuf_entry_per_line * cube_height;
     data2sc_data_update_payload_->dat_slices  = cube_height;
     dat_up_cdma2sc_b_transport(data2sc_data_update_payload_, b_transport_delay_);
-    cslInfo(("ImageConvDataRequestSequencerCommon. dat_up_cdma2sc: dat_entries=0x%x dat_slices=0x%x\n", data2sc_data_update_payload_->dat_entries, data2sc_data_update_payload_->dat_slices));
+    //cslInfo(("ImageConvDataRequestSequencerCommon. dat_up_cdma2sc: dat_entries=0x%x dat_slices=0x%x\n", data2sc_data_update_payload_->dat_entries, data2sc_data_update_payload_->dat_slices));
 }
 
 void NV_NVDLA_cdma::WinoConvDataRequestSequencerCommon() {
@@ -2923,9 +2923,9 @@ void NV_NVDLA_cdma::WinoConvDataRequestSequencerCommon() {
     if (total_height%part_4_sy_height != 0) {
         FAIL(("NV_NVDLA_cdma::WinoConvDataRequestSequencerCommon, invalid config on padding and conv_y_stride."));
     }
-    cslDebug((70, "WxHxC=%dx%dx%d, SX*SY=%dx%d, pad: topxbottomxleftxright=%dx%dx%dx%d, precision:%d\n", cube_width, cube_height, cube_channel,
-                cdma_conv_x_stride_+1, conv_y_stride, pad_top, pad_bottom,
-                cdma_pad_left_, cdma_pad_right_, precision));
+    //cslDebug((70, "WxHxC=%dx%dx%d, SX*SY=%dx%d, pad: topxbottomxleftxright=%dx%dx%dx%d, precision:%d\n", cube_width, cube_height, cube_channel,
+    //            cdma_conv_x_stride_+1, conv_y_stride, pad_top, pad_bottom,
+    //            cdma_pad_left_, cdma_pad_right_, precision));
 #pragma CTC ENDSKIP
     // In H direction, loop stride is 4*conv_y_stride.
     for (super_height_iter=0; super_height_iter<super_height_num; super_height_iter++) {
@@ -2950,8 +2950,8 @@ void NV_NVDLA_cdma::WinoConvDataRequestSequencerCommon() {
                             // payload_addr doesn't have to be aligned to 256Bytes
                             payload_addr        = base_addr + surface_iter * surface_stride + height_iter * line_stride + width_iter*ATOM_CUBE_SIZE;
 #pragma CTC SKIP
-                            cslDebug((30, "base_addr:0x%lx, super_height_iter:%d, surface_iter:%d, stride_y_iter:%d, width_iter:%d, i:%d, height_iter:%d\n",
-                                        base_addr, super_height_iter, surface_iter, stride_y_iter, width_iter, i, height_iter));
+                            //cslDebug((30, "base_addr:0x%lx, super_height_iter:%d, surface_iter:%d, stride_y_iter:%d, width_iter:%d, i:%d, height_iter:%d\n",
+                            //            base_addr, super_height_iter, surface_iter, stride_y_iter, width_iter, i, height_iter));
 #pragma CTC ENDSKIP
                             payload_atom_num    = min(uint32_t(8), cube_width - width_iter);
                             // Prepare payload
@@ -3062,7 +3062,7 @@ void NV_NVDLA_cdma::WinoConvDataResponseSequencerCommon() {
     int width_ext           = cube_width + pad_left + pad_right;
     int    c_atomics_ext    = surface_num*conv_x_stride*conv_y_stride;
     cbuf_entry_per_slice    = (width_ext/(4*conv_x_stride))*c_atomics_ext*4;
-    cslInfo(("width_ext:%d, c_atoms_ext:%d, surf_num:%d, stride:%dx%d, eps:%d\n", width_ext, c_atomics_ext, surface_num, conv_x_stride, conv_y_stride, cbuf_entry_per_slice));
+    //cslInfo(("width_ext:%d, c_atoms_ext:%d, surf_num:%d, stride:%dx%d, eps:%d\n", width_ext, c_atomics_ext, surface_num, conv_x_stride, conv_y_stride, cbuf_entry_per_slice));
 
 #pragma CTC SKIP
     if (width_ext%(4*conv_x_stride) != 0) {
@@ -3119,11 +3119,11 @@ void NV_NVDLA_cdma::WinoConvDataResponseSequencerCommon() {
                             if (!((height_iter < pad_top) || (height_iter >= (pad_top+cube_height)))) {
                                 for(payload_atom_iter=0;payload_atom_iter<payload_atom_num;payload_atom_iter++) {
 #pragma CTC SKIP
-                                    cslDebug((50, "super_height_iter=0x%x surface_iter=0x%x stride_y_iter=0x%x width_iter=0x%x fetched_width=0x%x i=%d\n", 
-                                                super_height_iter, surface_iter, stride_y_iter, width_iter, fetched_width, i));
+                                    //cslDebug((50, "super_height_iter=0x%x surface_iter=0x%x stride_y_iter=0x%x width_iter=0x%x fetched_width=0x%x i=%d\n",
+                                    //            super_height_iter, surface_iter, stride_y_iter, width_iter, fetched_width, i));
 #pragma CTC ENDSKIP
                                     read_atom_ptr = act_data_read_rsp_fifo_->read();
-                                    cslDebug((50, "after read act_data_read_rsp_fifo_\n"));
+                                    //cslDebug((50, "after read act_data_read_rsp_fifo_\n"));
                                     wino_fetch_data_fifo_[i]->write(read_atom_ptr);
                                 }
                             }
@@ -3132,19 +3132,19 @@ void NV_NVDLA_cdma::WinoConvDataResponseSequencerCommon() {
                         // no need to fetch padding data
                         if (fetched_width >= cube_width+pad_left) {
 #pragma CTC SKIP
-                            cslDebug((70, "fetched_width:%d exceed valid data area, set to total_width:%d\n",
-                                        fetched_width, total_width));
+                            //cslDebug((70, "fetched_width:%d exceed valid data area, set to total_width:%d\n",
+                            //            fetched_width, total_width));
 #pragma CTC ENDSKIP
                             fetched_width = total_width;
                         }
                     }
 #pragma CTC SKIP
-                    cslDebug((70, "%s prepared width_iter*ATOM*4=%dx32x4 act data, wino_fetch_data_fifo->num_available()=%d, fetched_width:%d, act_data_read_rsp_fifo->free():%d\n",
-                                __FUNCTION__,
-                                width_iter,
-                                wino_fetch_data_fifo_[0]->num_available(),
-                                fetched_width,
-                                act_data_read_rsp_fifo_->num_free()));
+                    //cslDebug((70, "%s prepared width_iter*ATOM*4=%dx32x4 act data, wino_fetch_data_fifo->num_available()=%d, fetched_width:%d, act_data_read_rsp_fifo->free():%d\n",
+                    //            __FUNCTION__,
+                    //            width_iter,
+                    //            wino_fetch_data_fifo_[0]->num_available(),
+                    //            fetched_width,
+                    //            act_data_read_rsp_fifo_->num_free()));
 #pragma CTC ENDSKIP
 
                     // Compose a cube of W=Stride_x*4, H=4, C=32B
@@ -3164,7 +3164,7 @@ void NV_NVDLA_cdma::WinoConvDataResponseSequencerCommon() {
                             }
                         }
                     }
-                    cslDebug((70, "%s: add padding done for width_iter:%d\n", __FUNCTION__, width_iter));
+                    //cslDebug((70, "%s: add padding done for width_iter:%d\n", __FUNCTION__, width_iter));
                     // There are (Stride_x*4)*4 atoms in read_data_ptr now
                     // The 4*256B (W=8, H=4, C=32B) will be divided into 8*128B. Each 128B is a cbuf entry.
                     for (i=0; i<conv_x_stride; i++) {       // Number pf stride_x 4x4x4 sub-cubes in width direction
@@ -3175,7 +3175,7 @@ void NV_NVDLA_cdma::WinoConvDataResponseSequencerCommon() {
                                     memcpy(&cbuf_entry_buffer[cube444_height_iter*READ_WINO_BUF_WIDTH+cube444_width_iter*8], &read_data_ptr[cube444_height_iter][cube444_width_iter*conv_x_stride+i][j*8], 8);
                                 }
                             }
-                            cslDebug((70, "compose 4x4x4 small cube done for i:%d, j:%d\n", i, j));
+                            //cslDebug((70, "compose 4x4x4 small cube done for i:%d, j:%d\n", i, j));
 
                             // Now we have an entire line(128B) in cbuf_entry_buffer to write to cbuf entry
                             // Flush NaN to zero
@@ -3202,41 +3202,41 @@ void NV_NVDLA_cdma::WinoConvDataResponseSequencerCommon() {
                             cbuf_entry_addr    = (data_entry_idx_working_ + coor_height_4x4x4 * cbuf_entry_per_slice + coor_channel_4x4x4*(cube_width_ext/4) + coor_width_4x4x4) % data_entry_num;
                             cslAssert(cube_width_ext/4*num_4x4x4_channel == cbuf_entry_per_slice);
 
-                            cslDebug((50, "NV_NVDLA_cdma::WinoConvDataResponseSequencerCommon\n"));
-                            cslDebug((50, "    coor_height_4x4x4          is 0x%x\n", coor_height_4x4x4));
-                            cslDebug((50, "    coor_width_4x4x4           is 0x%x\n", coor_width_4x4x4));
-                            cslDebug((50, "    coor_channel_4x4x4         is 0x%x\n", coor_channel_4x4x4));
-                            cslDebug((50, "    num_4x4x4_channel          is 0x%x\n", num_4x4x4_channel));
-                            cslDebug((50, "    cbuf_entry_addr            is 0x%x\n", cbuf_entry_addr));
+                            //cslDebug((50, "NV_NVDLA_cdma::WinoConvDataResponseSequencerCommon\n"));
+                            //cslDebug((50, "    coor_height_4x4x4          is 0x%x\n", coor_height_4x4x4));
+                            //cslDebug((50, "    coor_width_4x4x4           is 0x%x\n", coor_width_4x4x4));
+                            //cslDebug((50, "    coor_channel_4x4x4         is 0x%x\n", coor_channel_4x4x4));
+                            //cslDebug((50, "    num_4x4x4_channel          is 0x%x\n", num_4x4x4_channel));
+                            //cslDebug((50, "    cbuf_entry_addr            is 0x%x\n", cbuf_entry_addr));
 
                             cbuf_payload_data_ptr = reinterpret_cast <uint8_t *> (cdma2cbuf_data_payload_->data);
                             cdma2cbuf_data_payload_->addr = cbuf_entry_addr;
                             // Left half of cbuf entry
                             cdma2cbuf_data_payload_->hsel = 0;
                             memcpy (cbuf_payload_data_ptr, cbuf_entry_buffer, ATOM_CUBE_SIZE*2);
-                            cslDebug((70, "cdma2buf_dat_wr_b_transport addr=0x%x hsel=%d\n", cbuf_entry_addr, (unsigned int)(cdma2cbuf_data_payload_->hsel)));
-                            cslDebug((70, "data: "));
-                            for(int i=0;i<64;i++)
-                                cslDebug((70, "0x%x ", cbuf_payload_data_ptr[i]));
-                            cslDebug((70, "\n"));
+                            //cslDebug((70, "cdma2buf_dat_wr_b_transport addr=0x%x hsel=%d\n", cbuf_entry_addr, (unsigned int)(cdma2cbuf_data_payload_->hsel)));
+                            //cslDebug((70, "data: "));
+                            //for(int i=0;i<64;i++)
+                                //cslDebug((70, "0x%x ", cbuf_payload_data_ptr[i]));
+                            //cslDebug((70, "\n"));
                             cdma2buf_dat_wr_b_transport(cdma2cbuf_data_payload_, b_transport_delay_);
-                            cslDebug((70, "cdma2buf_dat_wr_b_transport hsel=%d done\n", (unsigned int)(cdma2cbuf_data_payload_->hsel)));
+                            //cslDebug((70, "cdma2buf_dat_wr_b_transport hsel=%d done\n", (unsigned int)(cdma2cbuf_data_payload_->hsel)));
                             // Right half of cbuf entry
                             cdma2cbuf_data_payload_->hsel = 1;
                             memcpy (cbuf_payload_data_ptr, &cbuf_entry_buffer[ATOM_CUBE_SIZE*2], ATOM_CUBE_SIZE*2);
-                            cslDebug((70, "cdma2buf_dat_wr_b_transport addr=0x%x hsel=%d\n", cbuf_entry_addr, (unsigned int)(cdma2cbuf_data_payload_->hsel)));
-                            cslDebug((70, "data: "));
-                            for(int i=0;i<64;i++)
-                                cslDebug((70, "0x%x ", cbuf_payload_data_ptr[i]));
-                            cslDebug((70, "\n"));
+                            //cslDebug((70, "cdma2buf_dat_wr_b_transport addr=0x%x hsel=%d\n", cbuf_entry_addr, (unsigned int)(cdma2cbuf_data_payload_->hsel)));
+                            //cslDebug((70, "data: "));
+                            //for(int i=0;i<64;i++)
+                                //cslDebug((70, "0x%x ", cbuf_payload_data_ptr[i]));
+                            //cslDebug((70, "\n"));
                             cdma2buf_dat_wr_b_transport(cdma2cbuf_data_payload_, b_transport_delay_);
-                            cslDebug((70, "cdma2buf_dat_wr_b_transport hsel=%d done\n", (unsigned int)(cdma2cbuf_data_payload_->hsel)));
+                            //cslDebug((70, "cdma2buf_dat_wr_b_transport hsel=%d done\n", (unsigned int)(cdma2cbuf_data_payload_->hsel)));
                         }
                     }
                     width_iter += 4*conv_x_stride;
 #pragma CTC SKIP
-                    cslDebug((50, "width_iter:%d, payload_atom_num:%d, num_available:%d\n",
-                                width_iter, payload_atom_num, wino_fetch_data_fifo_[0]->num_available()));
+                    //cslDebug((50, "width_iter:%d, payload_atom_num:%d, num_available:%d\n",
+                    //            width_iter, payload_atom_num, wino_fetch_data_fifo_[0]->num_available()));
 #pragma CTC ENDSKIP
                 }
             }
@@ -3244,27 +3244,27 @@ void NV_NVDLA_cdma::WinoConvDataResponseSequencerCommon() {
         data2sc_data_update_payload_->dat_entries = cbuf_entry_per_slice;
         data2sc_data_update_payload_->dat_slices  = 1;
         dat_up_cdma2sc_b_transport(data2sc_data_update_payload_, b_transport_delay_);
-        cslDebug((50, "%s. after dat_up_cdma2sc_b_transport. payload->dat_entries=0x%x, payload->dat_slices=0x%x\n", __FUNCTION__, data2sc_data_update_payload_->dat_entries, data2sc_data_update_payload_->dat_slices));
+        //cslDebug((50, "%s. after dat_up_cdma2sc_b_transport. payload->dat_entries=0x%x, payload->dat_slices=0x%x\n", __FUNCTION__, data2sc_data_update_payload_->dat_entries, data2sc_data_update_payload_->dat_slices));
     }
 }
 
 // Send Activation data DMA read request
 void NV_NVDLA_cdma::SendActDmaReadRequest(nvdla_dma_rd_req_t* payload, uint8_t cdma_source, sc_time& delay) {
     // TODO: push payload_addr for debug purpose. it can be poped when receiving data from mcif/cvif
-    cslDebug((50, "NV_NVDLA_cdma::SendActDmaReadRequest, begin. payload_addr=0x%0lx atom_num=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size + 1));
+    //cslDebug((50, "NV_NVDLA_cdma::SendActDmaReadRequest, begin. payload_addr=0x%0lx atom_num=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size + 1));
     //cslDebug((50, "Writing cdma_req_source_fifo_ in unit of a dma request (may be not 64bytes)\n"));
     if (RAM_ID_MC == cdma_datain_ram_type_) {
         NV_NVDLA_cdma_base::cdma_dat2mcif_rd_req_b_transport(payload, dma_delay_);
     } else {
         NV_NVDLA_cdma_base::cdma_dat2cvif_rd_req_b_transport(payload, dma_delay_);
     }
-    cslDebug((50, "NV_NVDLA_cdma::SendActDmaReadRequest, end.\n"));
+    //cslDebug((50, "NV_NVDLA_cdma::SendActDmaReadRequest, end.\n"));
 }
 
 // Send weight DMA read request
 void NV_NVDLA_cdma::SendWeightDmaReadRequestRTL(nvdla_dma_rd_req_t* payload, uint8_t cdma_source, sc_time& delay) {
     cdma_wt_req_t *cdma_wt_req;
-    cslDebug((50, "NV_NVDLA_cdma::SendWeightDmaReadRequestRTL, begin. payload_addr=0x%016lx, cdma_source=%d\n", payload->pd.dma_read_cmd.addr, cdma_source));
+    //cslDebug((50, "NV_NVDLA_cdma::SendWeightDmaReadRequestRTL, begin. payload_addr=0x%016lx, cdma_source=%d\n", payload->pd.dma_read_cmd.addr, cdma_source));
 
     cdma_wt_req = new cdma_wt_req_t();
     memcpy(&(cdma_wt_req->pd), payload, sizeof(nvdla_dma_rd_req_t));
@@ -3277,13 +3277,13 @@ void NV_NVDLA_cdma::SendWeightDmaReadRequestRTL(nvdla_dma_rd_req_t* payload, uin
     else {
         cdma_wgs_req_fifo_->write(cdma_wt_req);
     }
-    cslDebug((50, "NV_NVDLA_cdma::SendWeightDmaReadRequestRTL, end.\n"));
+    //cslDebug((50, "NV_NVDLA_cdma::SendWeightDmaReadRequestRTL, end.\n"));
 }
 
 // Send weight DMA read request
 void NV_NVDLA_cdma::SendWeightDmaReadRequest(nvdla_dma_rd_req_t* payload, uint8_t cdma_source, sc_time& delay) {
     cdma_wt_info_t*     cdma_wt_info;
-    cslDebug((50, "NV_NVDLA_cdma::SendWeightDmaReadRequest, begin. cdma_source=%d payload_addr=0x%016lx\n", cdma_source, payload->pd.dma_read_cmd.addr));
+    //cslDebug((50, "NV_NVDLA_cdma::SendWeightDmaReadRequest, begin. cdma_source=%d payload_addr=0x%016lx\n", cdma_source, payload->pd.dma_read_cmd.addr));
 
     cdma_wt_info = new cdma_wt_info_t();
     cdma_wt_info->cdma_source = cdma_source;
@@ -3295,7 +3295,7 @@ void NV_NVDLA_cdma::SendWeightDmaReadRequest(nvdla_dma_rd_req_t* payload, uint8_
     } else {
         NV_NVDLA_cdma_base::cdma_wt2cvif_rd_req_b_transport(payload, dma_delay_);
     }
-    cslDebug((50, "NV_NVDLA_cdma::SendWeightDmaReadRequest, end.\n"));
+    //cslDebug((50, "NV_NVDLA_cdma::SendWeightDmaReadRequest, end.\n"));
 }
 
 void NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeDataEntry() {
@@ -3303,9 +3303,9 @@ void NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeDataEntry() {
         if(data_entry_idx_planed_ <= data_entry_idx_free_) {
             break;
         } else {
-            cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeDataEntry, go to sleep\n"));
-            cslDebug((50, "    data_entry_idx_planed_ is 0x%x", data_entry_idx_planed_));
-            cslDebug((50, "    data_entry_idx_free_ is 0x%x\n", data_entry_idx_free_));
+            //cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeDataEntry, go to sleep\n"));
+            //cslDebug((50, "    data_entry_idx_planed_ is 0x%x", data_entry_idx_planed_));
+            //cslDebug((50, "    data_entry_idx_free_ is 0x%x\n", data_entry_idx_free_));
             wait(sc_updated_cbuf_usage_data_);
         }
     }
@@ -3314,14 +3314,14 @@ void NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeDataEntry() {
 void NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWmbEntry() {
     while (true) {
         if ( wmb_entry_idx_planed_ <= wmb_entry_idx_free_) {
-            cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWmbEntry, break\n"));
-            cslDebug((50, "    wmb_entry_idx_planed_ is 0x%x\n", wmb_entry_idx_planed_));
-            cslDebug((50, "    wmb_entry_idx_free_ is 0x%x\n", wmb_entry_idx_free_));
+            //cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWmbEntry, break\n"));
+            //cslDebug((50, "    wmb_entry_idx_planed_ is 0x%x\n", wmb_entry_idx_planed_));
+            //cslDebug((50, "    wmb_entry_idx_free_ is 0x%x\n", wmb_entry_idx_free_));
             break;
         } else {
-            cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWmbEntry, go to sleep\n"));
-            cslDebug((50, "    wmb_entry_idx_planed_ is 0x%x\n", wmb_entry_idx_planed_));
-            cslDebug((50, "    wmb_entry_idx_free_ is 0x%x\n", wmb_entry_idx_free_));
+            //cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWmbEntry, go to sleep\n"));
+            //cslDebug((50, "    wmb_entry_idx_planed_ is 0x%x\n", wmb_entry_idx_planed_));
+            //cslDebug((50, "    wmb_entry_idx_free_ is 0x%x\n", wmb_entry_idx_free_));
             wait(sc_updated_cbuf_usage_wmb_);
         }
     }
@@ -3330,14 +3330,14 @@ void NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWmbEntry() {
 void NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWeightEntry() {
     while (true) {
         if ( weight_entry_idx_planed_ <= weight_entry_idx_free_) {
-            cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWeightEntry, break\n"));
-            cslDebug((50, "    weight_entry_idx_planed_ is 0x%x\n", weight_entry_idx_planed_));
-            cslDebug((50, "    weight_entry_idx_free_ is 0x%x\n", weight_entry_idx_free_));
+            //cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWeightEntry, break\n"));
+            //cslDebug((50, "    weight_entry_idx_planed_ is 0x%x\n", weight_entry_idx_planed_));
+            //cslDebug((50, "    weight_entry_idx_free_ is 0x%x\n", weight_entry_idx_free_));
             break;
         } else {
-            cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWeightEntry, go to sleep\n"));
-            cslDebug((50, "    weight_entry_idx_planed_ is 0x%x\n", weight_entry_idx_planed_));
-            cslDebug((50, "    weight_entry_idx_free_ is 0x%x\n", weight_entry_idx_free_));
+            //cslDebug((50, "NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWeightEntry, go to sleep\n"));
+            //cslDebug((50, "    weight_entry_idx_planed_ is 0x%x\n", weight_entry_idx_planed_));
+            //cslDebug((50, "    weight_entry_idx_free_ is 0x%x\n", weight_entry_idx_free_));
             wait(sc_updated_cbuf_usage_weight_);
         }
     }
@@ -3346,8 +3346,8 @@ void NV_NVDLA_cdma::WaitUntilCBufferHasEnoughFreeWeightEntry() {
 void NV_NVDLA_cdma::WaitUntilDataEntryPlanedIndexEqualEntryFreeIndex() {
     while (true) {
         if ((data_entry_idx_free_ - data_entry_idx_planed_) < ((cdma_req_prev_data_bank_ + 1) * CBUF_ENTRY_PER_BANK)) {
-            cslInfo(("NV_NVDLA_cdma::WaitUntilDataEntryPlanedIndexEqualEntryFreeIndex, wait until cbuf data is empty.\n"));
-            cslInfo(("data_entry_idx_free_=0x%x data_entry_idx_planed_=0x%x cdma_prev_data_bank_=%d\n", data_entry_idx_free_, data_entry_idx_planed_, cdma_req_prev_data_bank_));
+            //cslInfo(("NV_NVDLA_cdma::WaitUntilDataEntryPlanedIndexEqualEntryFreeIndex, wait until cbuf data is empty.\n"));
+            //cslInfo(("data_entry_idx_free_=0x%x data_entry_idx_planed_=0x%x cdma_prev_data_bank_=%d\n", data_entry_idx_free_, data_entry_idx_planed_, cdma_req_prev_data_bank_));
             wait (sc_updated_cbuf_usage_data_);
         } else {
             break;
@@ -3358,10 +3358,10 @@ void NV_NVDLA_cdma::WaitUntilDataEntryPlanedIndexEqualEntryFreeIndex() {
 void NV_NVDLA_cdma::WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex() {
     while (true) {
         if ((wmb_entry_idx_free_ - wmb_entry_idx_planed_) < CBUF_ENTRY_PER_BANK) {
-            cslDebug((50, "NV_NVDLA_cdma::WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex wait until cbuf wmb is empty. wmb_entry_idx_free_=0x%x wmb_entry_idx_planed_=0x%x\n", wmb_entry_idx_free_, wmb_entry_idx_planed_));
+            //cslDebug((50, "NV_NVDLA_cdma::WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex wait until cbuf wmb is empty. wmb_entry_idx_free_=0x%x wmb_entry_idx_planed_=0x%x\n", wmb_entry_idx_free_, wmb_entry_idx_planed_));
             wait (sc_updated_cbuf_usage_wmb_);
         } else {
-            cslDebug((50, "NV_NVDLA_cdma::WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex break. wmb_entry_idx_free_=0x%x wmb_entry_idx_planed_=0x%x\n", wmb_entry_idx_free_, wmb_entry_idx_planed_));
+            //cslDebug((50, "NV_NVDLA_cdma::WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex break. wmb_entry_idx_free_=0x%x wmb_entry_idx_planed_=0x%x\n", wmb_entry_idx_free_, wmb_entry_idx_planed_));
             break;
         }
     }
@@ -3370,10 +3370,10 @@ void NV_NVDLA_cdma::WaitUntilWmbEntryPlanedIndexEqualEntryFreeIndex() {
 void NV_NVDLA_cdma::WaitUntilWeightEntryPlanedIndexEqualEntryFreeIndex() {
     while (true) {
         if ((weight_entry_idx_free_ - weight_entry_idx_planed_) < ((wt_req_cdma_prev_weight_bank_ + 1) * CBUF_ENTRY_PER_BANK)) {
-            cslDebug((50, "NV_NVDLA_cdma::WaitUntilWeightEntryPlanedIndexEqualEntryFreeIndex wait until cbuf weight is empty. weight_entry_idx_free_=0x%x weight_entry_idx_planed_=0x%x wt_req_cdma_prev_weight_bank_=%d\n", weight_entry_idx_free_, weight_entry_idx_planed_, wt_req_cdma_prev_weight_bank_));
+            //cslDebug((50, "NV_NVDLA_cdma::WaitUntilWeightEntryPlanedIndexEqualEntryFreeIndex wait until cbuf weight is empty. weight_entry_idx_free_=0x%x weight_entry_idx_planed_=0x%x wt_req_cdma_prev_weight_bank_=%d\n", weight_entry_idx_free_, weight_entry_idx_planed_, wt_req_cdma_prev_weight_bank_));
             wait (sc_updated_cbuf_usage_weight_);
         } else {
-            cslDebug((50, "NV_NVDLA_cdma::WaitUntilWeightEntryPlanedIndexEqualEntryFreeIndex break. weight_entry_idx_free_=0x%x weight_entry_idx_planed_=0x%x wt_req_cdma_prev_weight_bank_=%d\n", weight_entry_idx_free_, weight_entry_idx_planed_, wt_req_cdma_prev_weight_bank_));
+            //cslDebug((50, "NV_NVDLA_cdma::WaitUntilWeightEntryPlanedIndexEqualEntryFreeIndex break. weight_entry_idx_free_=0x%x weight_entry_idx_planed_=0x%x wt_req_cdma_prev_weight_bank_=%d\n", weight_entry_idx_free_, weight_entry_idx_planed_, wt_req_cdma_prev_weight_bank_));
             break;
         }
     }
@@ -3388,7 +3388,7 @@ void NV_NVDLA_cdma::ActDmaResponseHandler(nvdla_dma_rd_rsp_t* payload){
     mask = payload->pd.dma_read_data.mask;
     payload_data_ptr    = reinterpret_cast <uint8_t *> (payload->pd.dma_read_data.data);
     //cdma_data_source    = cdma_req_source_fifo_->read();
-    cslDebug((50, "NV_NVDLA_cdma::ActDmaResponseHandler is called. mask=%d valid atom number=0x%x, fifo->free():%d\n", (uint32_t)mask, (mask&0x1) + ((mask&0x2)>>1), act_data_read_rsp_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_cdma::ActDmaResponseHandler is called. mask=%d valid atom number=0x%x, fifo->free():%d\n", (uint32_t)mask, (mask&0x1) + ((mask&0x2)>>1), act_data_read_rsp_fifo_->num_free()));
 
     // Handling lower 32 bytes
 #pragma CTC SKIP
@@ -3396,13 +3396,13 @@ void NV_NVDLA_cdma::ActDmaResponseHandler(nvdla_dma_rd_rsp_t* payload){
 #pragma CTC EDNSKIP
         atom_cube_ptr = new uint8_t[ATOM_CUBE_SIZE]; 
         memcpy(atom_cube_ptr, payload_data_ptr, ATOM_CUBE_SIZE);
-        cslDebug((50, "NV_NVDLA_cdma::ActDmaResponseHandler, mask 1. CDMA_FEATURE_DATA\n"));
+        //cslDebug((50, "NV_NVDLA_cdma::ActDmaResponseHandler, mask 1. CDMA_FEATURE_DATA\n"));
         act_data_read_rsp_fifo_->write(atom_cube_ptr);
 #if LOG_DETAIL
-        cslDebug((90, "lower 32 bytes:"));
-        for(int i=0;i<32;i++)
-            cslDebug((90, "0x%02x ", atom_cube_ptr[i]));
-        cslDebug((90, "\n"));
+        //cslDebug((90, "lower 32 bytes:"));
+        //for(int i=0;i<32;i++)
+            //cslDebug((90, "0x%02x ", atom_cube_ptr[i]));
+        //cslDebug((90, "\n"));
 #endif
     }
 
@@ -3410,13 +3410,13 @@ void NV_NVDLA_cdma::ActDmaResponseHandler(nvdla_dma_rd_rsp_t* payload){
     if (0 != (mask & 0x2)) {
         atom_cube_ptr = new uint8_t[ATOM_CUBE_SIZE]; 
         memcpy(atom_cube_ptr, payload_data_ptr + ATOM_CUBE_SIZE, ATOM_CUBE_SIZE);
-        cslDebug((50, "NV_NVDLA_cdma::ActDmaResponseHandler, mask 2. CDMA_FEATURE_DATA\n"));
+        //cslDebug((50, "NV_NVDLA_cdma::ActDmaResponseHandler, mask 2. CDMA_FEATURE_DATA\n"));
         act_data_read_rsp_fifo_->write(atom_cube_ptr);
 #if LOG_DETAIL
-        cslDebug((90, "upper 32 bytes:"));
-        for(int i=0;i<32;i++)
-            cslDebug((90, "0x%02x ", atom_cube_ptr[i]));
-        cslDebug((90, "\n"));
+       //cslDebug((90, "upper 32 bytes:"));
+        //for(int i=0;i<32;i++)
+            //cslDebug((90, "0x%02x ", atom_cube_ptr[i]));
+        //cslDebug((90, "\n"));
 #endif
     }
 }
@@ -3433,9 +3433,9 @@ void NV_NVDLA_cdma::WeightDmaResponseHandler(nvdla_dma_rd_rsp_t* payload){
     mask = payload->pd.dma_read_data.mask;
     payload_data_ptr    = reinterpret_cast <uint8_t *> (payload->pd.dma_read_data.data);
     if (0==wt_response_payload_size) {
-        cslDebug((50, "before reading cdma_wt_info_fifo_\n"));
+        //cslDebug((50, "before reading cdma_wt_info_fifo_\n"));
         cdma_wt_info             = cdma_wt_info_fifo_->read();
-        cslDebug((50, "after reading cdma_wt_info_fifo_\n"));
+        //cslDebug((50, "after reading cdma_wt_info_fifo_\n"));
         wt_response_cdma_source  = cdma_wt_info->cdma_source;
         wt_response_payload_size = cdma_wt_info->payload_size;
         delete cdma_wt_info;
@@ -3447,22 +3447,22 @@ void NV_NVDLA_cdma::WeightDmaResponseHandler(nvdla_dma_rd_rsp_t* payload){
 #pragma CTC ENDSKIP
         atom_cube_ptr = new uint8_t[ATOM_CUBE_SIZE]; 
         memcpy(atom_cube_ptr, payload_data_ptr, ATOM_CUBE_SIZE);
-        cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 1\n"));
+        //cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 1\n"));
 #if LOG_DETAIL
         for (int32_t idx = 0; idx < ATOM_CUBE_SIZE; idx ++) {
-            cslDebug((70, "   atom_cube_ptr[%d]: 0x%x\n", idx, uint16_t (atom_cube_ptr[idx])));
+            //cslDebug((70, "   atom_cube_ptr[%d]: 0x%x\n", idx, uint16_t (atom_cube_ptr[idx])));
         }
 #endif
         if (wt_response_cdma_source==CDMA_WEIGHT_DATA) {
-            cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 1. CDMA_WEIGHT_DATA\n"));
+            //cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 1. CDMA_WEIGHT_DATA\n"));
             weight_read_rsp_fifo_->write(atom_cube_ptr);
         }
         else if (wt_response_cdma_source==CDMA_WMB_DATA) {
-            cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 1. CDMA_WMB_DATA\n"));
+            //cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 1. CDMA_WMB_DATA\n"));
             wmb_read_rsp_fifo_->write(atom_cube_ptr);
         }
         else {
-            cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 1. CDMA_WGS_DATA\n"));
+            //cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 1. CDMA_WGS_DATA\n"));
             wgs_read_rsp_fifo_->write(atom_cube_ptr);
         }
         wt_response_payload_size--;
@@ -3472,25 +3472,25 @@ void NV_NVDLA_cdma::WeightDmaResponseHandler(nvdla_dma_rd_rsp_t* payload){
     if (0 != (mask & 0x2)) {
         atom_cube_ptr = new uint8_t[ATOM_CUBE_SIZE]; 
         memcpy(atom_cube_ptr, payload_data_ptr + ATOM_CUBE_SIZE, ATOM_CUBE_SIZE);
-        cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 2\n"));
+        //cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 2\n"));
 #if LOG_DETAIL
         for (int32_t idx = 0; idx < ATOM_CUBE_SIZE; idx ++) {
-            cslDebug((70, "   atom_cube_ptr[%d]: 0x%x\n", idx, uint16_t (atom_cube_ptr[idx])));
+            //cslDebug((70, "   atom_cube_ptr[%d]: 0x%x\n", idx, uint16_t (atom_cube_ptr[idx])));
         }
 #endif
         if (wt_response_cdma_source==CDMA_WEIGHT_DATA) {
-            cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 2. CDMA_WEIGHT_DATA\n"));
+            //cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 2. CDMA_WEIGHT_DATA\n"));
             weight_read_rsp_fifo_->write(atom_cube_ptr);
         }
 #pragma CTC SKIP
         else if (wt_response_cdma_source==CDMA_WMB_DATA) {
 #pragma CTC ENDSKIP
-            cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 2. CDMA_WMB_DATA\n"));
+            //cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 2. CDMA_WMB_DATA\n"));
             wmb_read_rsp_fifo_->write(atom_cube_ptr);
         }
 #pragma CTC SKIP
         else {  // We fetch WGS in unit of 32B, so that this else is not entered by WGS
-            cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 2. CDMA_WGS_DATA\n"));
+            //cslDebug((50, "NV_NVDLA_cdma::WeightDmaResponseHandler, mask 2. CDMA_WGS_DATA\n"));
             wgs_read_rsp_fifo_->write(atom_cube_ptr);
         }
 #pragma CTC ENDSKIP
@@ -3526,9 +3526,9 @@ void NV_NVDLA_cdma::cvif2cdma_wt_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t*
 
 void NV_NVDLA_cdma::dat_up_sc2cdma_b_transport(int ID, nvdla_dat_info_update_t* payload, sc_time& delay){
     data_entry_idx_free_            += payload->dat_entries;
-    cslDebug((50, "NV_NVDLA_cdma::dat_up_sc2cdma_b_transport\n"));
-    cslDebug((50, "    payload->dat_entries is 0x%x\n", uint32_t (payload->dat_entries)));
-    cslDebug((50, "    data_entry_idx_free_ is 0x%x\n", data_entry_idx_free_));
+    //cslDebug((50, "NV_NVDLA_cdma::dat_up_sc2cdma_b_transport\n"));
+    //cslDebug((50, "    payload->dat_entries is 0x%x\n", uint32_t (payload->dat_entries)));
+    //cslDebug((50, "    data_entry_idx_free_ is 0x%x\n", data_entry_idx_free_));
 
     sc_updated_cbuf_usage_data_.notify();
 }
@@ -3536,19 +3536,19 @@ void NV_NVDLA_cdma::dat_up_sc2cdma_b_transport(int ID, nvdla_dat_info_update_t*
 void NV_NVDLA_cdma::wt_up_sc2cdma_b_transport(int ID, nvdla_wt_info_update_t* payload, sc_time& delay){
     weight_entry_idx_free_  +=  payload->wt_entries;
     wmb_entry_idx_free_     +=  payload->wmb_entries;
-    cslDebug((50, "NV_NVDLA_cdma::wt_up_sc2cdma_b_transport\n"));
-    cslDebug((50, "    payload->wt_kernels is 0x%x\n", uint32_t (payload->wt_kernels)));
-    cslDebug((50, "    payload->wt_entries is 0x%x\n", uint32_t (payload->wt_entries)));
-    cslDebug((50, "    payload->wmb_entries is 0x%x\n", uint32_t (payload->wmb_entries)));
-    cslDebug((50, "    weight_entry_idx_free_ is 0x%x\n", weight_entry_idx_free_));
-    cslDebug((50, "    wmb_entry_idx_free_ is 0x%x\n", wmb_entry_idx_free_));
+    //cslDebug((50, "NV_NVDLA_cdma::wt_up_sc2cdma_b_transport\n"));
+    //cslDebug((50, "    payload->wt_kernels is 0x%x\n", uint32_t (payload->wt_kernels)));
+    //cslDebug((50, "    payload->wt_entries is 0x%x\n", uint32_t (payload->wt_entries)));
+    //cslDebug((50, "    payload->wmb_entries is 0x%x\n", uint32_t (payload->wmb_entries)));
+    //cslDebug((50, "    weight_entry_idx_free_ is 0x%x\n", weight_entry_idx_free_));
+    //cslDebug((50, "    wmb_entry_idx_free_ is 0x%x\n", wmb_entry_idx_free_));
 
     sc_updated_cbuf_usage_wmb_.notify();
     sc_updated_cbuf_usage_weight_.notify();
 }
 
 void NV_NVDLA_cdma::cdma_wt_dma_arbiter_source_id_b_transport(int ID, int source_id, sc_time& delay){
-    cslDebug((50, "NV_NVDLA_cdma::cdma_wt_dma_arbiter_source_id_b_transport. source_id=%d\n", source_id));
+    //cslDebug((50, "NV_NVDLA_cdma::cdma_wt_dma_arbiter_source_id_b_transport. source_id=%d\n", source_id));
     wt_dma_rtl_source_id_fifo_->write(source_id);
 }
 
@@ -3740,7 +3740,7 @@ uint8_t NV_NVDLA_cdma::cdma_bytes_per_pixel_planar1(uint16_t pixel_format) {
 
 uint8_t NV_NVDLA_cdma::cdma_element_num(uint16_t pixel_format) {
     uint8_t element_num = 0;
-    cslDebug((50, "NV_NVDLA_cdma::cdma_element_num pixel_format=0x%x\n", pixel_format));
+    //cslDebug((50, "NV_NVDLA_cdma::cdma_element_num pixel_format=0x%x\n", pixel_format));
     switch (pixel_format) {
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R8:
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R10:
@@ -3749,7 +3749,7 @@ uint8_t NV_NVDLA_cdma::cdma_element_num(uint16_t pixel_format) {
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R16_I:
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R16_F:
             element_num = 1;
-            cslDebug((50, "NV_NVDLA_cdma::cdma_element_num element_num=0x%x\n", element_num));
+            //cslDebug((50, "NV_NVDLA_cdma::cdma_element_num element_num=0x%x\n", element_num));
             break;
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_A16B16G16R16:
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_X16B16G16R16:
@@ -3774,7 +3774,7 @@ uint8_t NV_NVDLA_cdma::cdma_element_num(uint16_t pixel_format) {
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_V10U10Y10A2:
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_R8G8B8X8:
             element_num = 4;
-            cslDebug((50, "NV_NVDLA_cdma::cdma_element_num: element_num=0x%x\n", element_num));
+            //cslDebug((50, "NV_NVDLA_cdma::cdma_element_num: element_num=0x%x\n", element_num));
             break;
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y8___U8V8_N444:
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y8___V8U8_N444:
@@ -3785,12 +3785,12 @@ uint8_t NV_NVDLA_cdma::cdma_element_num(uint16_t pixel_format) {
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y16___U16V16_N444:
         case NVDLA_CDMA_D_DATAIN_FORMAT_0_PIXEL_FORMAT_T_Y16___V16U16_N444:
             element_num = 3;
-            cslDebug((50, "NV_NVDLA_cdma::cdma_element_num: element_num=0x%x\n", element_num));
+            //cslDebug((50, "NV_NVDLA_cdma::cdma_element_num: element_num=0x%x\n", element_num));
             break;
         default:
             FAIL(("Unexpected pixel format %d", pixel_format));
     }
-    cslDebug((50, "NV_NVDLA_cdma::cdma_element_num: element_num=0x%x\n", element_num));
+    //cslDebug((50, "NV_NVDLA_cdma::cdma_element_num: element_num=0x%x\n", element_num));
     return element_num;
 }
 
@@ -3853,12 +3853,12 @@ void NV_NVDLA_cdma::WriteOneEntryToCbuf(uint8_t* read_data_ptr, uint32_t cbuf_en
     cdma2cbuf_data_payload_->hsel = 0;
     cdma2cbuf_data_payload_->addr = cbuf_entry_addr;
     memcpy(cbuf_payload_data_ptr, read_data_ptr, CBUF_ENTRY_SIZE/2);
-    cslDebug((50, "WriteToCbuf addr=0x%x hsel=%d\n", cdma2cbuf_data_payload_->addr, (unsigned int)(cdma2cbuf_data_payload_->hsel)));
+    //cslDebug((50, "WriteToCbuf addr=0x%x hsel=%d\n", cdma2cbuf_data_payload_->addr, (unsigned int)(cdma2cbuf_data_payload_->hsel)));
 #if LOG_DETAIL
-    cslDebug((90, " data:\n"));
-    for(int i=0;i<64;i++)
-        cslDebug((90, " 0x%x ", cbuf_payload_data_ptr[i]));
-    cslDebug((90, "\n"));
+    //cslDebug((90, " data:\n"));
+    //for(int i=0;i<64;i++)
+        //cslDebug((90, " 0x%x ", cbuf_payload_data_ptr[i]));
+    //cslDebug((90, "\n"));
 #endif
     cdma2buf_dat_wr_b_transport(cdma2cbuf_data_payload_, b_transport_delay_);
 
@@ -3866,12 +3866,12 @@ void NV_NVDLA_cdma::WriteOneEntryToCbuf(uint8_t* read_data_ptr, uint32_t cbuf_en
     cdma2cbuf_data_payload_->hsel = 1;
     cdma2cbuf_data_payload_->addr = cbuf_entry_addr;
     memcpy(cbuf_payload_data_ptr, &read_data_ptr[CBUF_ENTRY_SIZE/2], CBUF_ENTRY_SIZE/2);
-    cslDebug((50, "WriteToCbuf addr=0x%x hsel=%d\n", cdma2cbuf_data_payload_->addr, (unsigned int)(cdma2cbuf_data_payload_->hsel)));
+    //cslDebug((50, "WriteToCbuf addr=0x%x hsel=%d\n", cdma2cbuf_data_payload_->addr, (unsigned int)(cdma2cbuf_data_payload_->hsel)));
 #if LOG_DETAIL
-    cslDebug((90, " data:\n"));
-    for(int i=0;i<64;i++)
-        cslDebug((90, " 0x%x ", cbuf_payload_data_ptr[i]));
-    cslDebug((90, "\n"));
+    //cslDebug((90, " data:\n"));
+    //for(int i=0;i<64;i++)
+        //cslDebug((90, " 0x%x ", cbuf_payload_data_ptr[i]));
+    //cslDebug((90, "\n"));
 #endif
     cdma2buf_dat_wr_b_transport(cdma2cbuf_data_payload_, b_transport_delay_);
 }
@@ -3924,7 +3924,7 @@ void NV_NVDLA_cdma::hls_convertor(int16_t* in_ptr, uint8_t input_data_type, int1
             tmp0 = *in_ptr;
         }
         else {
-            cslInfo(("Invalid data type\n"));
+            //cslInfo(("Invalid data type\n"));
         }
 #pragma CTC ENDSKIP
 
@@ -3941,7 +3941,7 @@ void NV_NVDLA_cdma::hls_convertor(int16_t* in_ptr, uint8_t input_data_type, int1
             tmp4 = (tmp4 > 0x7fff)? 0x7fff: (tmp4 < -0x8000)? -0x8000: tmp4;
     }
 
-    cslDebug((70, "NV_NVDLA_cdma::hls_convertor input data=0x%x offset=0x%x scale=0x%x truncate=0x%x in_precision=%d out_precision=%d output_data=0x%x\n", *in_ptr, offset, scale, truncate, in_precision, out_precision, *out_ptr));
+    //cslDebug((70, "NV_NVDLA_cdma::hls_convertor input data=0x%x offset=0x%x scale=0x%x truncate=0x%x in_precision=%d out_precision=%d output_data=0x%x\n", *in_ptr, offset, scale, truncate, in_precision, out_precision, *out_ptr));
     if ((!fp16) && (DATA_FORMAT_FP16 != out_precision) && ((*out_ptr) != int32_t(tmp4)))
         FAIL(("Checker faild: hls ouput = 0x%x checker outout = 0x%lx\n", *out_ptr, (uint64_t)tmp4));
 }
@@ -3955,7 +3955,7 @@ void NV_NVDLA_cdma::process_one_element_8(int8_t pixel_8, uint32_t pixel_idx, ui
     input_data_type = cdma_pixel_sign_override_? PIXEL_SIGNED_INT8: PIXEL_UNSIGNED_INT8;
     convert_input = pixel_8 & 0xff;
 #if LOG_DETAIL
-    cslDebug((90, "convert_8to16=%d cvt_en=%d cvt_mean=0x%x cvt_scale=0x%x cvt_truncate=0x%x pixel_idx=0x%x pixel_8=0x%x convert_input=0x%x\n", convert_8to16, cvt_en, cvt_mean, cvt_scale, cvt_truncate, pixel_idx, pixel_8, convert_input));
+    //cslDebug((90, "convert_8to16=%d cvt_en=%d cvt_mean=0x%x cvt_scale=0x%x cvt_truncate=0x%x pixel_idx=0x%x pixel_8=0x%x convert_input=0x%x\n", convert_8to16, cvt_en, cvt_mean, cvt_scale, cvt_truncate, pixel_idx, pixel_8, convert_input));
 #endif
 
     if(cvt_en)
@@ -3970,7 +3970,7 @@ void NV_NVDLA_cdma::process_one_element_8(int8_t pixel_8, uint32_t pixel_idx, ui
         //cslDebug((70, "pad_buffer_8[pixel_idx*element_num+i]=0x%x\n", pad_buffer_8[pixel_idx*element_num+i]));
     }
 #if LOG_DETAIL
-    cslDebug((90, "convert_result=0x%x\n", convert_result));
+    //cslDebug((90, "convert_result=0x%x\n", convert_result));
 #endif
 }
 
@@ -3983,7 +3983,7 @@ void NV_NVDLA_cdma::process_one_element_16(int16_t pixel_16, uint32_t pixel_idx,
     input_data_type_tmp = (input_data_type==PIXEL_FP16)? PIXEL_FP16: cdma_pixel_sign_override_? PIXEL_SIGNED_INT16: PIXEL_UNSIGNED_INT16;
     convert_input = pixel_16;
 #if LOG_DETAIL
-    cslDebug((90, "cvt_en=%d cvt_mean=0x%x pixel_idx=0x%x pixel_16=0x%x\n", cvt_en, cvt_mean, pixel_idx, pixel_16));
+    //cslDebug((90, "cvt_en=%d cvt_mean=0x%x pixel_idx=0x%x pixel_16=0x%x\n", cvt_en, cvt_mean, pixel_idx, pixel_16));
 #endif
 
     if(cvt_en)
@@ -3997,7 +3997,7 @@ void NV_NVDLA_cdma::process_one_element_16(int16_t pixel_16, uint32_t pixel_idx,
         pad_buffer_16[pixel_idx*element_num+i] = *(uint16_t*)&convert_result; // get the lower two bytes
     }
 #if LOG_DETAIL
-    cslDebug((90, "convert_result=0x%x\n", convert_result));
+    //cslDebug((90, "convert_result=0x%x\n", convert_result));
 #endif
 }
 
diff --git a/cmod/cdma/gen/cdma_reg_model.cpp b/cmod/cdma/gen/cdma_reg_model.cpp
index 8f650ad..a7e77b5 100644
--- a/cmod/cdma/gen/cdma_reg_model.cpp
+++ b/cmod/cdma/gen/cdma_reg_model.cpp
@@ -85,7 +85,7 @@ bool cdma_reg_model::CdmaAccessRegister(uint32_t reg_addr, uint32_t & data, bool
                 cdma_register_group_0->SetWritable(offset, data);
                 if (cdma_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_cdma_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cdma_reg_model::CdmaAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "cdma_reg_model::CdmaAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -97,7 +97,7 @@ bool cdma_reg_model::CdmaAccessRegister(uint32_t reg_addr, uint32_t & data, bool
                 cdma_register_group_1->SetWritable(offset, data);
                 if (cdma_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_cdma_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cdma_reg_model::CdmaAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "cdma_reg_model::CdmaAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/cdp/NV_NVDLA_cdp.cpp b/cmod/cdp/NV_NVDLA_cdp.cpp
index 104ebba..9373680 100644
--- a/cmod/cdp/NV_NVDLA_cdp.cpp
+++ b/cmod/cdp/NV_NVDLA_cdp.cpp
@@ -192,7 +192,7 @@ void NV_NVDLA_cdp::CdpRdmaHardwareLayerExecutionTrigger () {
 
 void NV_NVDLA_cdp::CdpHardwareLayerExecutionTrigger () {
     cdp_kickoff_.notify();
-    cslInfo(("NV_NVDLA_cdp::CdpHardwareLayerExecutionTrigger, cdp has just been kicked off.\n"));
+    //cslInfo(("NV_NVDLA_cdp::CdpHardwareLayerExecutionTrigger, cdp has just been kicked off.\n"));
     wait(cdp_done_);
 }
 
@@ -201,7 +201,7 @@ void NV_NVDLA_cdp::CdpRdmaReadSequenceThread () {
     CdpConfig *cdp_config, *cdp_config_wdma;
     while (true) {
         wait(cdp_rdma_kickoff_);
-        cslInfo(("NV_NVDLA_cdp::CdpRdmaReadSequenceThread, get CDP RDMA hardware layer kickoff event.\n"));
+        //cslInfo(("NV_NVDLA_cdp::CdpRdmaReadSequenceThread, get CDP RDMA hardware layer kickoff event.\n"));
         cdp_config = new CdpConfig;
         cdp_config_wdma = new CdpConfig;
         cdp_config->cdp_rdma_width_ = cdp_rdma_width_;
@@ -254,7 +254,7 @@ void NV_NVDLA_cdp::CdpRdmaSequence_0() {
     uint32_t    payload_size;
     uint32_t    payload_atom_num;
 
-    cslInfo(("NV_NVDLA_cdp::CdpRdmaSequence0, start.\n"));
+    //cslInfo(("NV_NVDLA_cdp::CdpRdmaSequence0, start.\n"));
     // Copy from register value to local config variables, similar with RTL connection, begin
     // # Cube setting
     cube_width      = cdp_rdma_width_+1;
@@ -280,9 +280,9 @@ void NV_NVDLA_cdp::CdpRdmaSequence_0() {
 #pragma CTC ENDSKIP
     }
     // Copy from register value to local config variables, similar with RTL connection, end
-    cslInfo(("%s WxHxC=%dx%dx%d, format:%d\n", __FUNCTION__,
-                cube_width, cube_height, cube_channel,cdp_rdma_input_data_));
-    cslInfo(("\t addr:0x%lx, line_stride:%lx, surf_stride:%lx\n", src_base_addr, line_stride, surf_stride));
+    //cslInfo(("%s WxHxC=%dx%dx%d, format:%d\n", __FUNCTION__,
+    //            cube_width, cube_height, cube_channel,cdp_rdma_input_data_));
+    //cslInfo(("\t addr:0x%lx, line_stride:%lx, surf_stride:%lx\n", src_base_addr, line_stride, surf_stride));
 
     surf_num = (cube_channel + element_per_group_src - 1) / element_per_group_src;
 
@@ -316,27 +316,27 @@ void NV_NVDLA_cdp::CdpRdmaSequence_0() {
 
             // Send DMA request for all surfaces
             for (surf_iter = 0; surf_iter < surf_num; surf_iter++) {
-                cslDebug((50, "CdpRdmaSequence_0 line_iter=%d, surf_iter=%d, atom_sent=%d\n", line_iter, surf_iter, atom_sent));
+                //cslDebug((50, "CdpRdmaSequence_0 line_iter=%d, surf_iter=%d, atom_sent=%d\n", line_iter, surf_iter, atom_sent));
                 rdma_atom_num_fifo_->write(payload_atom_num);
                 payload_addr     = surf0_payload_addr + surf_iter * surf_stride + atom_sent * ATOM_CUBE_SIZE; // surface_stride is multiple of 256
-                cslDebug((50, "CdpRdmaSequence_0 SendDmaReadRequest payload_addr=0x%lx payload_atom_num=%d\n", payload_addr, payload_atom_num));
+                //cslDebug((50, "CdpRdmaSequence_0 SendDmaReadRequest payload_addr=0x%lx payload_atom_num=%d\n", payload_addr, payload_atom_num));
                 dma_rd_req_payload_->pd.dma_read_cmd.addr = payload_addr;
                 dma_rd_req_payload_->pd.dma_read_cmd.size = payload_atom_num - 1;
                 //WaitUntilRdmaFifoFreeSizeGreaterThan(payload_atom_num);
-                cslDebug((50, "WaitUntilRdmaFifoFreeSizeGreaterThan done\n"));
+                //cslDebug((50, "WaitUntilRdmaFifoFreeSizeGreaterThan done\n"));
                 SendDmaReadRequest(dma_rd_req_payload_, dma_delay_, cdp_rdma_src_ram_type_);
             }
 
             atom_sent               += payload_atom_num;
         }
     }
-    cslInfo(("%s: finished fetch input cube, totally: %d atoms are fetched\n", __FUNCTION__, atom_sent*cube_height));
+    //cslInfo(("%s: finished fetch input cube, totally: %d atoms are fetched\n", __FUNCTION__, atom_sent*cube_height));
 }
 
 void NV_NVDLA_cdp::CdpDataPathOperationSequenceThread () {
     while (true) {
         wait(cdp_kickoff_);
-        cslInfo(("NV_NVDLA_cdp::CdpDataPathOperationSequenceThread, catch cdp_kickoff_ event.\n"));
+        //cslInfo(("NV_NVDLA_cdp::CdpDataPathOperationSequenceThread, catch cdp_kickoff_ event.\n"));
 
         CdpDataPathReadphileSequence();
     }
@@ -354,15 +354,15 @@ void NV_NVDLA_cdp::reset_stats_regs() {
     nan_output_num = 0;
 }
 void NV_NVDLA_cdp::update_stats_regs() {
-    cslInfo(("NV_NVDLA_cdp, nan_input_num:%d\n", nan_input_num));
-    cslInfo(("NV_NVDLA_cdp, inf_input_num:%d\n", inf_input_num));
-    cslInfo(("NV_NVDLA_cdp, nan_output_num:%d\n", nan_output_num));
+    //cslInfo(("NV_NVDLA_cdp, nan_input_num:%d\n", nan_input_num));
+    //cslInfo(("NV_NVDLA_cdp, inf_input_num:%d\n", inf_input_num));
+    //cslInfo(("NV_NVDLA_cdp, nan_output_num:%d\n", nan_output_num));
 
-    cslInfo(("NV_NVDLA_cdp, lut_u_flow:%d\n", lut_u_flow));
-    cslInfo(("NV_NVDLA_cdp, lut_o_flow:%d\n", lut_o_flow));
-    cslInfo(("NV_NVDLA_cdp, lut_le_hit:%d\n", lut_le_hit));
-    cslInfo(("NV_NVDLA_cdp, lut_lo_hit:%d\n", lut_lo_hit));
-    cslInfo(("NV_NVDLA_cdp, lut_hybrid_hit:%d\n", lut_hybrid_hit));
+    //cslInfo(("NV_NVDLA_cdp, lut_u_flow:%d\n", lut_u_flow));
+    //cslInfo(("NV_NVDLA_cdp, lut_o_flow:%d\n", lut_o_flow));
+    //cslInfo(("NV_NVDLA_cdp, lut_le_hit:%d\n", lut_le_hit));
+    //cslInfo(("NV_NVDLA_cdp, lut_lo_hit:%d\n", lut_lo_hit));
+    //cslInfo(("NV_NVDLA_cdp, lut_hybrid_hit:%d\n", lut_hybrid_hit));
 
     cdp_reg_model::CdpUpdateStatusRegister((uint32_t)NVDLA_CDP_D_NAN_INPUT_NUM_0,  cdp_consumer_, (uint32_t)nan_input_num);
     cdp_reg_model::CdpUpdateStatusRegister((uint32_t)NVDLA_CDP_D_INF_INPUT_NUM_0,  cdp_consumer_, (uint32_t)inf_input_num);
@@ -493,9 +493,9 @@ void NV_NVDLA_cdp::CdpDataPathSequence() {
     hls_lookup_num_ = 0;
     round_num = surf_num*ATOM_CUBE_SIZE/8;
 
-    cslInfo(("%s WxHxC=%dx%dx%d, format:%d\n", __FUNCTION__,
-                cube_width, cube_height, cube_channel,cdp_input_data_type_));
-    cslInfo(("\t surf_num:%d, round_num:%d\n", surf_num, round_num));
+    //cslInfo(("%s WxHxC=%dx%dx%d, format:%d\n", __FUNCTION__,
+    //            cube_width, cube_height, cube_channel,cdp_input_data_type_));
+    //cslInfo(("\t surf_num:%d, round_num:%d\n", surf_num, round_num));
     for (line_iter=0; line_iter < cube_height; line_iter++) {
         processed_atom_num = 0;
         atom_num_per_line = cube_width * surf_num;
@@ -506,7 +506,7 @@ void NV_NVDLA_cdp::CdpDataPathSequence() {
             // Copy the first 256B data (may be less than 256B) to cur_calc_buffer
             atom_num = rdma_atom_num_fifo_->read();
             processed_atom_num  += atom_num;
-            cslDebug((50, "CDP line_iter=%d processed_atom_num=%d\n", line_iter, processed_atom_num));
+            //cslDebug((50, "CDP line_iter=%d processed_atom_num=%d\n", line_iter, processed_atom_num));
 
             hls_atom_num_fifo_->write(atom_num);
             for (atom_iter = 0; atom_iter < atom_num; atom_iter++) {
@@ -554,7 +554,7 @@ void NV_NVDLA_cdp::CdpDataPathSequence() {
                             // Copy from rdma_fifo_ to nxt buffer
                             nxt_atom_num = rdma_atom_num_fifo_->read();
                             processed_atom_num  += nxt_atom_num;
-                            cslDebug((50, "CDP line_iter=%d processed_atom_num=%d\n", line_iter, processed_atom_num));
+                            //cslDebug((50, "CDP line_iter=%d processed_atom_num=%d\n", line_iter, processed_atom_num));
 #pragma CTC SKIP
                             if(nxt_atom_num!=atom_num) {
                                 FAIL((("atom_num should be same in same stripe. atom_num=%d, nxt_atom_num=%d"), atom_num, nxt_atom_num));
@@ -582,7 +582,7 @@ void NV_NVDLA_cdp::CdpDataPathSequence() {
                             // Copy from rdma_fifo_ to nxt buffer
                             nxt_atom_num = rdma_atom_num_fifo_->read();
                             processed_atom_num  += nxt_atom_num;
-                            cslDebug((50, "CDP line_iter=%d processed_atom_num=%d\n", line_iter, processed_atom_num));
+                            //cslDebug((50, "CDP line_iter=%d processed_atom_num=%d\n", line_iter, processed_atom_num));
 #pragma CTC SKIP
                             if(nxt_atom_num!=atom_num) {
                                 FAIL((("atom_num should be same in same stripe. atom_num=%d, nxt_atom_num=%d"), atom_num, nxt_atom_num));
@@ -661,18 +661,18 @@ void NV_NVDLA_cdp::CdpDataPathSequence() {
                         cdp_channel_last = false;
 
                     hls_lookup_num_++;
-                    cslDebug((70, "cdp_width_cnt=%d cdp_channel_cnt=%d cdp_channel_last=%d round_iter=%d data_to_hls:\n",
-                                cdp_width_cnt, cdp_channel_cnt, cdp_channel_last, round_iter));
+                    //cslDebug((70, "cdp_width_cnt=%d cdp_channel_cnt=%d cdp_channel_last=%d round_iter=%d data_to_hls:\n",
+                                //cdp_width_cnt, cdp_channel_cnt, cdp_channel_last, round_iter));
                     if(is_int8)
                     {
                         for(int i=0;i<16;i++) {
-                            cslDebug((70, " %02x", data_to_hls_i8[i] & 0xff));
+                            //cslDebug((70, " %02x", data_to_hls_i8[i] & 0xff));
                         }
                     }
                     else
                     {
                         for(int i=0;i<12;i++) {
-                            cslDebug((70, " %04x", data_to_hls[i] & 0xffff));
+                            //cslDebug((70, " %04x", data_to_hls[i] & 0xffff));
 
                             if(cdp_input_data_type_ == DATA_FORMAT_FP16)
                             {
@@ -682,22 +682,22 @@ void NV_NVDLA_cdp::CdpDataPathSequence() {
                             }
                         }
                     }
-                    cslDebug((70, "\n"));
+                    //cslDebug((70, "\n"));
 
                     if (is_int8) {
                         normalz_out_int8 = new int8_t[8];
                         lookup_lut_int8(data_to_hls_i8, 8);
                         hls_out_fifo_->write((int16_t*)normalz_out_int8);    //8B
-                        cslDebug((50, "normalz_out:"));
+                        //cslDebug((50, "normalz_out:"));
                         for(int i=0;i<8;i++) {
-                            cslDebug((50, " %04x", normalz_out_int8[i]));
+                            //cslDebug((50, " %04x", normalz_out_int8[i]));
                         }
-                        cslDebug((50, "\n"));
+                        //cslDebug((50, "\n"));
                     } else {
                         normalz_out = new int16_t[4];
                         lookup_lut(data_to_hls, 4);
                         hls_out_fifo_->write(normalz_out);    //8B
-                        cslDebug((50, "normalz_out:"));
+                        //cslDebug((50, "normalz_out:"));
                         for(int i=0;i<4;i++) {
                             if(cdp_input_data_type_ == DATA_FORMAT_IS_FP16)
                             {
@@ -708,16 +708,16 @@ void NV_NVDLA_cdp::CdpDataPathSequence() {
                                     nan_output_num++;
                                 }
                             }
-                            cslDebug((50, " %04x", normalz_out[i]));
+                            //cslDebug((50, " %04x", normalz_out[i]));
                         }
-                        cslDebug((50, "\n"));
+                        //cslDebug((50, "\n"));
                     }
                     hls_out_num_++;
 
-                    cslDebug((50, "hls_lookup_num_=%d\n", hls_lookup_num_));
-                    cslDebug((50, "hls_out_num_=%d\n", hls_out_num_));
+                    //cslDebug((50, "hls_lookup_num_=%d\n", hls_lookup_num_));
+                    //cslDebug((50, "hls_out_num_=%d\n", hls_out_num_));
                     
-                    cslDebug((50, "\n"));
+                    //cslDebug((50, "\n"));
                 } // atom_iter
             } // round_iter
 
@@ -735,7 +735,7 @@ void NV_NVDLA_cdp::CdpDataPathSequence() {
         } // stripe iter
     } // line_iter
 
-    cslInfo(("%s finished process of current layer\n", __FUNCTION__));
+    //cslInfo(("%s finished process of current layer\n", __FUNCTION__));
 }
 
 void NV_NVDLA_cdp::CdpWdmaWriteSequenceThread () {
@@ -789,7 +789,7 @@ void NV_NVDLA_cdp::CdpWdmaSequence() {
     uint8_t     *payload_data_ptr;
     CdpConfig   *cfg;
 
-    cslInfo(("NV_NVDLA_cdp::CdpWdmaSequence, start.\n"));
+    //cslInfo(("NV_NVDLA_cdp::CdpWdmaSequence, start.\n"));
     // Copy from register value to local config variables, similar with RTL connection, begin
     // # Cube setting
     cfg = cdp_fifo_cfg_wdma_->read();
@@ -823,7 +823,7 @@ void NV_NVDLA_cdp::CdpWdmaSequence() {
 
     surf_num         = (cube_channel+element_per_group_dst-1)/element_per_group_dst;
     total_atom_num = cube_width * cube_height * surf_num;
-    cslDebug((30, "%s: WxHxC=%dx%dx%d, total_atoms=%d\n", __FUNCTION__, cube_width, cube_height, cube_channel, total_atom_num));
+    //cslDebug((30, "%s: WxHxC=%dx%dx%d, total_atoms=%d\n", __FUNCTION__, cube_width, cube_height, cube_channel, total_atom_num));
 
     surf_iter = 0;
     line_iter = 0;
@@ -836,7 +836,7 @@ void NV_NVDLA_cdp::CdpWdmaSequence() {
         payload_addr = dst_base_addr + surf_iter * surface_stride + line_iter * line_stride + width_iter*ATOM_CUBE_SIZE;
 
         // Prepare payload
-        cslDebug((30, "NV_NVDLA_cdp::SendDmaWriteRequest, begin. total_atom_num=%d sent_atom_num=%d atom_num=%d payload_addr=0x%lx\n", total_atom_num, sent_atom_num, atom_num, payload_addr));
+        //cslDebug((30, "NV_NVDLA_cdp::SendDmaWriteRequest, begin. total_atom_num=%d sent_atom_num=%d atom_num=%d payload_addr=0x%lx\n", total_atom_num, sent_atom_num, atom_num, payload_addr));
         dma_wr_req_cmd_payload_->pd.dma_write_cmd.addr = payload_addr;
         dma_wr_req_cmd_payload_->pd.dma_write_cmd.size = atom_num-1;
         payload_data_ptr = reinterpret_cast <uint8_t  *>  (dma_wr_req_data_payload_->pd.dma_write_data.data);
@@ -844,14 +844,14 @@ void NV_NVDLA_cdp::CdpWdmaSequence() {
         if ((sent_atom_num + atom_num) == total_atom_num)  // The last write request of the Cube
         {
             is_required_ack = true;
-            cslDebug((30, "CDP is_required_ack=true\n"));
+            //cslDebug((30, "CDP is_required_ack=true\n"));
         }
 
         // Send write command
         txn_w++;
-        cslDebug((50, "CdpWdmaSequence SendDmaWriteRquest cmd payload_addr=0x%lx payload_atom_num=%d txn=%d required_ack=%d\n", payload_addr, atom_num, txn_w, is_required_ack));
+        //cslDebug((50, "CdpWdmaSequence SendDmaWriteRquest cmd payload_addr=0x%lx payload_atom_num=%d txn=%d required_ack=%d\n", payload_addr, atom_num, txn_w, is_required_ack));
         SendDmaWriteRequest(dma_wr_req_cmd_payload_, dma_delay_, cdp_dst_ram_type_, is_required_ack);
-        cslDebug((50, "CdpWdmaSequence SendDmaWriteRquest cmd done\n"));
+        //cslDebug((50, "CdpWdmaSequence SendDmaWriteRquest cmd done\n"));
         
         for (round_iter = 0; round_iter < round_num; round_iter++) {
             hls_element = hls_out_fifo_->read();    //8B
@@ -869,9 +869,9 @@ void NV_NVDLA_cdp::CdpWdmaSequence() {
             memcpy(&payload_data_ptr[(atom_iter%2)*ATOM_CUBE_SIZE], &post_calc_buffer[atom_iter*ATOM_CUBE_SIZE], ATOM_CUBE_SIZE);
             if (((atom_iter%2)==1) || atom_iter==(atom_num-1)) {
                 // Send write data
-                cslDebug((50, "CdpWdmaSequence SendDmaWriteRquest data txn=%d atom_iter=%d\n", txn_w, atom_iter));
+                //cslDebug((50, "CdpWdmaSequence SendDmaWriteRquest data txn=%d atom_iter=%d\n", txn_w, atom_iter));
                 SendDmaWriteRequest(dma_wr_req_data_payload_, dma_delay_, cdp_dst_ram_type_);
-                cslDebug((50, "CdpWdmaSequence SendDmaWriteRquest data done\n"));
+                //cslDebug((50, "CdpWdmaSequence SendDmaWriteRquest data done\n"));
             }
         }
 
@@ -891,7 +891,7 @@ void NV_NVDLA_cdp::CdpWdmaSequence() {
 
         sent_atom_num += atom_num;
     }
-    cslInfo(("%s finished current layer\n", __FUNCTION__));
+    //cslInfo(("%s finished current layer\n", __FUNCTION__));
 }
 
 #pragma CTC SKIP
@@ -922,13 +922,13 @@ void NV_NVDLA_cdp::WaitUntilWdmaBufferAvailableSizeGreaterThan(uint32_t num) {
 
 // Send DMA read request
 void NV_NVDLA_cdp::SendDmaReadRequest(nvdla_dma_rd_req_t* payload, sc_time& delay, uint8_t src_ram_type) {
-    cslDebug((50, "NV_NVDLA_cdp::SendDmaReadRequest, start.\n"));
+    //cslDebug((50, "NV_NVDLA_cdp::SendDmaReadRequest, start.\n"));
     if ( (NVDLA_CDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_MC) == src_ram_type ) {
         NV_NVDLA_cdp_base::cdp2mcif_rd_req_b_transport(payload, dma_delay_);
     } else {
         NV_NVDLA_cdp_base::cdp2cvif_rd_req_b_transport(payload, dma_delay_);
     }
-    cslDebug((50, "NV_NVDLA_cdp::SendDmaReadRequest, end.\n"));
+    //cslDebug((50, "NV_NVDLA_cdp::SendDmaReadRequest, end.\n"));
 }
 
 void NV_NVDLA_cdp::ExtractRdmaResponsePayload(nvdla_dma_rd_rsp_t* payload){
@@ -937,7 +937,7 @@ void NV_NVDLA_cdp::ExtractRdmaResponsePayload(nvdla_dma_rd_rsp_t* payload){
     uint8_t *payload_data_ptr;
     int8_t *rdma_atom_cube_ptr;
     uint8_t mask;
-    cslDebug((50, "NV_NVDLA_cdp::ExtractRdmaResponsePayload, get a dma read response payload\n"));
+    //cslDebug((50, "NV_NVDLA_cdp::ExtractRdmaResponsePayload, get a dma read response payload\n"));
     mask = payload->pd.dma_read_data.mask;
     payload_data_ptr    = reinterpret_cast <uint8_t *> (payload->pd.dma_read_data.data);
 
@@ -973,12 +973,12 @@ void NV_NVDLA_cdp::ExtractRdmaResponsePayload(nvdla_dma_rd_rsp_t* payload){
             }
         }
 
-        cslDebug((70, "write to rdma_buffer. mask A\n"));
+        //cslDebug((70, "write to rdma_buffer. mask A\n"));
         for(int i=0;i<32;i++)
         {
-            cslDebug((70, "%02x ", rdma_atom_cube_ptr[i]));
+            //cslDebug((70, "%02x ", rdma_atom_cube_ptr[i]));
         }
-        cslDebug((70, "\n"));
+        //cslDebug((70, "\n"));
     }
 
     // Handling upper 32 bytes
@@ -1007,15 +1007,15 @@ void NV_NVDLA_cdp::ExtractRdmaResponsePayload(nvdla_dma_rd_rsp_t* payload){
             }
         }
 
-        cslDebug((70, "write to rdma_buffer. mask B\n"));
+        //cslDebug((70, "write to rdma_buffer. mask B\n"));
         for(int i=0;i<32;i++)
         {
-            cslDebug((70, "%02x ", rdma_atom_cube_ptr[i]));
+            //cslDebug((70, "%02x ", rdma_atom_cube_ptr[i]));
         }
-        cslDebug((70, "\n"));
+        //cslDebug((70, "\n"));
     }
 
-    cslDebug((50, "NV_NVDLA_cdp::ExtractRdmaResponsePayload, txn=%d, atom_iter=%d\n", txn_r / 8, txn_r % 8));
+    //cslDebug((50, "NV_NVDLA_cdp::ExtractRdmaResponsePayload, txn=%d, atom_iter=%d\n", txn_r / 8, txn_r % 8));
 }
 
 void NV_NVDLA_cdp::mcif2cdp_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* payload, sc_core::sc_time& delay){
@@ -1057,7 +1057,7 @@ void NV_NVDLA_cdp::SendDmaWriteRequest(nvdla_dma_wr_req_t* payload, sc_time& del
 }
 
 void NV_NVDLA_cdp::WriteResponseThreadMc() {
-    cslInfo(("NV_NVDLA_cdp::WriteResponseThreadMc is called\n"));
+    //cslInfo(("NV_NVDLA_cdp::WriteResponseThreadMc is called\n"));
     if ( true == mcif2cdp_wr_rsp.read() ) {
 #if 0
         if (NVDLA_CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_MC != cdp_dst_ram_type_) {
@@ -1070,7 +1070,7 @@ void NV_NVDLA_cdp::WriteResponseThreadMc() {
 }
 
 void NV_NVDLA_cdp::WriteResponseThreadCv() {
-    cslInfo(("NV_NVDLA_cdp::WriteResponseThreadCv is called\n"));
+    //cslInfo(("NV_NVDLA_cdp::WriteResponseThreadCv is called\n"));
     if ( true == cvif2cdp_wr_rsp.read() ) {
 #if 0
         if (NVDLA_CDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_MC == cdp_dst_ram_type_) {
@@ -1086,13 +1086,13 @@ void NV_NVDLA_cdp::WriteResponseThreadCv() {
 uint16_t NV_NVDLA_cdp::read_lut() {
     int16_t tmp;
     tmp = read_lut(cdp_lut_table_idx, cdp_lut_entry_idx);  //cdp_lut_table_idx=0: read raw; cdp_lut_table_idx=1: read density
-    cslDebug((30, "CDP read_lut: cdp_lut_table_idx=%d cdp_lut_entry_idx=%d cdp_lut_data=%d\n", cdp_lut_table_idx, cdp_lut_entry_idx, tmp));
+    //cslDebug((30, "CDP read_lut: cdp_lut_table_idx=%d cdp_lut_entry_idx=%d cdp_lut_data=%d\n", cdp_lut_table_idx, cdp_lut_entry_idx, tmp));
     return tmp;
 }
 #pragma CTC ENDSKIP
 
 void NV_NVDLA_cdp::write_lut() {
-    cslDebug((30, "CDP write_lut: cdp_lut_table_idx=%d cdp_lut_entry_idx=%d cdp_lut_data=%d\n", cdp_lut_table_idx, cdp_lut_entry_idx, cdp_lut_data));
+    //cslDebug((30, "CDP write_lut: cdp_lut_table_idx=%d cdp_lut_entry_idx=%d cdp_lut_data=%d\n", cdp_lut_table_idx, cdp_lut_entry_idx, cdp_lut_data));
     write_lut(cdp_lut_table_idx, cdp_lut_entry_idx, cdp_lut_data);  //cdp_lut_table_idx=0: write raw; cdp_lut_table_idx=1: write density
 }
 
@@ -1290,16 +1290,16 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
         data_cvt_in_3[i*2+1] = data_cvt_in_2[i*2+1] * data_cvt_in_2[i*2+1];
     }
 
-    cslDebug((70, "Data after input convertor:\n"));
+    //cslDebug((70, "Data after input convertor:\n"));
     for(int i=0;i<parallel_num+8;i++) {
-        cslDebug((70," %x",  data_cvt_in_2[i].to_int()));
+        //cslDebug((70," %x",  data_cvt_in_2[i].to_int()));
     }
-    cslDebug((70, "\n"));
-    cslDebug((70, "Data after square:\n"));
+    //cslDebug((70, "\n"));
+    //cslDebug((70, "Data after square:\n"));
     for(int i=0;i<parallel_num+8;i++) {
-        cslDebug((70," %x",  data_cvt_in_3[i].to_int()));
+        //cslDebug((70," %x",  data_cvt_in_3[i].to_int()));
     }
-    cslDebug((70, "\n"));
+    //cslDebug((70, "\n"));
 
 
     for(i=0; i<parallel_num; i++) {
@@ -1319,7 +1319,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
                 square_sum = square_sum + data_cvt_in_3[i+4+j];
             }
         }
-        cslDebug((70, "Square sum: %lx\n",  (uint64_t)square_sum.to_int64() ));
+        //cslDebug((70, "Square sum: %lx\n",  (uint64_t)square_sum.to_int64() ));
 
         // Look up Raw table
         if(raw_method==NVDLA_CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_EXPONENT) {    //raw lut is exponential
@@ -1332,7 +1332,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
 
             index = log_sum - le_index_offset;
             
-            cslDebug((70, "LE start=%lx index_offset=%d index=%d sub_result=0x%lx\n", (uint64_t)raw_start, le_index_offset, index, (uint64_t)raw_input_temp));
+            //cslDebug((70, "LE start=%lx index_offset=%d index=%d sub_result=0x%lx\n", (uint64_t)raw_start, le_index_offset, index, (uint64_t)raw_input_temp));
 
             if(index < 0 || raw_input_temp <= 0)  {
                 int16_t slope = cdp_lut_le_slope_uflow_scale_;
@@ -1369,7 +1369,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
                 //offset_raw_0 = (1 << 16) - offset_raw_1;
                 //result_raw = (result_raw_0*offset_raw_0 + result_raw_1*offset_raw_1);
                 result_raw = result_raw_0 + convert((result_raw_1 - result_raw_0) * offset_raw_1, 16, INTERP_INTERMIDIATE_BITS_INT8, true);
-                cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_raw_0, result_raw_1, (uint64_t)offset_raw_1, (uint64_t)result_raw));
+                //cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_raw_0, result_raw_1, (uint64_t)offset_raw_1, (uint64_t)result_raw));
                 result_raw = convert(result_raw, 0, 16, true);
                 le_hit = true;
             }
@@ -1388,7 +1388,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
                 raw_index = raw_index_tmp >> raw_frac_bits;
             }
 
-            cslDebug((70, "LE start=%lx index_select=%d index=%ld sub_result=0x%lx\n", (uint64_t)raw_start, raw_frac_bits, raw_index, (uint64_t)raw_index_tmp));
+            //cslDebug((70, "LE start=%lx index_select=%d index=%ld sub_result=0x%lx\n", (uint64_t)raw_start, raw_frac_bits, raw_index, (uint64_t)raw_index_tmp));
 
             if (raw_index < 0 || raw_index_tmp <= 0) {
                 int16_t slope = le_slope_uflow_scale;
@@ -1396,7 +1396,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
                 shift = cdp_lut_le_slope_uflow_shift_;
                 result_raw = raw_lut[0] + convert((square_sum - raw_start)*slope,
                         shift.to_int(), INTERP_INTERMIDIATE_BITS_INT8, true);
-                cslDebug((70, "L0=%x start=%lx slope=%x shift=%x result=%lx\n", raw_lut[0], raw_start, slope, shift.to_int(), (uint64_t)result_raw));
+                //cslDebug((70, "L0=%x start=%lx slope=%x shift=%x result=%lx\n", raw_lut[0], raw_start, slope, shift.to_int(), (uint64_t)result_raw));
                 result_raw = convert(result_raw, 0, 16, true);
             }
             else if (raw_index >= 64){
@@ -1405,7 +1405,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
                 shift = cdp_lut_le_slope_oflow_shift_;
                 result_raw = raw_lut[64] + convert((square_sum - raw_end)*slope,
                         shift.to_int(), INTERP_INTERMIDIATE_BITS_INT8, true);
-                cslDebug((70, "L64=%x end=%lx slope=%x shift=%x result=%lx\n", raw_lut[64], raw_end, slope, shift.to_int(), (uint64_t)result_raw));
+                //cslDebug((70, "L64=%x end=%lx slope=%x shift=%x result=%lx\n", raw_lut[64], raw_end, slope, shift.to_int(), (uint64_t)result_raw));
                 result_raw = convert(result_raw, 0, 16, true);
 
                 le_overflow = true;
@@ -1429,7 +1429,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
                 //offset_raw_0 = (1 << 16) - offset_raw_1;
                 //result_raw = (result_raw_0*offset_raw_0 + result_raw_1*offset_raw_1);
                 result_raw = result_raw_0 + convert((result_raw_1 - result_raw_0) * offset_raw_1, 16, INTERP_INTERMIDIATE_BITS_INT8, true);
-                cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_raw_0, result_raw_1, (uint64_t)offset_raw_1, (uint64_t)result_raw));
+                //cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_raw_0, result_raw_1, (uint64_t)offset_raw_1, (uint64_t)result_raw));
                 result_raw = convert(result_raw, 0, 16, true);
                 le_hit = true;
             }
@@ -1449,7 +1449,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
             density_index = density_index_tmp >> density_frac_bits;
         }
             
-        cslDebug((70, "LO start=%lx index_select=%d index=%ld sub_result=0x%lx\n", (uint64_t)density_start, density_frac_bits, density_index, (uint64_t)density_index_tmp));
+        //cslDebug((70, "LO start=%lx index_select=%d index=%ld sub_result=0x%lx\n", (uint64_t)density_start, density_frac_bits, density_index, (uint64_t)density_index_tmp));
 
         if (density_index < 0 || density_index_tmp <= 0) {
             int16_t slope = lo_slope_uflow_scale;
@@ -1487,7 +1487,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
             //offset_density_0 = (1 << 16) - offset_density_1;
             //result_density = (result_density_0*offset_density_0 + result_density_1*offset_density_1);
             result_density = result_density_0 + convert((result_density_1 - result_density_0) * offset_density_1, 16, INTERP_INTERMIDIATE_BITS_INT8, true);
-            cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_density_0, result_density_1, (uint64_t)offset_density_1, (uint64_t)result_density));
+            //cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_density_0, result_density_1, (uint64_t)offset_density_1, (uint64_t)result_density));
             result_density = convert(result_density, 0, 16, true);
             lo_hit = true;
         }
@@ -1525,7 +1525,7 @@ void NV_NVDLA_cdp::lookup_lut_int8(int8_t *data_in, int parallel_num)
             data_cvt_out_0[i] = lut_result * data_cvt_in_2[i+4];
         }
 
-        cslDebug((70, "le: %lx, lo:%lx, out:%x mul:%x\n" , result_raw, result_density, lut_result.to_int(), data_cvt_out_0[i].to_int() ));
+        //cslDebug((70, "le: %lx, lo:%lx, out:%x mul:%x\n" , result_raw, result_density, lut_result.to_int(), data_cvt_out_0[i].to_int() ));
     }
 
     for(i = 0; i < parallel_num/2; i++) {
@@ -1672,16 +1672,16 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
         data_cvt_in_3[i] = data_cvt_in_2[i] * data_cvt_in_2[i];
     }
 
-    cslDebug((70, "Data after input convertor:\n"));
+    //cslDebug((70, "Data after input convertor:\n"));
     for(int i=0;i<12;i++) {
-        cslDebug((70," %x",  data_cvt_in_2[i].to_int()));
+        //cslDebug((70," %x",  data_cvt_in_2[i].to_int()));
     }
-    cslDebug((70, "\n"));
-    cslDebug((70, "Data after square:\n"));
+    //cslDebug((70, "\n"));
+    //cslDebug((70, "Data after square:\n"));
     for(int i=0;i<12;i++) {
-        cslDebug((70," %llx",  data_cvt_in_3[i].to_int64()));
+        //cslDebug((70," %llx",  data_cvt_in_3[i].to_int64()));
     }
-    cslDebug((70, "\n"));
+    //cslDebug((70, "\n"));
 
 
     for(i=0; i<4; i++) {
@@ -1701,7 +1701,7 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
                 square_sum = square_sum + data_cvt_in_3[i+4+j];
             }
         }
-        cslDebug((70, "Square sum: %lx\n",  (uint64_t)square_sum.to_int64() ));
+        //cslDebug((70, "Square sum: %lx\n",  (uint64_t)square_sum.to_int64() ));
 
         // Look up Raw table
         if(raw_method==NVDLA_CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_EXPONENT) {    //raw lut is exponential
@@ -1714,7 +1714,7 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
 
             index = log_sum - le_index_offset;
 
-            cslDebug((70, "x=0x%lx, index=%d, log_sum=%d\n", (uint64_t)raw_input_temp, index, log_sum));
+            //cslDebug((70, "x=0x%lx, index=%d, log_sum=%d\n", (uint64_t)raw_input_temp, index, log_sum));
         
             if(index < 0 || raw_input_temp <= 0)  {
                 int16_t slope = cdp_lut_le_slope_uflow_scale_;
@@ -1751,7 +1751,7 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
                 //offset_raw_0 = (1 << 16) - offset_raw_1;
                 //result_raw = (result_raw_0*offset_raw_0 + result_raw_1*offset_raw_1);
                 result_raw = result_raw_0 + convert((result_raw_1 - result_raw_0) * offset_raw_1, 16, INTERP_INTERMIDIATE_BITS, true);
-                cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_raw_0, result_raw_1, (uint64_t)offset_raw_1, (uint64_t)result_raw));
+                //cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_raw_0, result_raw_1, (uint64_t)offset_raw_1, (uint64_t)result_raw));
                 result_raw = convert(result_raw, 0, 16, true);
 
                 le_hit = true;
@@ -1772,7 +1772,7 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
                 raw_index = raw_index_tmp >> raw_frac_bits;
             }
             
-            cslDebug((70, "x=0x%lx, index=%ld\n", (uint64_t)raw_index_tmp, raw_index));
+            //cslDebug((70, "x=0x%lx, index=%ld\n", (uint64_t)raw_index_tmp, raw_index));
         
             if (raw_index < 0 || raw_index_tmp <= 0) {
                 int16_t slope = le_slope_uflow_scale;
@@ -1811,7 +1811,7 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
                 //offset_raw_0 = (1 << 16) - offset_raw_1;
                 //result_raw = (result_raw_0*offset_raw_0 + result_raw_1*offset_raw_1);
                 result_raw = result_raw_0 + convert((result_raw_1 - result_raw_0) * offset_raw_1, 16, INTERP_INTERMIDIATE_BITS, true);
-                cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_raw_0, result_raw_1, (uint64_t)offset_raw_1, (uint64_t)result_raw));
+                //cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_raw_0, result_raw_1, (uint64_t)offset_raw_1, (uint64_t)result_raw));
                 result_raw = convert(result_raw, 0, 16, true);
 
                 le_hit = true;
@@ -1832,7 +1832,7 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
             density_index = density_index_tmp >> density_frac_bits;
         }
             
-        cslDebug((70, "x=0x%lx, index=%ld\n", (uint64_t)density_index_tmp, density_index));
+        //cslDebug((70, "x=0x%lx, index=%ld\n", (uint64_t)density_index_tmp, density_index));
         
         if (density_index < 0 || density_index_tmp <= 0) {
             int16_t slope = lo_slope_uflow_scale;
@@ -1841,7 +1841,7 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
             result_density = density_lut[0] + convert((square_sum - density_start)*slope,
                     shift.to_int(), INTERP_INTERMIDIATE_BITS, true);
             
-            cslDebug((70, "result_density=0x%lx, L0=0x%x, slope=0x%x, shift=%d\n", (uint64_t)result_density, density_lut[0], slope, shift.to_int() ));
+            //cslDebug((70, "result_density=0x%lx, L0=0x%x, slope=0x%x, shift=%d\n", (uint64_t)result_density, density_lut[0], slope, shift.to_int() ));
 
             result_density = convert(result_density, 0, 16, true);
             lo_underflow = true;
@@ -1873,7 +1873,7 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
             //offset_density_0 = (1 << 16) - offset_density_1;
             //result_density = (result_density_0*offset_density_0 + result_density_1*offset_density_1);
             result_density = result_density_0 + convert((result_density_1 - result_density_0) * offset_density_1, 16, INTERP_INTERMIDIATE_BITS, true);
-            cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_density_0, result_density_1, (uint64_t)offset_density_1, (uint64_t)result_density));
+            //cslDebug((70, "L0=%x L1=%x offset=%lx result=%lx\n", result_density_0, result_density_1, (uint64_t)offset_density_1, (uint64_t)result_density));
             result_density = convert(result_density, 0, 16, true);
             lo_hit = true;
         }
@@ -1911,7 +1911,7 @@ void NV_NVDLA_cdp::lookup_lut(int16_t *data_in, int parallel_num)
             data_cvt_out_0[i] = lut_result * data_cvt_in_2[i+4];
         }
 
-        cslDebug((70, "le: %lx, lo:%lx, out:%x mul:%lx\n" , result_raw, result_density, lut_result.to_int(), (uint64_t)data_cvt_out_0[i].to_int64() ));
+        //cslDebug((70, "le: %lx, lo:%lx, out:%x mul:%lx\n" , result_raw, result_density, lut_result.to_int(), (uint64_t)data_cvt_out_0[i].to_int64() ));
 
 #ifdef USE_HLS
         //***** HLS Output Convertor (For INT16: i33->i16) ******
diff --git a/cmod/cdp/gen/cdp_rdma_reg_model.cpp b/cmod/cdp/gen/cdp_rdma_reg_model.cpp
index 01fdf1b..94527bf 100644
--- a/cmod/cdp/gen/cdp_rdma_reg_model.cpp
+++ b/cmod/cdp/gen/cdp_rdma_reg_model.cpp
@@ -85,7 +85,7 @@ bool cdp_rdma_reg_model::CdpRdmaAccessRegister(uint32_t reg_addr, uint32_t & dat
                 cdp_rdma_register_group_0->SetWritable(offset, data);
                 if (cdp_rdma_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_cdp_rdma_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cdp_rdma_reg_model::CdpRdmaAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "cdp_rdma_reg_model::CdpRdmaAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -97,7 +97,7 @@ bool cdp_rdma_reg_model::CdpRdmaAccessRegister(uint32_t reg_addr, uint32_t & dat
                 cdp_rdma_register_group_1->SetWritable(offset, data);
                 if (cdp_rdma_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_cdp_rdma_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cdp_rdma_reg_model::CdpRdmaAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "cdp_rdma_reg_model::CdpRdmaAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/cdp/gen/cdp_reg_model.cpp b/cmod/cdp/gen/cdp_reg_model.cpp
index edf00b1..c3ffc10 100644
--- a/cmod/cdp/gen/cdp_reg_model.cpp
+++ b/cmod/cdp/gen/cdp_reg_model.cpp
@@ -88,7 +88,7 @@ bool cdp_reg_model::CdpAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 cdp_register_group_0->SetWritable(offset, data);
                 if (cdp_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_cdp_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cdp_reg_model::CdpAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "cdp_reg_model::CdpAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -100,7 +100,7 @@ bool cdp_reg_model::CdpAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 cdp_register_group_1->SetWritable(offset, data);
                 if (cdp_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_cdp_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cdp_reg_model::CdpAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "cdp_reg_model::CdpAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/cmac/NV_NVDLA_cmac.cpp b/cmod/cmac/NV_NVDLA_cmac.cpp
index 485f7fe..51d45bc 100644
--- a/cmod/cmac/NV_NVDLA_cmac.cpp
+++ b/cmod/cmac/NV_NVDLA_cmac.cpp
@@ -83,24 +83,24 @@ void NV_NVDLA_cmac::CmacConsumerThread () {
         while(CmacAGetOpeartionEnable(cmac_a_register_group_0) != NVDLA_CMAC_A_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_cmac_a_reg_group_0_operation_enable);
         }
-        cslDebug((50, "%s NV_NVDLA_cmac::CmacConsumerThread, group 0 opeartion start\n", basename()));
+        //cslDebug((50, "%s NV_NVDLA_cmac::CmacConsumerThread, group 0 opeartion start\n", basename()));
         cmac_a_reg_model::CmacAUpdateWorkingStatus(0,1);
         cmac_a_reg_model::CmacAUpdateVariables(cmac_a_register_group_0);
         CmacHardwareLayerExecutionTrigger();
         cmac_a_reg_model::CmacAUpdateWorkingStatus(0,0);
         cmac_a_reg_model::CmacAClearOpeartionEnable(cmac_a_register_group_0);
-        cslDebug((50, "%s NV_NVDLA_cmac::CmacConsumerThread, group 0 opeartion done\n", basename()));
+        //cslDebug((50, "%s NV_NVDLA_cmac::CmacConsumerThread, group 0 opeartion done\n", basename()));
 
         while(CmacAGetOpeartionEnable(cmac_a_register_group_1) != NVDLA_CMAC_A_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_cmac_a_reg_group_1_operation_enable);
         }
-        cslDebug((50, "%s NV_NVDLA_cmac::CmacConsumerThread, group 1 opeartion start\n", basename()));
+        //cslDebug((50, "%s NV_NVDLA_cmac::CmacConsumerThread, group 1 opeartion start\n", basename()));
         cmac_a_reg_model::CmacAUpdateWorkingStatus(1,1);
         cmac_a_reg_model::CmacAUpdateVariables(cmac_a_register_group_1);
         CmacHardwareLayerExecutionTrigger();
         cmac_a_reg_model::CmacAUpdateWorkingStatus(1,0);
         cmac_a_reg_model::CmacAClearOpeartionEnable(cmac_a_register_group_1);
-        cslDebug((50, "%s NV_NVDLA_cmac::CmacConsumerThread, group 1 opeartion done\n", basename()));
+        //cslDebug((50, "%s NV_NVDLA_cmac::CmacConsumerThread, group 1 opeartion done\n", basename()));
     }
 }
 
@@ -140,12 +140,12 @@ void NV_NVDLA_cmac::sc2mac_wt_b_transport(int ID, nvdla_sc2mac_weight_if_t* payl
         weight_operand_shadow_[mac_cell_id * DATA_ELEMENT_NUM + iter] = payload_data_ptr[iter];
     }
 
-    cslDebug((70, "%s: weight before MAC on %d MAC cell:\n", __FUNCTION__, mac_cell_id));
+    //cslDebug((70, "%s: weight before MAC on %d MAC cell:\n", __FUNCTION__, mac_cell_id));
     for (iter = 0; iter < DATA_ELEMENT_NUM; iter ++) {  //DATA_ELEMENT_NUM=128
         uint8_t val = weight_operand_shadow_[mac_cell_id * DATA_ELEMENT_NUM + iter].to_int();
-        cslDebug((70, "%02x", val));
+        //cslDebug((70, "%02x", val));
     }
-    cslDebug((70, "\n"));
+    //cslDebug((70, "\n"));
 
 }
 
@@ -176,16 +176,16 @@ void NV_NVDLA_cmac::sc2mac_dat_b_transport(int ID, nvdla_sc2mac_data_if_t* paylo
     dat_mask[0] = payload->mask[0];
     dat_mask[1] = payload->mask[1];
 
-    cslDebug((70, "%s: data before MAC:\n", __FUNCTION__));
+    //cslDebug((70, "%s: data before MAC:\n", __FUNCTION__));
     for(int idx = 127; idx >= 0; idx--) {
         uint8_t val = data_operand_[idx].to_int();
-        cslDebug((70, "%02x", val));
+        //cslDebug((70, "%02x", val));
     }
-    cslDebug((70, "\n"));
+    //cslDebug((70, "\n"));
 
     // Calculation
     for (mac_cell_iter=0; mac_cell_iter < MAC_CELL_NUM; mac_cell_iter++) {
-        cslDebug((70, "%s Calling mac do_calc. mac_cell_iter=%d\n", basename(), mac_cell_iter));
+        //cslDebug((70, "%s Calling mac do_calc. mac_cell_iter=%d\n", basename(), mac_cell_iter));
         mac_enable = ((enabled_mac_cell_active_ & (0x1 << mac_cell_iter)) != 0);
         mac_cell_array[mac_cell_iter].do_calc(mac_enable, wino_op);
     }
@@ -198,16 +198,16 @@ void NV_NVDLA_cmac::sc2mac_dat_b_transport(int ID, nvdla_sc2mac_data_if_t* paylo
     }
     mac2accu_payload.pd.nvdla_stripe_info = payload->pd.nvdla_stripe_info;
 
-    cslDebug((50, "%s NV_NVDLA_cmac::mac2accu_dat_b_transport, mac2accu_payload is below\n", basename()));
-    cslDebug((50, "    layer_end is 0x%x\n" ,   (uint32_t)mac2accu_payload.pd.nvdla_stripe_info.layer_end));
-    cslDebug((50, "    channel_end is 0x%x\n",  (uint32_t)mac2accu_payload.pd.nvdla_stripe_info.channel_end));
-    cslDebug((50, "    stripe_st is 0x%x\n",   (uint32_t)mac2accu_payload.pd.nvdla_stripe_info.stripe_st));
-    cslDebug((50, "    stripe_end is 0x%x\n",   (uint32_t)mac2accu_payload.pd.nvdla_stripe_info.stripe_end));
-    cslDebug((50, "    Mask is 0x%x\n",         mac2accu_payload.mask));
-    cslDebug((50, "    Mode is 0x%x\n",         mac2accu_payload.mode));
+    //cslDebug((50, "%s NV_NVDLA_cmac::mac2accu_dat_b_transport, mac2accu_payload is below\n", basename()));
+    //cslDebug((50, "    layer_end is 0x%x\n" ,   (uint32_t)mac2accu_payload.pd.nvdla_stripe_info.layer_end));
+    //cslDebug((50, "    channel_end is 0x%x\n",  (uint32_t)mac2accu_payload.pd.nvdla_stripe_info.channel_end));
+    //cslDebug((50, "    stripe_st is 0x%x\n",   (uint32_t)mac2accu_payload.pd.nvdla_stripe_info.stripe_st));
+    //cslDebug((50, "    stripe_end is 0x%x\n",   (uint32_t)mac2accu_payload.pd.nvdla_stripe_info.stripe_end));
+    //cslDebug((50, "    Mask is 0x%x\n",         mac2accu_payload.mask));
+    //cslDebug((50, "    Mode is 0x%x\n",         mac2accu_payload.mode));
     for (uint32_t mac_cell_idx_db=0; mac_cell_idx_db<MAC_CELL_NUM; mac_cell_idx_db ++) {
         for (uint32_t element_idx_db=0; element_idx_db<RESULT_NUM_PER_MACELL; element_idx_db ++) {
-            cslDebug((70, "Data[0x%x,0x%x]: 0x%08llx\n", mac_cell_idx_db, element_idx_db, mac2accu_payload.data[mac_cell_idx_db * RESULT_NUM_PER_MACELL + element_idx_db].to_int64()));
+            //cslDebug((70, "Data[0x%x,0x%x]: 0x%08llx\n", mac_cell_idx_db, element_idx_db, mac2accu_payload.data[mac_cell_idx_db * RESULT_NUM_PER_MACELL + element_idx_db].to_int64()));
         }
     }
     mac2accu_b_transport(&mac2accu_payload, b_transport_delay_);
@@ -215,7 +215,7 @@ void NV_NVDLA_cmac::sc2mac_dat_b_transport(int ID, nvdla_sc2mac_data_if_t* paylo
     // Hardware layer done 
     if ( (1 == payload->pd.nvdla_stripe_info.layer_end) && (1 == payload->pd.nvdla_stripe_info.stripe_end) ) {
         cmac_done_.notify();
-        cslDebug((50, "%s NV_NVDLA_cmac::sc2mac_dat_b_transport, sent cmac_done notification\n", basename()));
+        //cslDebug((50, "%s NV_NVDLA_cmac::sc2mac_dat_b_transport, sent cmac_done notification\n", basename()));
     }
 }
 
diff --git a/cmod/cmac/NV_NVDLA_cmac.h b/cmod/cmac/NV_NVDLA_cmac.h
index 7524df6..ed20239 100644
--- a/cmod/cmac/NV_NVDLA_cmac.h
+++ b/cmod/cmac/NV_NVDLA_cmac.h
@@ -112,7 +112,7 @@ public:
         for(int x = 0; x < 4; x++) {
             for(int y = 0; y < 4; y++) {
                 for(int c = 0; c < 8; c++) {
-                    cslDebug((30, "x=%d y=%d c=%d data:0x%x, weight:0x%x\n", x, y, c, data_array[c][y][x], weight_array[c][y][x]));
+                    //cslDebug((30, "x=%d y=%d c=%d data:0x%x, weight:0x%x\n", x, y, c, data_array[c][y][x], weight_array[c][y][x]));
                 }
             }
         }
@@ -122,11 +122,11 @@ public:
         //cslDebug((30, "data:0x%x, weight:0x%x\n", data_array[0][0][0], weight_array[0][0][0]));
         //cslDebug((30, "data:0x%x, weight:0x%x\n", data_array[1][0][0], weight_array[1][0][0]));
 
-        cslDebug((50, "Calculation_int8: mac_cell_enable_ is %s\n", mac_cell_enable_? "true": "false"));
-        cslDebug((50, "    wt_mask[0]  : 0x%016lx\n", wt_mask[0]));
-        cslDebug((50, "    wt_mask[1]  : 0x%016lx\n", wt_mask[1]));
-        cslDebug((50, "    dat_mask[0] : 0x%016lx\n", dat_mask[0]));
-        cslDebug((50, "    dat_mask[1] : 0x%016lx\n", dat_mask[1]));
+        //cslDebug((50, "Calculation_int8: mac_cell_enable_ is %s\n", mac_cell_enable_? "true": "false"));
+        //cslDebug((50, "    wt_mask[0]  : 0x%016lx\n", wt_mask[0]));
+        //cslDebug((50, "    wt_mask[1]  : 0x%016lx\n", wt_mask[1]));
+        //cslDebug((50, "    dat_mask[0] : 0x%016lx\n", dat_mask[0]));
+        //cslDebug((50, "    dat_mask[1] : 0x%016lx\n", dat_mask[1]));
         if (true == mac_cell_enable_) {
             if (winograd_op_) {
                 for(kernel_iter=0; kernel_iter<2; kernel_iter++) {
@@ -139,7 +139,7 @@ public:
                             weight = weight_operand[kernel_iter*64+i*4+channel_iter];
                             accu_wino_phase1[i] = accu_wino_phase1[i] + data * weight;
                         }
-                        cslDebug((70, "    calculation_int8 winograd kernel_iter=%d accu_wino_phase1[%d] = 0x%x\n", kernel_iter, i, (uint32_t)accu_wino_phase1[i].to_int()));
+                        //cslDebug((70, "    calculation_int8 winograd kernel_iter=%d accu_wino_phase1[%d] = 0x%x\n", kernel_iter, i, (uint32_t)accu_wino_phase1[i].to_int()));
                     }
                     // Phase2: multiply transposition of matrix A. Generate 8 parital sums.
                     for (i=0; i<4; i++) {
@@ -156,43 +156,43 @@ public:
                     result[kernel_iter+4] = accu_wino_phase3[2];
                     result[kernel_iter+6] = accu_wino_phase3[3];
                 }
-                for(int i=0;i<8;i++)
-                    cslDebug((70, "    calculation_int8 winograd result = 0x%x\n", (uint32_t)result[i].to_int()));
+                //for(int i=0;i<8;i++)
+                    //cslDebug((70, "    calculation_int8 winograd result = 0x%x\n", (uint32_t)result[i].to_int()));
             }
             else {
                 for(kernel_iter=0; kernel_iter<2; kernel_iter++) {
                     accu = 0;
-                    cslDebug((70, "    kernel_iter  is 0x%x\n", kernel_iter));
+                    //cslDebug((70, "    kernel_iter  is 0x%x\n", kernel_iter));
                     for (channel_iter=0; channel_iter<PARALLEL_CHANNEL_NUM; channel_iter++) {
                         data   = data_operand[kernel_iter*PARALLEL_CHANNEL_NUM+channel_iter];
                         weight = weight_operand[kernel_iter*PARALLEL_CHANNEL_NUM+channel_iter];
-                        cslDebug((70, "    channel_iter is 0x%x\n", channel_iter));
-                        cslDebug((70, "    Data        : 0x%02x\n", (uint8_t)data));
-                        cslDebug((70, "    Weight      : 0x%02x\n", (uint8_t)weight));
+                        //cslDebug((70, "    channel_iter is 0x%x\n", channel_iter));
+                        //cslDebug((70, "    Data        : 0x%02x\n", (uint8_t)data));
+                        //cslDebug((70, "    Weight      : 0x%02x\n", (uint8_t)weight));
                         if (kernel_iter==0) {
                             wt_mask_k0  = (wt_mask[1] >> channel_iter) & 0x1;
                             dat_mask_k0 = (dat_mask[1] >> channel_iter) & 0x1;
-                            cslDebug((70, "    dat_mask_k0 : %d\n", dat_mask_k0));
-                            cslDebug((70, "    wt_mask_k0  : %d\n", wt_mask_k0));
+                            //cslDebug((70, "    dat_mask_k0 : %d\n", dat_mask_k0));
+                            //cslDebug((70, "    wt_mask_k0  : %d\n", wt_mask_k0));
                             if((wt_mask_k0 == 0) || (dat_mask_k0 == 0))
                                 continue;
                         }
                         else {
                             wt_mask_k1  = (wt_mask[0] >> channel_iter) & 0x1;
                             dat_mask_k1 = (dat_mask[0] >> channel_iter) & 0x1;
-                            cslDebug((70, "    dat_mask_k1 : %d\n", dat_mask_k1));
-                            cslDebug((70, "    wt_mask_k1  : %d\n", wt_mask_k1));
+                            //cslDebug((70, "    dat_mask_k1 : %d\n", dat_mask_k1));
+                            //cslDebug((70, "    wt_mask_k1  : %d\n", wt_mask_k1));
                             if((wt_mask_k1 == 0) || (dat_mask_k1 == 0))
                                 continue;
                         }
                         //accu  = accu + data * weight;
                         product = data * weight;
                         accu    = accu + product;
-                        cslDebug((70, "    product    : 0x%x\n", (uint32_t)product));
-                        cslDebug((70, "    accu       : 0x%x\n", (uint32_t)accu));
+                        //cslDebug((70, "    product    : 0x%x\n", (uint32_t)product));
+                        //cslDebug((70, "    accu       : 0x%x\n", (uint32_t)accu));
                     }
                     result[kernel_iter] = accu; // save to index 0 and 4 of result array which contains 8 elements
-                    cslDebug((70, "    calculation_int8 result = 0x%x\n", (uint32_t)accu.to_int()));
+                    //cslDebug((70, "    calculation_int8 result = 0x%x\n", (uint32_t)accu.to_int()));
                 }
             }
         }
@@ -220,13 +220,13 @@ public:
                 }
             }
         }
-        cslDebug((30, "data:%d, weight:%d\n", data_array[0][0][0], weight_array[0][0][0]));
+        //cslDebug((30, "data:%d, weight:%d\n", data_array[0][0][0], weight_array[0][0][0]));
 
-        cslDebug((50, "Calculation_int16: mac_cell_enable_ is %s\n", mac_cell_enable_? "true": "false"));
-        cslDebug((50, "    wt_mask[0]  : 0x%016lx\n", wt_mask[0]));
-        cslDebug((50, "    wt_mask[1]  : 0x%016lx\n", wt_mask[1]));
-        cslDebug((50, "    dat_mask[0] : 0x%016lx\n", dat_mask[0]));
-        cslDebug((50, "    dat_mask[1] : 0x%016lx\n", dat_mask[1]));
+        //cslDebug((50, "Calculation_int16: mac_cell_enable_ is %s\n", mac_cell_enable_? "true": "false"));
+        //cslDebug((50, "    wt_mask[0]  : 0x%016lx\n", wt_mask[0]));
+        //cslDebug((50, "    wt_mask[1]  : 0x%016lx\n", wt_mask[1]));
+        //cslDebug((50, "    dat_mask[0] : 0x%016lx\n", dat_mask[0]));
+        //cslDebug((50, "    dat_mask[1] : 0x%016lx\n", dat_mask[1]));
         if (true == mac_cell_enable_) {
             if (winograd_op_) {
                 // Phase1: Generate 16 partial sums
@@ -287,13 +287,13 @@ public:
                         }
                     }
                     accu = accu + data * weight;
-                    cslDebug((70, "    channel_iter is 0x%x\n", channel_iter));
-                    cslDebug((70, "    Data        : 0x%x\n", (uint32_t)data));
-                    cslDebug((70, "    Weight      : 0x%x\n", (uint32_t)weight));
-                    cslDebug((70, "    accu       : 0x%lx\n", (uint64_t)accu));
+                    //cslDebug((70, "    channel_iter is 0x%x\n", channel_iter));
+                    //cslDebug((70, "    Data        : 0x%x\n", (uint32_t)data));
+                    //cslDebug((70, "    Weight      : 0x%x\n", (uint32_t)weight));
+                    //cslDebug((70, "    accu       : 0x%lx\n", (uint64_t)accu));
                 }
                 (result[1], result[0]) = accu;
-                cslDebug((70, "    calculation_int16 result[0] = 0x%x result[1] = 0x%x\n", (uint32_t)result[0], (uint32_t)result[1]));
+                //cslDebug((70, "    calculation_int16 result[0] = 0x%x result[1] = 0x%x\n", (uint32_t)result[0], (uint32_t)result[1]));
             }
         }
     }
@@ -321,7 +321,7 @@ public:
             cur_idx     = ch_iter;
             if((fp16_exp == -1) && (fp16_fra != 0) && (cur_idx < nan_idx)) {
 #if LOG_DETAIL
-                cslDebug((70, "[FP16_NAN] find weight nan, cur_idx = %d\n\n", cur_idx));
+                //cslDebug((70, "[FP16_NAN] find weight nan, cur_idx = %d\n\n", cur_idx));
 #endif
                 *nan_flag = 1;
                 nan_idx = cur_idx;
@@ -355,7 +355,7 @@ public:
             cur_idx     = ch_iter + 64;
             if((fp16_exp == -1) && (fp16_fra != 0) && (cur_idx < nan_idx)) {
 #if LOG_DETAIL
-                cslDebug((70, "[FP16_NAN] find data nan, cur_idx = %d\n\n", cur_idx));
+                //cslDebug((70, "[FP16_NAN] find data nan, cur_idx = %d\n\n", cur_idx));
 #endif
                 *nan_flag = 1;
                 nan_idx = cur_idx;
@@ -422,7 +422,7 @@ public:
         }
 
 #if LOG_DETAIL
-        cslDebug((50, "[FP16_EXP]: max_exp = %x\n\n", *max_exp));
+        //cslDebug((50, "[FP16_EXP]: max_exp = %x\n\n", *max_exp));
 #endif
         for(exp_iter = 0; exp_iter < PARALLEL_CHANNEL_NUM; exp_iter ++) {
             sum_exp_sft[exp_iter] = ((*max_exp - sum_exp_sft[exp_iter]) << 2);
@@ -444,13 +444,13 @@ public:
 
         *mts_product = 0;
 #if LOG_DETAIL
-        cslDebug((70, "[FP16_BOOTH]: wt_mts = 0x%04x, dat_mts = 0x%04x, sign = %d, sum_exp_sft = %d\n", wt_mts, dat_mts, res_sign, sum_exp_sft));
+        //cslDebug((70, "[FP16_BOOTH]: wt_mts = 0x%04x, dat_mts = 0x%04x, sign = %d, sum_exp_sft = %d\n", wt_mts, dat_mts, res_sign, sum_exp_sft));
 #endif
 
         if(sum_exp_sft >= 32) {
 #if LOG_DETAIL
-            cslDebug((70, "[FP16_BOOTH]: pp_0_sft = 0x00000000, pp_1_sft = 0x00000000\n"));
-            cslDebug((70, "[FP16_MUL]: Booth result = 0x00000000, sign_comp = 0x00000000\n"));
+            //cslDebug((70, "[FP16_BOOTH]: pp_0_sft = 0x00000000, pp_1_sft = 0x00000000\n"));
+            //cslDebug((70, "[FP16_MUL]: Booth result = 0x00000000, sign_comp = 0x00000000\n"));
 #endif
             return;
         }
@@ -576,8 +576,8 @@ public:
         }
 
 #if LOG_DETAIL
-        cslDebug((70, "[FP16_BOOTH]: pp_0_sft = 0x%08x, pp_1_sft = 0x%08x\n", csa_pp[0], csa_pp[1]));
-        cslDebug((70, "[FP16_MUL]: Booth result = 0x%08x, sign_comp = 0x%08x\n", (csa_pp[0]+csa_pp[1]), sign_comp));
+        //cslDebug((70, "[FP16_BOOTH]: pp_0_sft = 0x%08x, pp_1_sft = 0x%08x\n", csa_pp[0], csa_pp[1]));
+        //cslDebug((70, "[FP16_MUL]: Booth result = 0x%08x, sign_comp = 0x%08x\n", (csa_pp[0]+csa_pp[1]), sign_comp));
 #endif
         sum = csa_pp[0] + csa_pp[1] + sign_comp;
         sum = sum & 0x00000000ffffffff;
@@ -605,16 +605,16 @@ public:
         fp16_mts.range(15,11) = 0;
         for(ch_iter = 0; ch_iter < PARALLEL_CHANNEL_NUM; ch_iter ++) {
 #if LOG_DETAIL
-            cslDebug((50, "[FP16_MUL] mul_idx = %d\n", ch_iter));
+            //cslDebug((50, "[FP16_MUL] mul_idx = %d\n", ch_iter));
 #endif
             i = 1 - int(ch_iter / 32);
             j = (ch_iter % 32) * 2;
 
             if(!((wt_mask[i] >> j) & 0x1) || !((dat_mask[i] >> j) & 0x1)) {
 #if LOG_DETAIL
-                cslDebug((70, "[FP16_MUL]: Booth result = 0x00000000, sign_comp = 0x00000000\n"));
-                cslDebug((50, "[FP16_MUL]: wt_val = 0x%04x, dat_val = 0x%04x, sum_exp_sft = %d, sign = %d\n", wt_val, dat_val, sum_exp_sft[ch_iter], res_sign));
-                cslDebug((50, "[FP16_MUL]: Real result = 0x00000000, stand result = 0x00000000, result delta = 0\n\n"));
+                //cslDebug((70, "[FP16_MUL]: Booth result = 0x00000000, sign_comp = 0x00000000\n"));
+                //cslDebug((50, "[FP16_MUL]: wt_val = 0x%04x, dat_val = 0x%04x, sum_exp_sft = %d, sign = %d\n", wt_val, dat_val, sum_exp_sft[ch_iter], res_sign));
+                //cslDebug((50, "[FP16_MUL]: Real result = 0x00000000, stand result = 0x00000000, result delta = 0\n\n"));
 #endif
                 mts_product[ch_iter] = 0;
                 continue;
@@ -654,8 +654,8 @@ public:
 
                 res_delta = res_veri - mts_product[ch_iter];
 #if LOG_DETAIL
-                cslDebug((50, "[FP16_MUL]: wt_val = 0x%04x, dat_val = 0x%04x, sum_exp_sft = %d, sign = %d\n", wt_val, dat_val, sum_exp_sft[ch_iter], res_sign));
-                cslDebug((50, "[FP16_MUL]: Real result = 0x%08x, stand result = 0x%08x, result delta = %d\n\n", mts_product[ch_iter], res_veri, res_delta));
+                //cslDebug((50, "[FP16_MUL]: wt_val = 0x%04x, dat_val = 0x%04x, sum_exp_sft = %d, sign = %d\n", wt_val, dat_val, sum_exp_sft[ch_iter], res_sign));
+                //cslDebug((50, "[FP16_MUL]: Real result = 0x%08x, stand result = 0x%08x, result delta = %d\n\n", mts_product[ch_iter], res_veri, res_delta));
 #endif
                 if(res_delta > 1 || res_delta < -1) {
                     FAIL(("FP16 mantissa error is out of range! res_delta = %x\n", res_delta)); 
@@ -707,11 +707,11 @@ public:
              result[result_iter] = 0;
         }
 
-        cslDebug((50, "Calculation_fp16: mac_cell_enable_ is %s\n", mac_cell_enable_? "true": "false"));
-        cslDebug((50, "    wt_mask[0]  : 0x%016lx\n", wt_mask[0]));
-        cslDebug((50, "    wt_mask[1]  : 0x%016lx\n", wt_mask[1]));
-        cslDebug((50, "    dat_mask[0] : 0x%016lx\n", dat_mask[0]));
-        cslDebug((50, "    dat_mask[1] : 0x%016lx\n", dat_mask[1]));
+        //cslDebug((50, "Calculation_fp16: mac_cell_enable_ is %s\n", mac_cell_enable_? "true": "false"));
+        //cslDebug((50, "    wt_mask[0]  : 0x%016lx\n", wt_mask[0]));
+        //cslDebug((50, "    wt_mask[1]  : 0x%016lx\n", wt_mask[1]));
+        //cslDebug((50, "    dat_mask[0] : 0x%016lx\n", dat_mask[0]));
+        //cslDebug((50, "    dat_mask[1] : 0x%016lx\n", dat_mask[1]));
         if (true == mac_cell_enable_) {
             cal_fp16_nan(wt_mask, dat_mask, data_operand, weight_operand, &nan_value, &nan_flag);
 
@@ -780,7 +780,7 @@ public:
                     double_data= float_data;
                     double_weight= float_weight;
                     marray[j]= double_data* double_weight;
-                    cslDebug((50, "CMAC:index=0x%d data=0x%04x weight=0x%04x mul_result=0x%016lx marray[%d]=%e\n", j, uint16_data_input, uint16_weight_input, ((uint64_t)(result[1], result[0])), j, marray[j]));
+                    //cslDebug((50, "CMAC:index=0x%d data=0x%04x weight=0x%04x mul_result=0x%016lx marray[%d]=%e\n", j, uint16_data_input, uint16_weight_input, ((uint64_t)(result[1], result[0])), j, marray[j]));
                 }
                 exp_new = exp_dc;
                 if(exp_new < 0) {
@@ -801,11 +801,11 @@ public:
                         cal_out[j] = pp_phase3[j] * pow(2, exp_new);
                         if(fabs(double_out[j]-cal_out[j])> cmac_delta){
 #ifdef LOG_DETAIL
-                            cslDebug((50, "stepheng:the 0x%d\n th output, total 4", j));
+                            //cslDebug((50, "stepheng:the 0x%d\n th output, total 4", j));
                             //cslDebug((50, "stepheng:cmac pure V output origninal high 22bits: 0x%06lx\n",result[j*2+1] ));
                             //cslDebug((50, "stepheng:cmac pure V output origninal low 22bits: 0x%06lx\n",result[j*2] ));
-                            cslDebug((50, "stepheng:cmac pure C double-2-hex output: 0x%016lx\n",*((uint64_t*)(&double_out[j])) ));
-                            cslDebug((50, "stepheng:cmac pure V double-2-hex output: 0x%016lx\n",*((uint64_t*)(&cal_out[j])) ));                            
+                            //cslDebug((50, "stepheng:cmac pure C double-2-hex output: 0x%016lx\n",*((uint64_t*)(&double_out[j])) ));
+                            //cslDebug((50, "stepheng:cmac pure V double-2-hex output: 0x%016lx\n",*((uint64_t*)(&cal_out[j])) ));
 #endif
                             FAIL(("Error: CMAC output is not sync with high level checker!!\n"));
                         }
@@ -820,12 +820,12 @@ public:
                     if(fabs(double_out[0]-cal_out[0])> cmac_delta){
                         //cslDebug((50, "stepheng:cmac pure V output origninal high 22bits: 0x%06lx\n",result[1] ));
                         //cslDebug((50, "stepheng:cmac pure V output origninal low 22bits: 0x%06lx\n",result[0] ));
-                        cslDebug((50, "stepheng:cmac pure C double-2-hex output: 0x%016lx\n",*((uint64_t*)(&double_out[0])) ));
-                        cslDebug((50, "stepheng:cmac pure V double-2-hex output: 0x%016lx\n",*((uint64_t*)(&cal_out)) ));
+                        //cslDebug((50, "stepheng:cmac pure C double-2-hex output: 0x%016lx\n",*((uint64_t*)(&double_out[0])) ));
+                        //cslDebug((50, "stepheng:cmac pure V double-2-hex output: 0x%016lx\n",*((uint64_t*)(&cal_out)) ));
                         FAIL(("Error: CMAC output is not sync with high level checker!!\n"));
                     }
                     else {
-                        cslDebug((50, "stepheng:cmac pure C double-2-hex output: 0x%016lx (%e)\n", *((uint64_t*)(&double_out[0])), double_out[0]));
+                        //cslDebug((50, "stepheng:cmac pure C double-2-hex output: 0x%016lx (%e)\n", *((uint64_t*)(&double_out[0])), double_out[0]));
                     }
                 }
 #endif
diff --git a/cmod/cmac/gen/cmac_a_reg_model.cpp b/cmod/cmac/gen/cmac_a_reg_model.cpp
index 1ff2563..82fb565 100644
--- a/cmod/cmac/gen/cmac_a_reg_model.cpp
+++ b/cmod/cmac/gen/cmac_a_reg_model.cpp
@@ -85,7 +85,7 @@ bool cmac_a_reg_model::CmacAAccessRegister(uint32_t reg_addr, uint32_t & data, b
                 cmac_a_register_group_0->SetWritable(offset, data);
                 if (cmac_a_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_cmac_a_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cmac_a_reg_model::CmacAAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "cmac_a_reg_model::CmacAAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -97,7 +97,7 @@ bool cmac_a_reg_model::CmacAAccessRegister(uint32_t reg_addr, uint32_t & data, b
                 cmac_a_register_group_1->SetWritable(offset, data);
                 if (cmac_a_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_cmac_a_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "cmac_a_reg_model::CmacAAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "cmac_a_reg_model::CmacAAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/csc/NV_NVDLA_csc.cpp b/cmod/csc/NV_NVDLA_csc.cpp
index 54dcd18..e61b27a 100644
--- a/cmod/csc/NV_NVDLA_csc.cpp
+++ b/cmod/csc/NV_NVDLA_csc.cpp
@@ -154,7 +154,7 @@ void NV_NVDLA_csc::CscConsumerThread () {
         }
         csc_reg_model::CscUpdateWorkingStatus(0,1);
         csc_reg_model::CscUpdateVariables(csc_register_group_0);
-        cslDebug((50, "CSC group 0 trigger\n"));
+        //cslDebug((50, "CSC group 0 trigger\n"));
         CscHardwareLayerExecutionTrigger();
         csc_reg_model::CscUpdateWorkingStatus(0,0);
         csc_reg_model::CscClearOpeartionEnable(csc_register_group_0);
@@ -164,7 +164,7 @@ void NV_NVDLA_csc::CscConsumerThread () {
         }
         csc_reg_model::CscUpdateWorkingStatus(1,1);
         csc_reg_model::CscUpdateVariables(csc_register_group_1);
-        cslDebug((50, "CSC group 1 trigger\n"));
+        //cslDebug((50, "CSC group 1 trigger\n"));
         CscHardwareLayerExecutionTrigger();
         csc_reg_model::CscUpdateWorkingStatus(1,0);
         csc_reg_model::CscClearOpeartionEnable(csc_register_group_1);
@@ -174,11 +174,11 @@ void NV_NVDLA_csc::CscConsumerThread () {
 void NV_NVDLA_csc::CscHardwareLayerExecutionTrigger () {
     kernel_switch_round_data_   = 0;
     kernel_switch_round_weight_ = 0;
-    cslDebug((50, "calling csc_kickoff_.notify\n"));
+    //cslDebug((50, "calling csc_kickoff_.notify\n"));
     csc_kickoff_.notify();
     //wait(csc_data_fetch_done_);
     wait(csc_weight_fetch_done_);   //FIXME(skip-t194): to use FIFO like in cdma
-    cslDebug((50, "CscHardwareLayerExecutionTrigger Done\n"));
+    //cslDebug((50, "CscHardwareLayerExecutionTrigger Done\n"));
 }
 
 void NV_NVDLA_csc::DataLoadSequenceThread () {
@@ -205,30 +205,30 @@ void NV_NVDLA_csc::DataLoadSequenceThread () {
                     dat_up_sc2cdma_payload.dat_entries = csc_prev_left_dat_entries_;
                     dat_up_sc2cdma_b_transport(&dat_up_sc2cdma_payload, b_transport_delay_);
                 }
-                cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. DATA_BANK changed.\n"));
+                //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. DATA_BANK changed.\n"));
             } else {
                 if (csc_prev_left_dat_entries_ > 0) {   // Release left data of previous layer in cbuf
                     dat_up_sc2cdma_payload.dat_slices = csc_prev_left_dat_slices_;
                     dat_up_sc2cdma_payload.dat_entries = csc_prev_left_dat_entries_;
                     dat_up_sc2cdma_b_transport(&dat_up_sc2cdma_payload, b_transport_delay_);
                     data_entry_idx_free_ += csc_prev_left_dat_entries_;
-                    cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Not reuse previous layer's data. Partial data of previous layer was released. data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
+                    //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Not reuse previous layer's data. Partial data of previous layer was released. data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
                 } else {
-                    cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Not reuse previous layer's data. All data of previous layer was released.  data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
+                    //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Not reuse previous layer's data. All data of previous layer was released.  data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
                 }
             }
-            cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Mode or BANK changed. Restart from 0 of cbuf\n"));
+            //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Mode or BANK changed. Restart from 0 of cbuf\n"));
         }
         else if (csc_dat_prev_skip_data_rls_ && csc_data_reuse_ && (csc_dat_prev_conv_mode_ == csc_conv_mode_) &&
                 (csc_dat_prev_data_bank_ == csc_data_bank_) && (csc_dat_prev_weight_bank_ == csc_weight_bank_) && (csc_dat_prev_input_data_format_ == csc_dat_input_data_format_)) {
             // reuse previous layer's entire data
-            cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. reuse previous layer's entire data. data_entry_idx_free_=0x%lx data_entry_idx_available_=0x%lx\n", data_entry_idx_free_, data_entry_idx_available_));
+            //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. reuse previous layer's entire data. data_entry_idx_free_=0x%lx data_entry_idx_available_=0x%lx\n", data_entry_idx_free_, data_entry_idx_available_));
         }
         else if (!csc_dat_prev_skip_data_rls_ && csc_data_reuse_ && (csc_dat_prev_conv_mode_ == csc_conv_mode_) &&
                 (csc_dat_prev_data_bank_ == csc_data_bank_) && (csc_dat_prev_weight_bank_ == csc_weight_bank_) && (csc_dat_prev_input_data_format_ == csc_dat_input_data_format_)) {
             // reuse partial data of previous layer
             // Continue to use cbuf following the end of previous layer
-            cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. reuse previous layer's partial data. data_entry_idx_free_=0x%lx data_entry_idx_available_=0x%lx\n", data_entry_idx_free_, data_entry_idx_available_));
+            //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. reuse previous layer's partial data. data_entry_idx_free_=0x%lx data_entry_idx_available_=0x%lx\n", data_entry_idx_free_, data_entry_idx_available_));
         }
         else {
             // Not reuse data of previous layer
@@ -237,9 +237,9 @@ void NV_NVDLA_csc::DataLoadSequenceThread () {
                 dat_up_sc2cdma_payload.dat_entries = csc_prev_left_dat_entries_;
                 dat_up_sc2cdma_b_transport(&dat_up_sc2cdma_payload, b_transport_delay_);
                 data_entry_idx_free_ += csc_prev_left_dat_entries_;
-                cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Not reuse previous layer's data. Partial data of previous layer was released. data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
+                //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Not reuse previous layer's data. Partial data of previous layer was released. data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
             } else {
-                cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Not reuse previous layer's data. All data of previous layer was released.  data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
+                //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread. Not reuse previous layer's data. All data of previous layer was released.  data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
             }
         }
 
@@ -285,7 +285,7 @@ void NV_NVDLA_csc::DataLoadSequenceThread () {
                 break;
 #pragma CTC ENDSKIP
             case DATA_LOAD_MODE_WINOGRAD_CONV:
-                cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread calling SendDataToMacSequencerWinoConvCommon\n")); 
+                //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread calling SendDataToMacSequencerWinoConvCommon\n"));
                 SendDataToMacSequencerWinoConvCommon();
                 break;
 #pragma CTC SKIP
@@ -300,18 +300,18 @@ void NV_NVDLA_csc::DataLoadSequenceThread () {
             released_slice_num          = 0;
             csc_prev_left_dat_slices_   = (csc_batches_ + 1) * (csc_datain_height_ext_ + 1);
             csc_prev_left_dat_entries_  = csc_prev_left_dat_slices_ * (csc_entries_ + 1);
-            cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread, end of current layer. not release slices\n"));
+            //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread, end of current layer. not release slices\n"));
         } else {
             // Release slices, the number is rls_slices_
             released_slice_num          = csc_rls_slices_ + 1;
             csc_prev_left_dat_slices_   = (csc_batches_ + 1) * (csc_datain_height_ext_ + 1) - released_slice_num;
             csc_prev_left_dat_entries_  = csc_prev_left_dat_slices_ * (csc_entries_ + 1);
-            cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread, end of current layer. released_slice_num=0x%x\n", released_slice_num));
+            //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread, end of current layer. released_slice_num=0x%x\n", released_slice_num));
         }
 
         // Advance data_entry_idx_free_
         data_entry_idx_free_ += released_slice_num * (csc_entries_ + 1);
-        cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread, end of current layer. data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
+        //cslInfo(("NV_NVDLA_csc::DataLoadSequenceThread, end of current layer. data_entry_idx_free_=0x%lx\n", data_entry_idx_free_));
         // Release slices at the end of layer
         if (released_slice_num > 0) {
             dat_up_sc2cdma_payload.dat_slices   = released_slice_num;
@@ -377,7 +377,7 @@ void NV_NVDLA_csc::WeightLoadSequenceThread () {
                     wt_up_sc2cdma_payload.wmb_entries = csc_prev_left_wmb_entries_;
                     wt_up_sc2cdma_b_transport(&wt_up_sc2cdma_payload, b_transport_delay_);
                 }
-                cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. BANK changed. reset cbuf pointers\n"));
+                //cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. BANK changed. reset cbuf pointers\n"));
             } else {
 #if ENABLE_WEIGHT_REUSE
                 weight_kernel_num_used_prev_ = weight_kernel_num_used_; // weight_kernel_num_used_ may be increased in layer exeuction. save to weight_kernel_num_used_prev_
@@ -392,13 +392,13 @@ void NV_NVDLA_csc::WeightLoadSequenceThread () {
                     wt_up_sc2cdma_payload.wmb_entries = csc_prev_left_wmb_entries_;
                     wt_up_sc2cdma_b_transport(&wt_up_sc2cdma_payload, b_transport_delay_);
                 }
-                cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. BANK not change. not reset cbuf pointers\n"));
+                //cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. BANK not change. not reset cbuf pointers\n"));
             }
-            cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. MODE or BANK changed.\n"));
+            //cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. MODE or BANK changed.\n"));
         }
         else if (csc_wt_prev_skip_weight_rls_ && csc_weight_reuse_ && (csc_wt_prev_conv_mode_ == csc_conv_mode_) &&    // reuse previous layer's weight
                 (csc_wt_prev_data_bank_ == csc_data_bank_) && (csc_wt_prev_weight_bank_ == csc_weight_bank_) && (csc_wt_prev_input_data_format_ == csc_wt_input_data_format_)) {
-            cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. reuse previous layer's weight. weight_entry_idx_start_=0x%lx weight_entry_idx_available_=0x%lx weight_layer_start_byte_idx_=0x%lx\n", weight_entry_idx_start_, weight_entry_idx_available_, weight_layer_start_byte_idx_));
+            //cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. reuse previous layer's weight. weight_entry_idx_start_=0x%lx weight_entry_idx_available_=0x%lx weight_layer_start_byte_idx_=0x%lx\n", weight_entry_idx_start_, weight_entry_idx_available_, weight_layer_start_byte_idx_));
 #if ENABLE_WEIGHT_REUSE
             weight_kernel_num_used_ = weight_kernel_num_used_prev_;
             weight_entry_idx_start_ = weight_entry_idx_start_prev_;
@@ -422,7 +422,7 @@ void NV_NVDLA_csc::WeightLoadSequenceThread () {
                 wt_up_sc2cdma_payload.wmb_entries = csc_prev_left_wmb_entries_;
                 wt_up_sc2cdma_b_transport(&wt_up_sc2cdma_payload, b_transport_delay_);
             }
-            cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. Not reuse previous layer's weight. weight_entry_idx_start_=0x%lx weight_entry_idx_available_=0x%lx\n", weight_entry_idx_start_, weight_entry_idx_available_));
+            //cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread. Not reuse previous layer's weight. weight_entry_idx_start_=0x%lx weight_entry_idx_available_=0x%lx\n", weight_entry_idx_start_, weight_entry_idx_available_));
         }
 
         // Evaluation operation mode
@@ -452,11 +452,11 @@ void NV_NVDLA_csc::WeightLoadSequenceThread () {
         switch(weight_load_operation_mode) {
             case WEIGHT_LOAD_MODE_DIRECT_CONV_NONE_BATCH:
             case WEIGHT_LOAD_MODE_DIRECT_CONV:
-                cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread calling SendWeightToMacSequencerDirectConvCommon\n")); 
+                //cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread calling SendWeightToMacSequencerDirectConvCommon\n"));
                 SendWeightToMacSequencerDirectConvCommon();
                 break;
             case WEIGHT_LOAD_MODE_IMAGE_CONV_NONE_BATCH:
-                cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread calling SendImageWeightToMacSequencerConvCommon\n")); 
+                //cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread calling SendImageWeightToMacSequencerConvCommon\n"));
                 SendWeightToMacSequencerDirectConvCommon();
                 //SendImageWeightToMacSequencerConvCommon();
                 break;
@@ -464,7 +464,7 @@ void NV_NVDLA_csc::WeightLoadSequenceThread () {
                 FAIL(("NV_NVDLA_csc::WeightLoadSequenceThread, batch direct convolution sequences has not been implemented."));
                 break;
             case WEIGHT_LOAD_MODE_WINOGRAD_CONV:
-                cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread calling SendWeightToMacSequencerWinoConvCommon\n")); 
+                //cslInfo(("NV_NVDLA_csc::WeightLoadSequenceThread calling SendWeightToMacSequencerWinoConvCommon\n"));
                 SendWeightToMacSequencerWinoConvCommon();
                 //FAIL(("NV_NVDLA_csc::WeightLoadSequenceThread, Winograd convolution sequences has not been implemented."));
                 break;
@@ -578,7 +578,7 @@ void NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon() {
     uint8_t  stripe_length_per_batch[33] = {0, 16, 8, 8, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 
                                   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
 
-    cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, start\n"));
+    //cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, start\n"));
     read_data_ptr = new sc_uint<64> [CBUF_ENTRY_SIZE/8];
 
     // Copy from register value to local config variables, similar with RTL connection
@@ -601,9 +601,9 @@ void NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon() {
     cbuf_entry_for_data     = (csc_data_bank_+1) * CBUF_ENTRY_PER_BANK;
     batch_num               = csc_batches_ + 1;
 
-    cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, cube_out_width is:0x%x\n", cube_out_width));
-    cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, cube_out_height is:0x%x\n", cube_out_height));
-    cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, cube_out_channel is:0x%x\n", cube_out_channel));
+    //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, cube_out_width is:0x%x\n", cube_out_width));
+    //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, cube_out_height is:0x%x\n", cube_out_height));
+    //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, cube_out_channel is:0x%x\n", cube_out_channel));
     // Evaluated
     switch (precision) {
         case DATA_FORMAT_INT8:
@@ -652,9 +652,9 @@ void NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon() {
 
     output_atom_num     = cube_out_height * cube_out_width;
     required_slice_num  = cube_in_height * batch_num;
-    cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput, wait cbuffer.\n"));
+    //cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput, wait cbuffer.\n"));
     WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput(required_slice_num*cbuf_entry_per_slice);
-    cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput, wait cbuffer Done.\n"));
+    //cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput, wait cbuffer Done.\n"));
     if (batch_num<16) {
         if (output_atom_num >= 2 * ideal_stripe_length_per_batch)
             last_stripe_length_per_batch = ( ((output_atom_num % ideal_stripe_length_per_batch)==0)? ideal_stripe_length_per_batch: (output_atom_num % ideal_stripe_length_per_batch) ) + ideal_stripe_length_per_batch;
@@ -666,9 +666,9 @@ void NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon() {
 
     stripe_num = (output_atom_num - last_stripe_length_per_batch)/ideal_stripe_length_per_batch + 1;
     // each out_surface (a channel of output cube) corresponds to a group(number of 16) of kernels
-    cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, out_surface_num is: 0x%x\n", out_surface_num));
-    cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, stripe_num is: 0x%x\n", stripe_num));
-    cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, last_super_channel_element_num is: 0x%x\n", last_super_channel_element_num));
+    //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, out_surface_num is: 0x%x\n", out_surface_num));
+    //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, stripe_num is: 0x%x\n", stripe_num));
+    //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, last_super_channel_element_num is: 0x%x\n", last_super_channel_element_num));
     for (out_surface_iter  = 0; out_surface_iter<out_surface_num; out_surface_iter ++) {
         for (stripe_iter=0; stripe_iter < stripe_num; stripe_iter++){ // Loop on all stripes in output cube's W'xH' plane
             output_atom_sent_num = stripe_iter * ideal_stripe_length_per_batch; // Count per input cube
@@ -700,9 +700,9 @@ void NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon() {
                             // Notify CMAC needs to reload weight
                             if ((batch_iter==0) && (output_atom_iter==output_atom_sent_num)) { //The 1st atom of the stripe
                                 sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st = 1;
-                                cslDebug((30, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, before WaitUntilKernelsAreReady.\n"));
+                                //cslDebug((30, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, before WaitUntilKernelsAreReady.\n"));
                                 WaitUntilKernelsAreReady(); //Kernels should be loaded into shadow before featue data
-                                cslDebug((30, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, a group of weight for a stripe operation was ready.\n"));
+                                //cslDebug((30, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, a group of weight for a stripe operation was ready.\n"));
                             } else {
                                 sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st = 0;
                             }
@@ -718,7 +718,7 @@ void NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon() {
                             if ((kernel_atom_iter == kernel_atom_num-1) && last_super_channel) { //&&        // Last stripe operation and the last block operation of current channel operation
                                 // (output_atom_iter == output_atom_sent_num + current_stripe_length - 1))   // All atom operations of current stripe operation should have channel_end=1. Same as layer_end.
                                 sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end = 1;
-                                cslDebug((30, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, got a channel_end, out_surface_iter is 0x%x, out_surface_num is 0x%x, stripe_iter is 0x%x, stripe_num is 0x%x\n", out_surface_iter, out_surface_num, stripe_iter, stripe_num));
+                                //cslDebug((30, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, got a channel_end, out_surface_iter is 0x%x, out_surface_num is 0x%x, stripe_iter is 0x%x, stripe_num is 0x%x\n", out_surface_iter, out_surface_num, stripe_iter, stripe_num));
                                 if ( (out_surface_iter==out_surface_num-1) && (stripe_iter==stripe_num-1) ) {    //The last atom of the input cube (last stripe and last output surface)
                                     // Layer done, notify CACC set the hardware layer done bit
                                     sc2mac_a_dat_payload.pd.nvdla_stripe_info.layer_end = 1;
@@ -758,17 +758,17 @@ void NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon() {
                                         }
                                         break;
                                 }
-                                cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, Padding coordinate:\n"));
-                                cslDebug((50, "    out_surface_iter           is %d\n", out_surface_iter));
-                                cslDebug((50, "    stripe_iter                is %d\n", stripe_iter));
-                                cslDebug((50, "    batch_iter                 is %d\n", batch_iter));
-                                cslDebug((50, "    super_channel_iter         is %d\n", super_channel_iter));
-                                cslDebug((50, "    kernel_atom_iter           is %d\n", kernel_atom_iter));
-                                cslDebug((50, "    output_atom_iter           is %d\n", output_atom_iter));
-                                cslDebug((50, "    output_atom_coor_width     is %d\n", output_atom_coor_width));
-                                cslDebug((50, "    output_atom_coor_height    is %d\n", output_atom_coor_height));
-                                cslDebug((50, "    input_atom_coor_width      is %d\n", input_atom_coor_width));
-                                cslDebug((50, "    input_atom_coor_height     is %d\n", input_atom_coor_height));
+                                //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, Padding coordinate:\n"));
+                                //cslDebug((50, "    out_surface_iter           is %d\n", out_surface_iter));
+                                //cslDebug((50, "    stripe_iter                is %d\n", stripe_iter));
+                                //cslDebug((50, "    batch_iter                 is %d\n", batch_iter));
+                                //cslDebug((50, "    super_channel_iter         is %d\n", super_channel_iter));
+                                //cslDebug((50, "    kernel_atom_iter           is %d\n", kernel_atom_iter));
+                                //cslDebug((50, "    output_atom_iter           is %d\n", output_atom_iter));
+                                //cslDebug((50, "    output_atom_coor_width     is %d\n", output_atom_coor_width));
+                                //cslDebug((50, "    output_atom_coor_height    is %d\n", output_atom_coor_height));
+                                //cslDebug((50, "    input_atom_coor_width      is %d\n", input_atom_coor_width));
+                                //cslDebug((50, "    input_atom_coor_height     is %d\n", input_atom_coor_height));
                             } else {
                                 // None padding coordinate, read data from CBUF
                                 if (last_super_channel) {
@@ -806,18 +806,18 @@ void NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon() {
                                 }
                                 sc2buf_dat_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr = cbuf_entry_addr;
                                 // Send CBUF read request (block read)
-                                cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, sc2buf_dat_rd_b_transport\n"));
-                                cslDebug((50, "    out_surface_iter           is %d\n", out_surface_iter));
-                                cslDebug((50, "    stripe_iter                is %d\n", stripe_iter));
-                                cslDebug((50, "    batch_iter                 is %d\n", batch_iter));
-                                cslDebug((50, "    super_channel_iter         is %d\n", super_channel_iter));
-                                cslDebug((50, "    kernel_atom_iter           is %d\n", kernel_atom_iter));
-                                cslDebug((50, "    output_atom_iter           is %d\n", output_atom_iter));
-                                cslDebug((50, "    output_atom_coor_width     is %d\n", output_atom_coor_width));
-                                cslDebug((50, "    output_atom_coor_height    is %d\n", output_atom_coor_height));
-                                cslDebug((50, "    input_atom_coor_width      is %d\n", input_atom_coor_width));
-                                cslDebug((50, "    input_atom_coor_height     is %d\n", input_atom_coor_height));
-                                cslDebug((50, "    cbuf_entry_addr            is 0x%x\n", cbuf_entry_addr));
+                                //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, sc2buf_dat_rd_b_transport\n"));
+                                //cslDebug((50, "    out_surface_iter           is %d\n", out_surface_iter));
+                                //cslDebug((50, "    stripe_iter                is %d\n", stripe_iter));
+                                //cslDebug((50, "    batch_iter                 is %d\n", batch_iter));
+                                //cslDebug((50, "    super_channel_iter         is %d\n", super_channel_iter));
+                                //cslDebug((50, "    kernel_atom_iter           is %d\n", kernel_atom_iter));
+                                //cslDebug((50, "    output_atom_iter           is %d\n", output_atom_iter));
+                                //cslDebug((50, "    output_atom_coor_width     is %d\n", output_atom_coor_width));
+                                //cslDebug((50, "    output_atom_coor_height    is %d\n", output_atom_coor_height));
+                                //cslDebug((50, "    input_atom_coor_width      is %d\n", input_atom_coor_width));
+                                //cslDebug((50, "    input_atom_coor_height     is %d\n", input_atom_coor_height));
+                                //cslDebug((50, "    cbuf_entry_addr            is 0x%x\n", cbuf_entry_addr));
                                 // NOTE: For packed data storage and int8, we may read same entry more than once. There is optimazation in RTL not to read cbuf if unnecessary.
                                 //       So there is mismatch on cbuf2csc interface between RTL and cmodel.
                                 sc2buf_dat_rd_b_transport(&sc2buf_dat_rd_payload, b_transport_delay_);
@@ -916,23 +916,23 @@ void NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon() {
                                     }
                                     break;
                             }
-                            cslDebug((50, "sc2mac_a_dat_payload: stripe_st=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st));
-                            cslDebug((50, " stripe_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end));
-                            cslDebug((50, " channel_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end));
-                            cslDebug((50, " layer_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.layer_end));
-                            cslDebug((50, " mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_dat_payload.mask[0]));
-                            cslDebug((50, " mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_dat_payload.mask[1]));
+                            //cslDebug((50, "sc2mac_a_dat_payload: stripe_st=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st));
+                            //cslDebug((50, " stripe_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end));
+                            //cslDebug((50, " channel_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end));
+                            //cslDebug((50, " layer_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.layer_end));
+                            //cslDebug((50, " mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_dat_payload.mask[0]));
+                            //cslDebug((50, " mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_dat_payload.mask[1]));
 #if LOG_DETAIL
                             for (uint32_t idx_db=0; idx_db<128; idx_db++) {
-                                cslDebug((90, "    Data[%d]: 0x%02x\n", idx_db, sc2mac_a_dat_payload.data[idx_db].to_int()));
+                                //cslDebug((90, "    Data[%d]: 0x%02x\n", idx_db, sc2mac_a_dat_payload.data[idx_db].to_int()));
                             }
-                            cslDebug((90, "\n"));
+                            //cslDebug((90, "\n"));
 #endif
                             sc2mac_a_dat_b_transport (&sc2mac_a_dat_payload, b_transport_delay_);
                             sc2mac_b_dat_b_transport (&sc2mac_a_dat_payload, b_transport_delay_);
                             if (sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end && sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end) {
                                 cacc_free_entry_num_ -= current_stripe_length_per_batch * batch_num* atom_ratio_cacc_to_csc;
-                                cslDebug((50, "Updated credit: cacc_free_entry_num_=%lx\n", cacc_free_entry_num_));
+                                //cslDebug((50, "Updated credit: cacc_free_entry_num_=%lx\n", cacc_free_entry_num_));
                             }
 
                             if ( 1 == sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st ) {
@@ -1080,7 +1080,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
         channel_operation_num = evaluate_channel_operation_num(cube_out_width * cube_out_height, ideal_stripe_length);
         out_line_num          = 1;
     }
-    cslDebug((30, "cripple_channel_num=%d\n", cripple_channel_num));
+    //cslDebug((30, "cripple_channel_num=%d\n", cripple_channel_num));
     comp_released_wt_entries = 0;
     comp_released_wmb_entries = 0;
     for (kernel_group_iter=0; kernel_group_iter < kernel_group_num; kernel_group_iter++) {
@@ -1090,8 +1090,8 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
         } else {
             kernel_per_group = kernel_per_group_ideal;
         }
-        cslDebug((30, "kernel_group_iter=%d current kernel_per_group=%d\n", kernel_group_iter, kernel_per_group));
-        cslDebug((50, "WaitUntilThereAreEnoughKernel start\n"));
+        //cslDebug((30, "kernel_group_iter=%d current kernel_per_group=%d\n", kernel_group_iter, kernel_per_group));
+        //cslDebug((50, "WaitUntilThereAreEnoughKernel start\n"));
         // Wait the next Kernel Group is fetched into cbuf
         if (is_skip_weight_rls_mode) {  // Not release weight
             // Count from the beginning of the entire weight
@@ -1100,11 +1100,11 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
             // Count from the beginning of the current Kernel Group
             WaitUntilThereAreEnoughKernel(kernel_per_group);
         }
-        cslDebug((50, "WaitUntilThereAreEnoughKernel end\n"));
+        //cslDebug((50, "WaitUntilThereAreEnoughKernel end\n"));
 
         for (out_line_iter=0; out_line_iter < out_line_num; out_line_iter++) { // Loop on lines of output cube
             for (channel_operation_iter=0; channel_operation_iter < channel_operation_num; channel_operation_iter++) {
-                cslDebug((30, "channel_operation_iter=%d\n", channel_operation_iter));
+                //cslDebug((30, "channel_operation_iter=%d\n", channel_operation_iter));
                 if (NVDLA_CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED==weight_format) {
                     comp_updated_wt_entry_num = 0;
                     comp_updated_wmb_entry_num = 0;
@@ -1123,16 +1123,16 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                         if (128==wt_payload_available)
                             FAIL(("The weight data in comp_entry_wt should be used by prev kernel group\n"));
                         int i;
-                        cslDebug((70, "After restore: wt_payload_available=%d next_wt_idx=%d next_wmb_idx=%d\n", wt_payload_available, next_wt_idx, next_wmb_idx));
-                        cslDebug((70, "comp_entry_wt:\n"));
-                        for(i=0;i<CBUF_ENTRY_SIZE/8;i++)
-                            cslDebug((70, "0x%016lx ", comp_entry_wt[i]));
-                        cslDebug((70, "\n"));
-
-                        cslDebug((70, "comp_entry_wmb:\n"));
-                        for(i=0;i<CBUF_ENTRY_SIZE;i++)
-                            cslDebug((70, "0x%02x ", comp_entry_wmb[i]));
-                        cslDebug((70, "\n"));
+                        //cslDebug((70, "After restore: wt_payload_available=%d next_wt_idx=%d next_wmb_idx=%d\n", wt_payload_available, next_wt_idx, next_wmb_idx));
+                        //cslDebug((70, "comp_entry_wt:\n"));
+                        //for(i=0;i<CBUF_ENTRY_SIZE/8;i++)
+                            //cslDebug((70, "0x%016lx ", comp_entry_wt[i]));
+                        //cslDebug((70, "\n"));
+
+                        //cslDebug((70, "comp_entry_wmb:\n"));
+                        //for(i=0;i<CBUF_ENTRY_SIZE;i++)
+                            //cslDebug((70, "0x%02x ", comp_entry_wmb[i]));
+                        //cslDebug((70, "\n"));
                     }
                     // For each channel op in one kernel group, restart from the start of the kernel group
                     // cbuf_wt_entry_addr is used only for weight compression mode
@@ -1143,9 +1143,9 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                     memcpy(read_data_curr_ptr, kg_wt_first_entry_buffer, CBUF_ENTRY_SIZE);
                 }
                 for (block_operation_iter=0; block_operation_iter < block_per_channel_num; block_operation_iter ++) {
-                    cslDebug((30, "block_operation_iter=%d\n", block_operation_iter));
+                    //cslDebug((30, "block_operation_iter=%d\n", block_operation_iter));
                     for (stripe_operation_iter=0; stripe_operation_iter<stripe_operation_per_block_operation; stripe_operation_iter++) {
-                        cslDebug((30, "stripe_operation_iter=%d\n", stripe_operation_iter));
+                        //cslDebug((30, "stripe_operation_iter=%d\n", stripe_operation_iter));
                         last_stripe_operation = stripe_operation_iter == (stripe_operation_per_block_operation-1);
                         if (post_y_extension>1) {
                             if(block_operation_iter>0)
@@ -1174,7 +1174,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                         }
                         WaitStripeBeginHasSent();   //Wait until the previous stripe has been sent to mac. Then load the next batch of kernels into shadow.
                         for (kernel_iter=0; kernel_iter<kernel_per_group; kernel_iter++) {
-                            cslDebug((30, "kernel_iter=%d\n", kernel_iter));
+                            //cslDebug((30, "kernel_iter=%d\n", kernel_iter));
                             kernel_atom_size_index = (weight_layer_start_byte_idx_
                                     + kernel_iter * current_super_atom_size
                                     + stripe_operation_iter * stripe_operation_stride
@@ -1182,23 +1182,23 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                                     + kernel_group_iter     * kernel_group_stride) % (cbuf_entry_for_weight*CBUF_ENTRY_SIZE);
                             cbuf_entry_addr = cbuf_entry_for_data + kernel_atom_size_index/CBUF_ENTRY_SIZE;
                             begin_byte_within_one_entry = kernel_atom_size_index % CBUF_ENTRY_SIZE;
-                            cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon, iterator values:\n"));
-                            cslDebug((50, "    kernel_group_iter          is %d\n", kernel_group_iter));
-                            cslDebug((50, "    out_line_iter              is %d\n", out_line_iter));
-                            cslDebug((50, "    channel_operation_iter     is %d\n", channel_operation_iter));
-                            cslDebug((50, "    block_operation_iter       is %d\n", block_operation_iter));
-                            cslDebug((50, "    stripe_operation_iter      is %d\n", stripe_operation_iter));
-                            cslDebug((50, "    kernel_iter                is %d\n", kernel_iter));
-                            cslDebug((50, "    kernel_atom_size_index     is 0x%lx\n", kernel_atom_size_index));
-                            cslDebug((50, "    begin_byte_within_one_entry is 0x%x\n", begin_byte_within_one_entry));
-                            cslDebug((50, "    cbuf_entry_addr            is 0x%x\n", cbuf_entry_addr));
+                            //cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon, iterator values:\n"));
+                            //cslDebug((50, "    kernel_group_iter          is %d\n", kernel_group_iter));
+                            //cslDebug((50, "    out_line_iter              is %d\n", out_line_iter));
+                            //cslDebug((50, "    channel_operation_iter     is %d\n", channel_operation_iter));
+                            //cslDebug((50, "    block_operation_iter       is %d\n", block_operation_iter));
+                            //cslDebug((50, "    stripe_operation_iter      is %d\n", stripe_operation_iter));
+                            //cslDebug((50, "    kernel_iter                is %d\n", kernel_iter));
+                            //cslDebug((50, "    kernel_atom_size_index     is 0x%lx\n", kernel_atom_size_index));
+                            //cslDebug((50, "    begin_byte_within_one_entry is 0x%x\n", begin_byte_within_one_entry));
+                            //cslDebug((50, "    cbuf_entry_addr            is 0x%x\n", cbuf_entry_addr));
                             if (NVDLA_CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED==weight_format) {
                                 get_decompressed_weight(read_data_curr_ptr, input_atom_channel_num);    // For INT8, read_data_curr_ptr is different in compress and non-compress modes
                                 // Prepare CSC2MAC weight payload, from C0 to C64, C0 is aligned with 0
                                 if (DATA_FORMAT_INT8 == precision) {    // sc2mac_a_wt_payload.data[0] is sc_int<8>
                                     for (sc2mac_element_iter=ELEMENT_PER_INPUT_ATOM*(kernel_iter%2); sc2mac_element_iter< ELEMENT_PER_INPUT_ATOM*(kernel_iter%2) + input_atom_channel_num; sc2mac_element_iter++) {
                                         sc2mac_a_wt_payload.data[sc2mac_element_iter] = read_data_curr_ptr[sc2mac_element_iter - ELEMENT_PER_INPUT_ATOM*(kernel_iter%2)];
-//                                        cslDebug((70, "kernel_iter=%d sc2mac_element_iter=%d read_data_curr_ptr[]=0x%x sc2mac_a_wt_payload.data[]=0x%x\n", kernel_iter, sc2mac_element_iter, read_data_curr_ptr[sc2mac_element_iter - ELEMENT_PER_INPUT_ATOM*(kernel_iter%2)], sc2mac_a_wt_payload.data[sc2mac_element_iter].to_int()));
+//                                        //cslDebug((70, "kernel_iter=%d sc2mac_element_iter=%d read_data_curr_ptr[]=0x%x sc2mac_a_wt_payload.data[]=0x%x\n", kernel_iter, sc2mac_element_iter, read_data_curr_ptr[sc2mac_element_iter - ELEMENT_PER_INPUT_ATOM*(kernel_iter%2)], sc2mac_a_wt_payload.data[sc2mac_element_iter].to_int()));
                                     }
                                 } else {
                                     // Int16 or FP16, each element size is 2 byte
@@ -1213,7 +1213,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                                 // There is no usable data in read_data_curr_ptr
                                 // Read new line in cbuf
                                 sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr = cbuf_entry_addr;
-                                cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon, begin byte address is aligned with entry size.  sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr));
+                                //cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon, begin byte address is aligned with entry size.  sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr));
                                 // Send CBUF read request. Read one cbuf entry(128B)
                                 sc2buf_wt_rd_b_transport(&sc2buf_wt_rd_payload, b_transport_delay_);
                                 updated_entry_num ++;
@@ -1243,7 +1243,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                                 else
                                     cbuf_entry_addr ++;
                                 sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr = cbuf_entry_addr;
-                                cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon, begin byte address is not aligned with entry size.  sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr));
+                                //cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon, begin byte address is not aligned with entry size.  sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr));
                                 // Send CBUF read request
                                 sc2buf_wt_rd_b_transport(&sc2buf_wt_rd_payload, b_transport_delay_);
                                 updated_entry_num ++;
@@ -1281,7 +1281,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                             } else {
                                 // All required Data for current kernel are already in read_data_curr_ptr   (e.g. int8 or the current_super_atom_size is less than 128)
                                 // Get data from curr
-                                cslDebug((50, "(begin_byte_within_one_entry != 0) && (begin_byte_within_one_entry+current_super_atom_size <= CBUF_ENTRY_SIZE)\n"));
+                                //cslDebug((50, "(begin_byte_within_one_entry != 0) && (begin_byte_within_one_entry+current_super_atom_size <= CBUF_ENTRY_SIZE)\n"));
                                 prev_read_size = CBUF_ENTRY_SIZE - begin_byte_within_one_entry;
                                 curr_byte_size = current_super_atom_size - prev_read_size;
                                 for (byte_iter=0;byte_iter<current_super_atom_size;byte_iter++) {
@@ -1309,7 +1309,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                             }
 #if 0
                             for (uint32_t idx_db=0; idx_db<128; idx_db ++) {
-                                cslDebug((70, "    payload_data_tmp[%d]: 0x%02x\n", idx_db, (uint8_t)payload_data_tmp[idx_db]));
+                                //cslDebug((70, "    payload_data_tmp[%d]: 0x%02x\n", idx_db, (uint8_t)payload_data_tmp[idx_db]));
                             }
 #endif
                             if (post_y_extension==1) {
@@ -1406,7 +1406,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                             }
 #if 0
                             for (uint32_t idx_db=0; idx_db<128; idx_db ++) {
-                                cslDebug((70, "    XXXXXXX Weight[%d]: 0x%02x\n", idx_db, (uint8_t)sc2mac_a_wt_payload.data[idx_db].to_int()));
+                                //cslDebug((70, "    XXXXXXX Weight[%d]: 0x%02x\n", idx_db, (uint8_t)sc2mac_a_wt_payload.data[idx_db].to_int()));
                             }
 #endif
                             // Send weight to CMAC
@@ -1416,7 +1416,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                                 // Int8, send weight in kernel pairs
                                 if ((1 == kernel_iter%2) || (kernel_iter == kernel_per_group - 1)) {
                                     if ((0==(kernel_iter%2)) && (kernel_iter == kernel_per_group - 1)) {
-                                        cslDebug((30, "Last kernel of kernels, the total number of kernel is odd. kernel_iter=%d\n", kernel_iter));
+                                        //cslDebug((30, "Last kernel of kernels, the total number of kernel is odd. kernel_iter=%d\n", kernel_iter));
                                         // In INT8 case, two kernels shares one MAC cell, if kernel_per_group is a odd number, fill zero to the 2nd kernel (64Bytes)
                                         for (sc2mac_element_iter=ELEMENT_PER_INPUT_ATOM; sc2mac_element_iter< ELEMENT_PER_INPUT_ATOM*2; sc2mac_element_iter++) {
                                             sc2mac_a_wt_payload.data[sc2mac_element_iter] = 0;
@@ -1431,16 +1431,16 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                                     }
                                     sc2mac_a_wt_payload.sel = 0x1 << (kernel_iter/2);
                                     if ((sc2mac_a_wt_payload.sel&0xFF)) {
-                                        cslDebug((70, "sc2mac_a_wt_payload (part a) is\n"));
+                                        //cslDebug((70, "sc2mac_a_wt_payload (part a) is\n"));
                                     } else { //if ((sc2mac_a_wt_payload.sel>>8) & 0xFF)  {
-                                        cslDebug((70, "sc2mac_a_wt_payload (part b) is\n"));
+                                        //cslDebug((70, "sc2mac_a_wt_payload (part b) is\n"));
                                     }
-                                    cslDebug((50, "    mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[0]));
-                                    cslDebug((50, "    mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[1]));
-                                    cslDebug((70, "    sel is 0x%x\n", sc2mac_a_wt_payload.sel));
+                                    //cslDebug((50, "    mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[0]));
+                                    //cslDebug((50, "    mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[1]));
+                                    //cslDebug((70, "    sel is 0x%x\n", sc2mac_a_wt_payload.sel));
 #if LOG_DETAIL
                                     for (uint32_t idx_db=0; idx_db<128; idx_db ++) {
-                                        cslDebug((90, "    Weight[%d]: 0x%02x\n", idx_db, (uint8_t)sc2mac_a_wt_payload.data[idx_db].to_int()));
+                                        //cslDebug((90, "    Weight[%d]: 0x%02x\n", idx_db, (uint8_t)sc2mac_a_wt_payload.data[idx_db].to_int()));
                                     }
 #endif
                                     if ((sc2mac_a_wt_payload.sel&0xFF)) {
@@ -1465,16 +1465,16 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                                 }
                                 sc2mac_a_wt_payload.sel = 0x1 << kernel_iter;
                                 if ((sc2mac_a_wt_payload.sel&0xFF)) {
-                                    cslDebug((70, "sc2mac_a_wt_payload (part a) is\n"));
+                                    //cslDebug((70, "sc2mac_a_wt_payload (part a) is\n"));
                                 } else if ((sc2mac_a_wt_payload.sel>>8) & 0xFF)  {
-                                    cslDebug((70, "sc2mac_a_wt_payload (part b) is\n"));
+                                    //cslDebug((70, "sc2mac_a_wt_payload (part b) is\n"));
                                 }
-                                cslDebug((50, "    mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[0]));
-                                cslDebug((50, "    mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[1]));
-                                cslDebug((70, "    sel is 0x%x\n", sc2mac_a_wt_payload.sel));
+                                //cslDebug((50, "    mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[0]));
+                                //cslDebug((50, "    mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[1]));
+                                //cslDebug((70, "    sel is 0x%x\n", sc2mac_a_wt_payload.sel));
 #if LOG_DETAIL
                                 for (uint32_t idx_db=0; idx_db<128; idx_db ++) {
-                                    cslDebug((90, "    Weight[%d]: 0x%02x\n", idx_db, (uint8_t)(sc2mac_a_wt_payload.data[idx_db].to_int())));
+                                    //cslDebug((90, "    Weight[%d]: 0x%02x\n", idx_db, (uint8_t)(sc2mac_a_wt_payload.data[idx_db].to_int())));
                                 }
 #endif
                                 if ((sc2mac_a_wt_payload.sel&0xFF)) {
@@ -1488,13 +1488,13 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                         // Notify data thread that a kernel group is ready
                         kernel_switch_round_weight_ ++;
                         kernel_switch_updated_.notify();
-                        cslDebug((30, "end of stripe_operation_iter=%d\n", stripe_operation_iter));
+                        //cslDebug((30, "end of stripe_operation_iter=%d\n", stripe_operation_iter));
                     }
-                    cslDebug((30, "end of block_operation_iter=%d\n", block_operation_iter));
+                    //cslDebug((30, "end of block_operation_iter=%d\n", block_operation_iter));
                 }
-                cslDebug((30, "end of channel_operation_iter=%d\n", channel_operation_iter));
+                //cslDebug((30, "end of channel_operation_iter=%d\n", channel_operation_iter));
             }
-            cslDebug((30, "end of out_line_iter=%d\n", out_line_iter));
+            //cslDebug((30, "end of out_line_iter=%d\n", out_line_iter));
         }
         // End of a kernel group
 
@@ -1504,7 +1504,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                 wt_up_sc2cdma_payload.wt_entries = total_wt_entries - comp_released_wt_entries;
                 weight_entry_idx_start_ += total_wt_entries - comp_released_wt_entries;
                 if (total_wt_entries - comp_released_wt_entries != comp_updated_wt_entry_num) {
-                    cslInfo(("total_wt_entries=0x%x comp_released_wt_entries=0x%x comp_updated_wt_entry_num=0x%x\n", total_wt_entries, comp_released_wt_entries, comp_updated_wt_entry_num));
+                    //cslInfo(("total_wt_entries=0x%x comp_released_wt_entries=0x%x comp_updated_wt_entry_num=0x%x\n", total_wt_entries, comp_released_wt_entries, comp_updated_wt_entry_num));
                     FAIL(("In the end of last kernel group in weight compression mode, the wt entry num used should be same as available wt entries\n"));
                 }
 
@@ -1512,7 +1512,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
                 wt_up_sc2cdma_payload.wmb_entries = total_wmb_entries - comp_released_wmb_entries;
                 wmb_entry_idx_start_ += total_wmb_entries - comp_released_wmb_entries;
                 if (total_wmb_entries - comp_released_wmb_entries != comp_updated_wmb_entry_num) {
-                    cslInfo(("total_wmb_entries=0x%x comp_released_wmb_entries=0x%x comp_updated_wmb_entry_num=0x%x\n", total_wmb_entries, comp_released_wmb_entries, comp_updated_wmb_entry_num));
+                    //cslInfo(("total_wmb_entries=0x%x comp_released_wmb_entries=0x%x comp_updated_wmb_entry_num=0x%x\n", total_wmb_entries, comp_released_wmb_entries, comp_updated_wmb_entry_num));
                     FAIL(("In the end of last kernel group in weight compression mode, the wmb entry num used should be same as available wmb entries\n"));
                 }
             } else {
@@ -1532,7 +1532,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
             weight_kernel_num_used_ += kernel_per_group;
             wt_up_sc2cdma_payload.wt_kernels = kernel_per_group;
             wt_up_sc2cdma_b_transport(&wt_up_sc2cdma_payload, b_transport_delay_);
-            cslInfo(("after wt_up_sc2cdma_b_transport.    wt_kernels = 0x%x\ wt_entries=0x%x wmb_entries=0x%x\n", wt_up_sc2cdma_payload.wt_kernels, wt_up_sc2cdma_payload.wt_entries, wt_up_sc2cdma_payload.wmb_entries));
+            //cslInfo(("after wt_up_sc2cdma_b_transport.    wt_kernels = 0x%x\ wt_entries=0x%x wmb_entries=0x%x\n", wt_up_sc2cdma_payload.wt_kernels, wt_up_sc2cdma_payload.wt_entries, wt_up_sc2cdma_payload.wmb_entries));
         }
         if (NVDLA_CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED==weight_format) {
             save_info_kernel_group();
@@ -1540,7 +1540,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerDirectConvCommon() {
             // Copy left valid data in read_data_curr_ptr to a backup buffer
             memcpy(kg_wt_first_entry_buffer, read_data_curr_ptr, CBUF_ENTRY_SIZE);
         }
-        cslDebug((30, "end of kernel_group_iter=%d\n", kernel_group_iter));
+        //cslDebug((30, "end of kernel_group_iter=%d\n", kernel_group_iter));
     }
     // End of layer
     // TODO: assert on weight_entry_idx_start_ to be the end of current layer
@@ -1602,7 +1602,7 @@ void NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon() {
     uint8_t  read_data_ptr_tmp[CBUF_ENTRY_SIZE];
     uint8_t  read_data_ptr_tmp0[CBUF_ENTRY_SIZE], read_data_ptr_tmp1[CBUF_ENTRY_SIZE], read_data_ptr_tmp2[CBUF_ENTRY_SIZE], read_data_ptr_tmp3[CBUF_ENTRY_SIZE];
     uint64_t *read_data_ptr_tmp_64;
-    cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, start\n"));
+    //cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, start\n"));
     read_data_ptr   = new sc_uint<64> [CBUF_ENTRY_SIZE/8];
 
     // Copy from register value to local config variables, similar with RTL connection
@@ -1658,7 +1658,7 @@ void NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon() {
     // For Image-in, batch mode is not supported
     sc2mac_a_dat_payload.pd.nvdla_stripe_info.batch_index = 0;
     required_slice_num = cube_in_height;
-    cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput, wait cbuffer.\n"));
+    //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerDirectConvCommon, WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput, wait cbuffer.\n"));
     WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput(required_slice_num*cbuf_entry_per_line);
 
     // Compute last stripe length of each line
@@ -1666,9 +1666,9 @@ void NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon() {
     // Compute stripe number of each line
     stripe_num = (cube_out_width - last_stripe_length)/ideal_stripe_length + 1;
 
-    cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon, out_surface_num is: 0x%x\n", out_surface_num));
-    cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon, stripe_num in one line is: 0x%x\n", stripe_num));
-    cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon, last_super_channel_element_num is: 0x%x\n", last_super_channel_element_num));
+    //cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon, out_surface_num is: 0x%x\n", out_surface_num));
+    //cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon, stripe_num in one line is: 0x%x\n", stripe_num));
+    //cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon, last_super_channel_element_num is: 0x%x\n", last_super_channel_element_num));
 
     // each out_surface (a channel of output cube) corresponds to a group(number of 16) of kernels
     for (out_surface_iter  = 0; out_surface_iter<out_surface_num; out_surface_iter ++) {
@@ -1691,9 +1691,9 @@ void NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon() {
                             // Notify CMAC needs to reload weight
                             if (output_atom_iter == output_atom_sent_num) { //The 1st atom of the stripe
                                 sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st = 1;
-                                cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerDirectConvCommon, before WaitUntilKernelsAreReady.\n"));
+                                //cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerDirectConvCommon, before WaitUntilKernelsAreReady.\n"));
                                 WaitUntilKernelsAreReady(); //Kernels should be loaded into shadow before featue data
-                                cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerDirectConvCommon, a group of weight for a stripe operation was ready.\n"));
+                                //cslDebug((50, "NV_NVDLA_csc::SendImageDataToMacSequencerDirectConvCommon, a group of weight for a stripe operation was ready.\n"));
                             } else {
                                 sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st = 0;
                             }
@@ -1708,7 +1708,7 @@ void NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon() {
                             // All channels done, notify CACC current data is the last partial sum, CACCU could send out data. The condition (sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end == 1) is not required.
                             if ((kernel_atom_iter == kernel_atom_num-1) && last_super_channel) { //The last stripe of the last block operation
                                 sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end = 1;
-                                cslDebug((30, "NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon, got a channel_end, out_surface_iter is 0x%x, out_surface_num is 0x%x, stripe_iter is 0x%x, stripe_num is 0x%x\n", out_surface_iter, out_surface_num, stripe_iter, stripe_num));
+                                //cslDebug((30, "NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon, got a channel_end, out_surface_iter is 0x%x, out_surface_num is 0x%x, stripe_iter is 0x%x, stripe_num is 0x%x\n", out_surface_iter, out_surface_num, stripe_iter, stripe_num));
                                 if ( (out_surface_iter==out_surface_num-1) && (out_line_iter==cube_out_height-1) && (stripe_iter==stripe_num-1) ) {    //The last atom of the input cube
                                     // Layer done, notify CACC set the hardware layer done bit
                                     sc2mac_a_dat_payload.pd.nvdla_stripe_info.layer_end = 1;
@@ -1727,18 +1727,18 @@ void NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon() {
                             // Here input_atom_coor_width is actually the coordicate in channel direction. The real input_atom_coor_width is always 0 since the width of input cube is 1(after pre-extension).
                             input_atom_coor_width  = output_atom_coor_width * (kernel_stride_w * cube_in_channel) + super_channel_iter * PARALLEL_CHANNEL_NUM;
                             input_atom_coor_height = output_atom_coor_height * kernel_stride_h + kernel_atom_coor_height * post_y_extension - pad_top;
-                            cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerImageConvCommon, sc2buf_dat_rd_b_transport\n"));
-                            cslDebug((50, "    out_surface_iter           is %d\n", out_surface_iter));
-                            cslDebug((50, "    out_line_iter              is %d\n", out_line_iter));
-                            cslDebug((50, "    stripe_iter                is %d\n", stripe_iter));
-                            cslDebug((50, "    super_channel_iter         is %d\n", super_channel_iter));
-                            cslDebug((50, "    kernel_atom_iter           is %d\n", kernel_atom_iter));
-                            cslDebug((50, "    output_atom_iter           is %d\n", output_atom_iter));
-                            cslDebug((50, "    current_stripe_length      is %d\n", current_stripe_length));
-                            cslDebug((50, "    output_atom_coor_width     is %d\n", output_atom_coor_width));
-                            cslDebug((50, "    output_atom_coor_height    is %d\n", output_atom_coor_height));
-                            cslDebug((50, "    input_atom_coor_width      is %d\n", input_atom_coor_width));
-                            cslDebug((50, "    input_atom_coor_height     is %d\n", input_atom_coor_height));
+                            //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerImageConvCommon, sc2buf_dat_rd_b_transport\n"));
+                            //cslDebug((50, "    out_surface_iter           is %d\n", out_surface_iter));
+                            //cslDebug((50, "    out_line_iter              is %d\n", out_line_iter));
+                            //cslDebug((50, "    stripe_iter                is %d\n", stripe_iter));
+                            //cslDebug((50, "    super_channel_iter         is %d\n", super_channel_iter));
+                            //cslDebug((50, "    kernel_atom_iter           is %d\n", kernel_atom_iter));
+                            //cslDebug((50, "    output_atom_iter           is %d\n", output_atom_iter));
+                            //cslDebug((50, "    current_stripe_length      is %d\n", current_stripe_length));
+                            //cslDebug((50, "    output_atom_coor_width     is %d\n", output_atom_coor_width));
+                            //cslDebug((50, "    output_atom_coor_height    is %d\n", output_atom_coor_height));
+                            //cslDebug((50, "    input_atom_coor_width      is %d\n", input_atom_coor_width));
+                            //cslDebug((50, "    input_atom_coor_height     is %d\n", input_atom_coor_height));
 
                             if (post_y_extension == 1)
                                 csc_read_one_image_entry(post_y_extension, 0, input_atom_coor_width, input_atom_coor_height, cbuf_entry_per_line, element_size, last_super_channel, last_super_channel_element_num, cube_in_height, cube_in_channel, &read_data_ptr_tmp[0]);
@@ -1799,7 +1799,7 @@ void NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon() {
                             switch (precision) {
                                 case DATA_FORMAT_INT8:
                                     for (channel_iter=0; channel_iter < PARALLEL_CHANNEL_NUM; channel_iter++) {
-//                                        cslDebug((70, "channel_iter=%d data=0x%x\n", channel_iter, (uint64_t)read_data_ptr[channel_iter/4]));
+//                                        //cslDebug((70, "channel_iter=%d data=0x%x\n", channel_iter, (uint64_t)read_data_ptr[channel_iter/4]));
                                         sc2mac_a_dat_payload.data[channel_iter] = read_data_ptr[channel_iter/8].range((channel_iter%8)*8+7, (channel_iter%8)*8);
                                         sc2mac_a_dat_payload.data[channel_iter+PARALLEL_CHANNEL_NUM] = sc2mac_a_dat_payload.data[channel_iter];
                                     }
@@ -1854,23 +1854,23 @@ void NV_NVDLA_csc::SendImageDataToMacSequencerConvCommon() {
                                 default:
                                     break;
                             }
-                            cslDebug((50, "sc2mac_a_dat_payload: stripe_st=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st));
-                            cslDebug((50, " stripe_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end));
-                            cslDebug((50, " channel_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end));
-                            cslDebug((50, " layer_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.layer_end));
-                            cslDebug((50, " mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_dat_payload.mask[0]));
-                            cslDebug((50, " mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_dat_payload.mask[1]));
+                            //cslDebug((50, "sc2mac_a_dat_payload: stripe_st=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st));
+                            //cslDebug((50, " stripe_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end));
+                            //cslDebug((50, " channel_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end));
+                            //cslDebug((50, " layer_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.layer_end));
+                            //cslDebug((50, " mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_dat_payload.mask[0]));
+                            //cslDebug((50, " mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_dat_payload.mask[1]));
 #if LOG_DETAIL
                             for (uint32_t idx_db=0; idx_db<128; idx_db++) {
-                                cslDebug((90, "    Data[%d]: 0x%x\n", idx_db, sc2mac_a_dat_payload.data[idx_db].to_int()));
+                                //cslDebug((90, "    Data[%d]: 0x%x\n", idx_db, sc2mac_a_dat_payload.data[idx_db].to_int()));
                             }
-                            cslDebug((90, "\n"));
+                            //cslDebug((90, "\n"));
 #endif
                             sc2mac_a_dat_b_transport (&sc2mac_a_dat_payload, b_transport_delay_);
                             sc2mac_b_dat_b_transport (&sc2mac_a_dat_payload, b_transport_delay_);
                             if (sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end && sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end) {
                                 cacc_free_entry_num_ -= current_stripe_length * atom_ratio_cacc_to_csc;
-                                cslDebug((50, "Updated credit: cacc_free_entry_num_=%lx\n", cacc_free_entry_num_));
+                                //cslDebug((50, "Updated credit: cacc_free_entry_num_=%lx\n", cacc_free_entry_num_));
                             }
 
                             if ( 1 == sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st ) {
@@ -1940,7 +1940,7 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
     uint8_t map_out_seq_x[4] = {0, 0, 1, 1};
     uint8_t map_out_seq_y[4] = {0, 1, 0, 1};
     uint32_t trans_id = 0;
-    cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, start\n"));
+    //cslInfo(("NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, start\n"));
     // CBUF read request payload sc2buf_dat_rd_nvdla_ram_addr_ADDR_WIDTH_12_BE_1_payload
 
     // Copy from register value to local config variables, similar with RTL connection
@@ -2016,7 +2016,7 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
     // For looping
     sc2mac_a_dat_payload.pd.nvdla_stripe_info.batch_index = 0;
     required_slice_num = cube_in_4x4_height;
-    cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput, wait cbuffer.\n"));
+    //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput, wait cbuffer.\n"));
     WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput(required_slice_num*cbuf_entry_per_slice);
 
     // each out_surface (a channel of output cube) corresponds to a group(number of 16) of kernels
@@ -2024,7 +2024,7 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
         for (stripe_iter=0; stripe_iter < stripe_num; stripe_iter++){ // Each loop is a channel operation which contains a stripe of ouput atoms
             output_2x2_sent_num = stripe_iter * ideal_stripe_length;
             current_stripe_length = (stripe_iter<(stripe_num-1))? ideal_stripe_length: last_stripe_length;
-            cslDebug((50, "%s: stripe_iter:%d, current_stripe_length:%d\n", __FUNCTION__, stripe_iter, current_stripe_length));
+            //cslDebug((50, "%s: stripe_iter:%d, current_stripe_length:%d\n", __FUNCTION__, stripe_iter, current_stripe_length));
             WaitUntilThereIsEnoughSpaceInCaccu(current_stripe_length*atom_ratio_cacc_to_csc);
             for (super_channel_iter=0; super_channel_iter < super_channel_num; super_channel_iter++) { // Loop in Channel direction of Input Cube
                 // Each block operation contains only one strip operation
@@ -2032,9 +2032,9 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
                     // Notify CMAC needs to reload weight
                     if (output_2x2_iter == output_2x2_sent_num) { //The 1st atom of the stripe
                         sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st = 1;
-                        cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, before WaitUntilKernelsAreReady.\n"));
+                        //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, before WaitUntilKernelsAreReady.\n"));
                         WaitUntilKernelsAreReady(); //Kernels should be loaded into shadow before featue data
-                        cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, a group of weight for a stripe operation was ready.\n"));
+                        //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, a group of weight for a stripe operation was ready.\n"));
                     } else {
                         sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st = 0;
                     }
@@ -2065,27 +2065,27 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
                     output_2x2_coor_height= (output_4x4_int/(cube_out_2x2_width/2))*2 + (map_out_seq_y[output_4x4_frac]);
                     input_4x4_coor_width  = output_2x2_coor_width * 2;  // conv_stride must be 0 here as the stride already channel extended
                     input_4x4_coor_height = output_2x2_coor_height * 2;
-                    cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, sc2buf_dat_rd_b_transport\n"));
-                    cslDebug((50, "    out_surface_iter           is %d\n", out_surface_iter));
-                    cslDebug((50, "    stripe_iter                is %d\n", stripe_iter));
-                    cslDebug((50, "    super_channel_iter         is %d\n", super_channel_iter));
-                    cslDebug((50, "    output_2x2_coor_width      is %d\n", output_2x2_coor_width));
-                    cslDebug((50, "    output_2x2_coor_height     is %d\n", output_2x2_coor_height));
-                    cslDebug((50, "    input_4x4_coor_width       is %d\n", input_4x4_coor_width));
-                    cslDebug((50, "    input_4x4_coor_height      is %d\n", input_4x4_coor_height));
+                    //cslDebug((50, "NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon, sc2buf_dat_rd_b_transport\n"));
+                    //cslDebug((50, "    out_surface_iter           is %d\n", out_surface_iter));
+                    //cslDebug((50, "    stripe_iter                is %d\n", stripe_iter));
+                    //cslDebug((50, "    super_channel_iter         is %d\n", super_channel_iter));
+                    //cslDebug((50, "    output_2x2_coor_width      is %d\n", output_2x2_coor_width));
+                    //cslDebug((50, "    output_2x2_coor_height     is %d\n", output_2x2_coor_height));
+                    //cslDebug((50, "    input_4x4_coor_width       is %d\n", input_4x4_coor_width));
+                    //cslDebug((50, "    input_4x4_coor_height      is %d\n", input_4x4_coor_height));
                     if (((input_4x4_coor_width%4)==0) && ((input_4x4_coor_height%4)==0)) {
                         cbuf_entry_addr_0 = (data_entry_idx_free_ + input_4x4_coor_height/4 * cbuf_entry_per_slice + (super_channel_iter/super_channel_ratio)*cube_in_4x4_width + input_4x4_coor_width/4)%cbuf_entry_for_data;
-                        cslDebug((50, "    cbuf_entry_addr_0          is %d\n", cbuf_entry_addr_0));
+                        //cslDebug((50, "    cbuf_entry_addr_0          is %d\n", cbuf_entry_addr_0));
                         read_cbuf_entry(cbuf_entry_addr_0, read_data_ptr);
                     }
 #pragma CTC SKIP
                     else if (((input_4x4_coor_width%4)==0) && ((input_4x4_coor_height%4)!=0)) {
 #pragma CTC ENDSKIP
                         cbuf_entry_addr_0 = (data_entry_idx_free_ + input_4x4_coor_height/4 * cbuf_entry_per_slice + (super_channel_iter/super_channel_ratio)*cube_in_4x4_width + input_4x4_coor_width/4)%cbuf_entry_for_data;
-                        cslDebug((50, "    cbuf_entry_addr_0          is %d\n", cbuf_entry_addr_0));
+                        //cslDebug((50, "    cbuf_entry_addr_0          is %d\n", cbuf_entry_addr_0));
                         read_cbuf_entry(cbuf_entry_addr_0, read_data_ptr_0);
                         cbuf_entry_addr_1 = (data_entry_idx_free_ + (input_4x4_coor_height/4+1) * cbuf_entry_per_slice + (super_channel_iter/super_channel_ratio)*cube_in_4x4_width + input_4x4_coor_width/4)%cbuf_entry_for_data;
-                        cslDebug((50, "    cbuf_entry_addr_1          is %d\n", cbuf_entry_addr_1));
+                        //cslDebug((50, "    cbuf_entry_addr_1          is %d\n", cbuf_entry_addr_1));
                         read_cbuf_entry(cbuf_entry_addr_1, read_data_ptr_1);
                         memcpy(read_data_ptr, &read_data_ptr_0[64], 64);
                         memcpy(&read_data_ptr[64], read_data_ptr_1, 64);
@@ -2094,10 +2094,10 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
                     else if (((input_4x4_coor_width%4)!=0) && ((input_4x4_coor_height%4)==0)) {
 #pragma CTC ENDSKIP
                         cbuf_entry_addr_0 = (data_entry_idx_free_ + input_4x4_coor_height/4 * cbuf_entry_per_slice + (super_channel_iter/super_channel_ratio)*cube_in_4x4_width + input_4x4_coor_width/4)%cbuf_entry_for_data;
-                        cslDebug((50, "    cbuf_entry_addr_0          is %d\n", cbuf_entry_addr_0));
+                        //cslDebug((50, "    cbuf_entry_addr_0          is %d\n", cbuf_entry_addr_0));
                         read_cbuf_entry(cbuf_entry_addr_0, read_data_ptr_0);
                         cbuf_entry_addr_1 = (data_entry_idx_free_ + input_4x4_coor_height/4 * cbuf_entry_per_slice + (super_channel_iter/super_channel_ratio)*cube_in_4x4_width + input_4x4_coor_width/4 + 1)%cbuf_entry_for_data;
-                        cslDebug((50, "    cbuf_entry_addr_1          is %d\n", cbuf_entry_addr_1));
+                        //cslDebug((50, "    cbuf_entry_addr_1          is %d\n", cbuf_entry_addr_1));
                         read_cbuf_entry(cbuf_entry_addr_1, read_data_ptr_1);
                         memcpy(read_data_ptr,       &read_data_ptr_0[16],  16);
                         memcpy(&read_data_ptr[32],  &read_data_ptr_0[48],  16);
@@ -2111,16 +2111,16 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
                     else { // ((input_4x4_coor_width%4)!=0) && ((input_4x4_coor_height%4)!=0)
                         // top-left -> left-bottom -> top_right -> bottom_right
                         cbuf_entry_addr_0 = (data_entry_idx_free_ + input_4x4_coor_height/4 * cbuf_entry_per_slice + (super_channel_iter/super_channel_ratio)*cube_in_4x4_width + input_4x4_coor_width/4)%cbuf_entry_for_data;
-                        cslDebug((50, "    cbuf_entry_addr_0          is %d\n", cbuf_entry_addr_0));
+                        //cslDebug((50, "    cbuf_entry_addr_0          is %d\n", cbuf_entry_addr_0));
                         read_cbuf_entry(cbuf_entry_addr_0, read_data_ptr_0);
                         cbuf_entry_addr_1 = (data_entry_idx_free_ + (input_4x4_coor_height/4+1) * cbuf_entry_per_slice + (super_channel_iter/super_channel_ratio)*cube_in_4x4_width + input_4x4_coor_width/4)%cbuf_entry_for_data;
-                        cslDebug((50, "    cbuf_entry_addr_1          is %d\n", cbuf_entry_addr_1));
+                        //cslDebug((50, "    cbuf_entry_addr_1          is %d\n", cbuf_entry_addr_1));
                         read_cbuf_entry(cbuf_entry_addr_1, read_data_ptr_1);
                         cbuf_entry_addr_2 = (data_entry_idx_free_ + input_4x4_coor_height/4 * cbuf_entry_per_slice + (super_channel_iter/super_channel_ratio)*cube_in_4x4_width + input_4x4_coor_width/4 + 1)%cbuf_entry_for_data;
-                        cslDebug((50, "    cbuf_entry_addr_2          is %d\n", cbuf_entry_addr_2));
+                        //cslDebug((50, "    cbuf_entry_addr_2          is %d\n", cbuf_entry_addr_2));
                         read_cbuf_entry(cbuf_entry_addr_2, read_data_ptr_2);
                         cbuf_entry_addr_3 = (data_entry_idx_free_ + (input_4x4_coor_height/4+1) * cbuf_entry_per_slice + (super_channel_iter/super_channel_ratio)*cube_in_4x4_width + input_4x4_coor_width/4 + 1)%cbuf_entry_for_data;
-                        cslDebug((50, "    cbuf_entry_addr_3          is %d\n", cbuf_entry_addr_3));
+                        //cslDebug((50, "    cbuf_entry_addr_3          is %d\n", cbuf_entry_addr_3));
                         read_cbuf_entry(cbuf_entry_addr_3, read_data_ptr_3);
                         memcpy(read_data_ptr,       &read_data_ptr_0[80],  16);
                         memcpy(&read_data_ptr[32],  &read_data_ptr_0[112], 16);
@@ -2132,11 +2132,11 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
                         memcpy(&read_data_ptr[112], &read_data_ptr_3[32],  16);
                     }
 #if ENABLE_PRA_LOG
-                    cslDebug((70, "%s: data before pra remapping:\n", __FUNCTION__));
+                    //cslDebug((70, "%s: data before pra remapping:\n", __FUNCTION__));
                     for(int idx = 127; idx >= 0; idx--) {
-                        cslDebug((70, "%02x", read_data_ptr[idx]));
+                        //cslDebug((70, "%02x", read_data_ptr[idx]));
                     }
-                    cslDebug((70, "\n"));
+                    //cslDebug((70, "\n"));
 #endif
                     // Perform PRA
                     int16_t pra_hls_out[16];
@@ -2155,22 +2155,22 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
                         }
                     }
 #if ENABLE_PRA_LOG
-                    cslDebug((70, "%s: data after pra remapping:\n", __FUNCTION__));
+                    //cslDebug((70, "%s: data after pra remapping:\n", __FUNCTION__));
                     for(int idx = 127; idx >= 0; idx--) {
-                        cslDebug((70, "%02x", ((uint8_t*)pra_hls_in)[idx]));
+                        //cslDebug((70, "%02x", ((uint8_t*)pra_hls_in)[idx]));
                     }
-                    cslDebug((70, "\n"));
+                    //cslDebug((70, "\n"));
 #endif
                     switch (precision) {
                         case DATA_FORMAT_INT8:
                             for (idx_c=0;idx_c<4;idx_c++) {     // In channel direction
                                 csc_pra_hls(&pra_hls_in[idx_c*16] , precision, pra_truncate, pra_hls_out);   // pra_hls_out is 16x16bits
 #if ENABLE_PRA_LOG
-                                cslDebug((70, "%s: data after pra calculate@%d round:\n", __FUNCTION__, idx_c));
+                                //cslDebug((70, "%s: data after pra calculate@%d round:\n", __FUNCTION__, idx_c));
                                 for(int idx = 15; idx >= 0; idx--) {
-                                    cslDebug((70, "%02x", ((uint8_t*)pra_hls_out)[idx]));
+                                    //cslDebug((70, "%02x", ((uint8_t*)pra_hls_out)[idx]));
                                 }
-                                cslDebug((70, "\n"));
+                                //cslDebug((70, "\n"));
 #endif
                                 for (idx=0; idx<16; idx++) {
                                     sc2mac_a_dat_payload.data[idx_c + idx*4] = pra_hls_out[idx] & 0xff;    // Only retrieve the low 8bits
@@ -2183,11 +2183,11 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
                             for (idx_c=0;idx_c<4;idx_c++) {     // In channel direction
                                 csc_pra_hls(&pra_hls_in[16*idx_c], precision, pra_truncate, pra_hls_out);
 #if ENABLE_PRA_LOG
-                                cslDebug((70, "%s: data after pra calculate@%d round:\n", __FUNCTION__, idx_c));
+                                //cslDebug((70, "%s: data after pra calculate@%d round:\n", __FUNCTION__, idx_c));
                                 for(int idx = 15; idx >= 0; idx--) {
-                                    cslDebug((70, "%02x", ((uint8_t*)pra_hls_out)[idx]));
+                                    //cslDebug((70, "%02x", ((uint8_t*)pra_hls_out)[idx]));
                                 }
-                                cslDebug((70, "\n"));
+                                //cslDebug((70, "\n"));
 #endif
 
 //#define WG_CMOD_DEBUG
@@ -2199,19 +2199,19 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
 //      with cc_debug_wt_pra_out.dat dumped from AMOD
 #ifdef WG_CMOD_DEBUG
                                 if (out_surface_iter == 0 && stripe_iter==0 && output_2x2_iter == 0) {
-                                    cslDebug((30, "WG_CMOD_DEBUG: super_channel_iter:%d\n", super_channel_iter)) ;
-                                    cslDebug((70, "WG_CMOD_DEBUG: %s: data before pra calculate@%d round:\n", __FUNCTION__, idx_c));
-                                    cslDebug((70, "wg_cmod_debug_pre_pra: "));
+                                    //cslDebug((30, "WG_CMOD_DEBUG: super_channel_iter:%d\n", super_channel_iter)) ;
+                                    //cslDebug((70, "WG_CMOD_DEBUG: %s: data before pra calculate@%d round:\n", __FUNCTION__, idx_c));
+                                    //cslDebug((70, "wg_cmod_debug_pre_pra: "));
                                     for(int idx = 0; idx < 16; idx++) {
-                                        cslDebug((70, "0x%02x 0x%02x ", ((uint8_t*)pra_hls_in)[idx*2 + idx_c*32], ((uint8_t*)pra_hls_in)[idx*2 + 1 + idx_c*32]));
+                                        //cslDebug((70, "0x%02x 0x%02x ", ((uint8_t*)pra_hls_in)[idx*2 + idx_c*32], ((uint8_t*)pra_hls_in)[idx*2 + 1 + idx_c*32]));
                                     }
-                                    cslDebug((70, "WG_CMOD_DEBUG:\n"));
-                                    cslDebug((70, "WG_CMOD_DEBUG: %s: data after pra calculate@%d round:\n", __FUNCTION__, idx_c));
-                                    cslDebug((70, "wg_cmod_debug_post_pra: "));
+                                    //cslDebug((70, "WG_CMOD_DEBUG:\n"));
+                                    //cslDebug((70, "WG_CMOD_DEBUG: %s: data after pra calculate@%d round:\n", __FUNCTION__, idx_c));
+                                    //cslDebug((70, "wg_cmod_debug_post_pra: "));
                                     for(int idx = 0; idx < 16; idx++) {
-                                        cslDebug((70, "0x%02x 0x%02x ", ((uint8_t*)pra_hls_out)[idx*2], ((uint8_t*)pra_hls_out)[idx*2+1]));
+                                        //cslDebug((70, "0x%02x 0x%02x ", ((uint8_t*)pra_hls_out)[idx*2], ((uint8_t*)pra_hls_out)[idx*2+1]));
                                     }
-                                    cslDebug((70, "WG_CMOD_DEBUG:\n"));
+                                    //cslDebug((70, "WG_CMOD_DEBUG:\n"));
                                 }
 #endif
                                 for (idx=0; idx<16; idx++) {
@@ -2267,18 +2267,18 @@ void NV_NVDLA_csc::SendDataToMacSequencerWinoConvCommon() {
                             break;
 #pragma CTC ENDSKIP
                     }
-                    cslDebug((50, "sc2mac_a_dat_payload(%d): stripe_st=%d\n", trans_id++, (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st));
-                    cslDebug((50, " stripe_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end));
-                    cslDebug((50, " channel_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end));
-                    cslDebug((50, " layer_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.layer_end));
+                    //cslDebug((50, "sc2mac_a_dat_payload(%d): stripe_st=%d\n", trans_id++, (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st));
+                    //cslDebug((50, " stripe_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end));
+                    //cslDebug((50, " channel_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end));
+                    //cslDebug((50, " layer_end=%d\n", (uint32_t)sc2mac_a_dat_payload.pd.nvdla_stripe_info.layer_end));
                     for (uint32_t idx_db=0; idx_db<128; idx_db ++) {
-                        cslDebug((70, "    Data[%d]: 0x%x\n", idx_db, sc2mac_a_dat_payload.data[idx_db].to_int()));
+                        //cslDebug((70, "    Data[%d]: 0x%x\n", idx_db, sc2mac_a_dat_payload.data[idx_db].to_int()));
                     }
                     sc2mac_a_dat_b_transport (&sc2mac_a_dat_payload, b_transport_delay_);
                     sc2mac_b_dat_b_transport (&sc2mac_a_dat_payload, b_transport_delay_);
                     if (sc2mac_a_dat_payload.pd.nvdla_stripe_info.channel_end && sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_end) {
                         cacc_free_entry_num_ -= current_stripe_length * atom_ratio_cacc_to_csc;
-                        cslDebug((50, "Updated credit: cacc_free_entry_num_=%lx\n", cacc_free_entry_num_));
+                        //cslDebug((50, "Updated credit: cacc_free_entry_num_=%lx\n", cacc_free_entry_num_));
                     }
 
                     if ( 1 == sc2mac_a_dat_payload.pd.nvdla_stripe_info.stripe_st ) {
@@ -2373,12 +2373,12 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
 //        FAIL(("weight_bytes%%kernel_num!=0. weight_bytes=0x%X, kernel_num=0x%X\n", weight_bytes, kernel_num));
 
 #pragma CTC SKIP
-    cslDebug((70, "DAIN: WxHxC=%dx%dx%d, DAOUT:WxHxC=%dx%dx%d, SxRxK=%dx%dx%d, weight format:%d, precision:%d, entry4data:%d, entry4wt:%d\n",
-                csc_datain_width_ext_+1, csc_datain_height_ext_+1, csc_datain_channel_ext_+1, 
-                cube_out_width, cube_out_height, csc_dataout_channel_,
-                kernel_width, kernel_height, kernel_num,
-                weight_format, precision,
-                cbuf_entry_for_data, cbuf_entry_for_weight));
+    //cslDebug((70, "DAIN: WxHxC=%dx%dx%d, DAOUT:WxHxC=%dx%dx%d, SxRxK=%dx%dx%d, weight format:%d, precision:%d, entry4data:%d, entry4wt:%d\n",
+    //            csc_datain_width_ext_+1, csc_datain_height_ext_+1, csc_datain_channel_ext_+1,
+    //            cube_out_width, cube_out_height, csc_dataout_channel_,
+    //            kernel_width, kernel_height, kernel_num,
+    //            weight_format, precision,
+    //            cbuf_entry_for_data, cbuf_entry_for_weight));
     assert(kernel_width == 4 && kernel_height == 4);
 #pragma CTC ENDSKIP
     // Evaluated
@@ -2435,7 +2435,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
         } else {
             kernel_per_group = kernel_per_group_ideal;
         }
-        cslDebug((30, "kernel_group_iter=%d current kernel_per_group=%d\n", kernel_group_iter, kernel_per_group));
+        //cslDebug((30, "kernel_group_iter=%d current kernel_per_group=%d\n", kernel_group_iter, kernel_per_group));
         // WaitUntilThereAreEnoughKernelGroup(kernel_per_group);
         int kernel_data_available;
         if (is_skip_weight_rls_mode) {
@@ -2447,9 +2447,9 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
             WaitUntilThereAreEnoughKernel(kernel_per_group);
             kernel_data_available = kernel_per_group;
         }
-        cslDebug((70, "enough(%d) kernel are received\n", kernel_data_available));
+        //cslDebug((70, "enough(%d) kernel are received\n", kernel_data_available));
         for (channel_operation_iter=0; channel_operation_iter < channel_operation_num; channel_operation_iter++) {
-            cslDebug((30, "channel_operation_iter=%d\n", channel_operation_iter));
+            //cslDebug((30, "channel_operation_iter=%d\n", channel_operation_iter));
             if (NVDLA_CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED==weight_format) {
                 comp_updated_wt_entry_num = 0;
                 comp_updated_wmb_entry_num = 0;
@@ -2470,16 +2470,16 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                         FAIL(("The weight data in comp_entry_wt should be used by prev kernel group\n"));
 #pragma CTC ENDSKIP
                     int i;
-                    cslDebug((70, "After restore: wt_payload_available=%d next_wt_idx=%d next_wmb_idx=%d\n", wt_payload_available, next_wt_idx, next_wmb_idx));
-                    cslDebug((70, "comp_entry_wt:\n"));
-                    for(i=0;i<CBUF_ENTRY_SIZE/8;i++)
-                        cslDebug((70, "0x%016lx ", comp_entry_wt[i]));
-                    cslDebug((70, "\n"));
-
-                    cslDebug((70, "comp_entry_wmb:\n"));
-                    for(i=0;i<CBUF_ENTRY_SIZE;i++)
-                        cslDebug((70, "0x%02x ", comp_entry_wmb[i]));
-                    cslDebug((70, "\n"));
+                    //cslDebug((70, "After restore: wt_payload_available=%d next_wt_idx=%d next_wmb_idx=%d\n", wt_payload_available, next_wt_idx, next_wmb_idx));
+                    //cslDebug((70, "comp_entry_wt:\n"));
+                    //for(i=0;i<CBUF_ENTRY_SIZE/8;i++)
+                        //cslDebug((70, "0x%016lx ", comp_entry_wt[i]));
+                    //cslDebug((70, "\n"));
+
+                    //cslDebug((70, "comp_entry_wmb:\n"));
+                    //for(i=0;i<CBUF_ENTRY_SIZE;i++)
+                        //cslDebug((70, "0x%02x ", comp_entry_wmb[i]));
+                    //cslDebug((70, "\n"));
                 }
                 // For each channel op in one kernel group, restart from the start of the kernel group
                 cbuf_wt_entry_addr  = cbuf_entry_for_data + weight_entry_idx_start_ % cbuf_entry_for_weight;
@@ -2488,17 +2488,17 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                 // NOTE: for winograd, each kernel group is aligned to 128B? So there should be no left weight when releasing kernel group? If so, no need to do memcpy
             }
             for (block_operation_iter=0; block_operation_iter < block_per_channel_num; block_operation_iter ++) {
-                cslDebug((30, "block_operation_iter=%d\n", block_operation_iter));
+                //cslDebug((30, "block_operation_iter=%d\n", block_operation_iter));
                 // block_per_channel_num is number of input channels
                 super_atom_size = ELEMENT_PER_INPUT_ATOM_WG * element_size * 4*4;
                 input_atom_channel_num = ELEMENT_PER_INPUT_ATOM_WG;
                 stripe_operation_stride  = super_atom_size * kernel_per_group;
                 block_operation_stride   = stripe_operation_stride * stripe_operation_per_block_operation;  // stripe_operatrion_stride*1
                 for (stripe_operation_iter=0; stripe_operation_iter<stripe_operation_per_block_operation; stripe_operation_iter++) {
-                    cslDebug((30, "stripe_operation_iter=%d\n", stripe_operation_iter));
+                    //cslDebug((30, "stripe_operation_iter=%d\n", stripe_operation_iter));
                     WaitStripeBeginHasSent();   //Wait until the previous stipe has been sent to mac. Then load the next batch of kernels into shadow.
                     for (kernel_iter=0; kernel_iter<kernel_per_group; kernel_iter++) {
-                        cslDebug((30, "kernel_iter=%d\n", kernel_iter));
+                        //cslDebug((30, "kernel_iter=%d\n", kernel_iter));
                         kernel_atom_size_index = (weight_layer_start_byte_idx_
                                 + kernel_iter * super_atom_size
                                 + stripe_operation_iter * stripe_operation_stride
@@ -2506,12 +2506,12 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                                 + kernel_group_iter     * kernel_group_stride) % (cbuf_entry_for_weight*CBUF_ENTRY_SIZE);
                         cbuf_entry_addr = cbuf_entry_for_data + kernel_atom_size_index/CBUF_ENTRY_SIZE;
                         begin_byte_within_one_entry = kernel_atom_size_index % CBUF_ENTRY_SIZE;
-                        cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon, iterator values:\n"));
-                        cslDebug((50, "    kernel_iter                is %d\n", kernel_iter));
-                        cslDebug((50, "    stripe_operation_iter      is %d\n", stripe_operation_iter));
-                        cslDebug((50, "    block_operation_iter       is %d\n", block_operation_iter));
-                        cslDebug((50, "    channel_operation_iter     is %d\n", channel_operation_iter));
-                        cslDebug((50, "    kernel_group_iter          is %d\n", kernel_group_iter));
+                        //cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon, iterator values:\n"));
+                        //cslDebug((50, "    kernel_iter                is %d\n", kernel_iter));
+                        //cslDebug((50, "    stripe_operation_iter      is %d\n", stripe_operation_iter));
+                        //cslDebug((50, "    block_operation_iter       is %d\n", block_operation_iter));
+                        //cslDebug((50, "    channel_operation_iter     is %d\n", channel_operation_iter));
+                        //cslDebug((50, "    kernel_group_iter          is %d\n", kernel_group_iter));
                         if (NVDLA_CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED==weight_format) {
                             uint8_t *read_data_curr_ptr_int8;
                             read_data_curr_ptr_int8 = new uint8_t [CBUF_ENTRY_SIZE];
@@ -2520,7 +2520,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                             if (DATA_FORMAT_INT8 == precision) {    // sc2mac_a_wt_payload.data[0] is sc_int<8>
                                 for (sc2mac_element_iter=ELEMENT_PER_INPUT_ATOM*(kernel_iter%2); sc2mac_element_iter< ELEMENT_PER_INPUT_ATOM*(kernel_iter%2) + 4*4*input_atom_channel_num; sc2mac_element_iter++) {
                                     sc2mac_a_wt_payload.data[sc2mac_element_iter] = read_data_curr_ptr_int8[sc2mac_element_iter - ELEMENT_PER_INPUT_ATOM*(kernel_iter%2)];
-                                    cslDebug((70, "kernel_iter=%d sc2mac_element_iter=%d read_data_curr_ptr_int8[]=0x%x sc2mac_a_wt_payload.data[]=0x%x\n", kernel_iter, sc2mac_element_iter, read_data_curr_ptr_int8[sc2mac_element_iter - ELEMENT_PER_INPUT_ATOM*(kernel_iter%2)], sc2mac_a_wt_payload.data[sc2mac_element_iter].to_int()));
+                                    //cslDebug((70, "kernel_iter=%d sc2mac_element_iter=%d read_data_curr_ptr_int8[]=0x%x sc2mac_a_wt_payload.data[]=0x%x\n", kernel_iter, sc2mac_element_iter, read_data_curr_ptr_int8[sc2mac_element_iter - ELEMENT_PER_INPUT_ATOM*(kernel_iter%2)], sc2mac_a_wt_payload.data[sc2mac_element_iter].to_int()));
                                 }
                             } else {
                                 for (sc2mac_element_iter=0; sc2mac_element_iter<4*4*input_atom_channel_num*2; sc2mac_element_iter++) {
@@ -2535,7 +2535,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                             // There is no usable data in read_data_curr_ptr
                             // Read new line in cbuf
                             sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr = cbuf_entry_addr;
-                            cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon, begin byte address is aligned with entry size.  sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr));
+                            //cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon, begin byte address is aligned with entry size.  sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr));
                             if (cbuf_entry_addr == (cbuf_entry_for_data+cbuf_entry_for_weight-1))
                                 cbuf_entry_addr = cbuf_entry_for_data;
                             else
@@ -2573,7 +2573,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                                 // Fill 0 to cripple channels
                                 if (input_atom_channel_num != ELEMENT_PER_INPUT_ATOM_WG) {
                                     FAIL(("cripple channel is not allowed for winograd\n"));
-                                    cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon, fill cripple channel\n"));
+                                    //cslDebug((50, "NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon, fill cripple channel\n"));
                                     for (sc2mac_element_iter=4*4*input_atom_channel_num*2; sc2mac_element_iter< 4*4*ELEMENT_PER_INPUT_ATOM_WG*2; sc2mac_element_iter++) {
                                         sc2mac_a_wt_payload.data[sc2mac_element_iter] = 0;
                                     }
@@ -2611,7 +2611,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
 #pragma CTC SKIP
                                 if ((0==(kernel_iter%2)) && (kernel_iter == kernel_per_group - 1)) {
 #pragma CTC ENDSKIP
-                                    cslDebug((70, "Last kernel of kernels, the total number of kernel is odd. kernel_iter=%d\n", kernel_iter));
+                                    //cslDebug((70, "Last kernel of kernels, the total number of kernel is odd. kernel_iter=%d\n", kernel_iter));
                                     // In INT8 case, two kernels shalls one MAC cell, if kernel_per_group is a odd number, fill zero to the 2nd kernel (64Bytes)
                                     for (sc2mac_element_iter=ELEMENT_PER_INPUT_ATOM; sc2mac_element_iter< ELEMENT_PER_INPUT_ATOM*2; sc2mac_element_iter++) {
                                         sc2mac_a_wt_payload.data[sc2mac_element_iter] = 0;
@@ -2626,17 +2626,17 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                                 }
 
                                 sc2mac_a_wt_payload.sel = 0x1 << (kernel_iter/2);
-                                cslDebug((70, "sc2mac_a_wt_payload is\n"));
-                                cslDebug((50, "    mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[0]));
-                                cslDebug((50, "    mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[1]));
-                                cslDebug((70, "    sel is 0x%x\n", sc2mac_a_wt_payload.sel));
+                                //cslDebug((70, "sc2mac_a_wt_payload is\n"));
+                                //cslDebug((50, "    mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[0]));
+                                //cslDebug((50, "    mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[1]));
+                                //cslDebug((70, "    sel is 0x%x\n", sc2mac_a_wt_payload.sel));
                                 for (uint32_t idx_db=0; idx_db<128; idx_db ++) {
-                                    cslDebug((70, "    Weight[%d]: 0x%02x\n", idx_db, (uint8_t)sc2mac_a_wt_payload.data[idx_db].to_int()));
+                                    //cslDebug((70, "    Weight[%d]: 0x%02x\n", idx_db, (uint8_t)sc2mac_a_wt_payload.data[idx_db].to_int()));
                                 }
                                 if ((sc2mac_a_wt_payload.sel&0xFF)) {
                                     sc2mac_a_wt_b_transport(&sc2mac_a_wt_payload, b_transport_delay_);
                                 } else { //if ((sc2mac_a_wt_payload.sel>>8) & 0xFF)  {
-                                    cslDebug((70, "sending sc2mac_a_wt_payload to MAC_B\n"));
+                                    //cslDebug((70, "sending sc2mac_a_wt_payload to MAC_B\n"));
                                     sc2mac_a_wt_payload.sel = sc2mac_a_wt_payload.sel >> 8;
                                     sc2mac_b_wt_b_transport(&sc2mac_a_wt_payload, b_transport_delay_);
                                 }
@@ -2655,24 +2655,24 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                                     sc2mac_a_wt_payload.mask[0] = (sc2mac_a_wt_payload.mask[0]<<2) | element_mask_bit;
                             }
                             sc2mac_a_wt_payload.sel = 0x1 << kernel_iter;
-                            cslDebug((70, "sc2mac_a_wt_payload is\n"));
-                            cslDebug((50, "    mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[0]));
-                            cslDebug((50, "    mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[1]));
-                            cslDebug((70, "    sel is 0x%x\n", sc2mac_a_wt_payload.sel));
+                            //cslDebug((70, "sc2mac_a_wt_payload is\n"));
+                            //cslDebug((50, "    mask[0]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[0]));
+                            //cslDebug((50, "    mask[1]=0x%016lx\n", (uint64_t)sc2mac_a_wt_payload.mask[1]));
+                            //cslDebug((70, "    sel is 0x%x\n", sc2mac_a_wt_payload.sel));
                             for (uint32_t idx_db=0; idx_db<128; idx_db ++) {
-                                cslDebug((70, "    Weight[%d]: 0x%02x\n", idx_db, (uint8_t)(sc2mac_a_wt_payload.data[idx_db].to_int())));
+                                //cslDebug((70, "    Weight[%d]: 0x%02x\n", idx_db, (uint8_t)(sc2mac_a_wt_payload.data[idx_db].to_int())));
                             }
 
 #ifdef WG_CMOD_DEBUG
                             if (kernel_group_iter == 0 && channel_operation_iter == 0 && kernel_iter == 1) {
-                                cslDebug((30, "WG_CMOD_DEBUG:block_operation_iter:%d\n", block_operation_iter));
-                                cslDebug((30, "\nWG_CMOD_DEBUG:wt_post_pra:"));
+                                //cslDebug((30, "WG_CMOD_DEBUG:block_operation_iter:%d\n", block_operation_iter));
+                                //cslDebug((30, "\nWG_CMOD_DEBUG:wt_post_pra:"));
                                 for(uint32_t channel_iter = 0; channel_iter < 4; channel_iter++) {
                                     for (uint32_t idx_db=0; idx_db<16; idx_db ++) {
-                                        cslDebug((70, "0x%02x ", (uint8_t)(sc2mac_a_wt_payload.data[idx_db*8+channel_iter*2].to_int())));
-                                        cslDebug((70, "0x%02x ", (uint8_t)(sc2mac_a_wt_payload.data[idx_db*8+channel_iter*2+1].to_int())));
+                                        //cslDebug((70, "0x%02x ", (uint8_t)(sc2mac_a_wt_payload.data[idx_db*8+channel_iter*2].to_int())));
+                                        //cslDebug((70, "0x%02x ", (uint8_t)(sc2mac_a_wt_payload.data[idx_db*8+channel_iter*2+1].to_int())));
                                     }
-                                    cslDebug((30, "\nWG_CMOD_DEBUG:wt_post_pra:"));
+                                    //cslDebug((30, "\nWG_CMOD_DEBUG:wt_post_pra:"));
                                 }
                             }
 #endif
@@ -2690,11 +2690,11 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                     // Notify data thread that a kernel group is ready
                     kernel_switch_round_weight_ ++;
                     kernel_switch_updated_.notify();
-                    cslDebug((30, "end of stripe_operation_iter=%d\n", stripe_operation_iter));
+                    //cslDebug((30, "end of stripe_operation_iter=%d\n", stripe_operation_iter));
                 }
-                cslDebug((30, "end of block_operation_iter=%d\n", block_operation_iter));
+                //cslDebug((30, "end of block_operation_iter=%d\n", block_operation_iter));
             }
-            cslDebug((30, "end of channel_operation_iter=%d\n", channel_operation_iter));
+            //cslDebug((30, "end of channel_operation_iter=%d\n", channel_operation_iter));
         }
 
         if (NVDLA_CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED==weight_format) {
@@ -2704,7 +2704,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                 weight_entry_idx_start_ += total_wt_entries - comp_released_wt_entries;
 #pragma CTC SKIP
                 if (total_wt_entries - comp_released_wt_entries != comp_updated_wt_entry_num) {
-                    cslInfo(("total_wt_entries=0x%x comp_released_wt_entries=0x%x comp_updated_wt_entry_num=0x%x\n", total_wt_entries, comp_released_wt_entries, comp_updated_wt_entry_num));
+                    //cslInfo(("total_wt_entries=0x%x comp_released_wt_entries=0x%x comp_updated_wt_entry_num=0x%x\n", total_wt_entries, comp_released_wt_entries, comp_updated_wt_entry_num));
                     FAIL(("In the end of last kernel group in weight compression mode, the wt entry num used should be same as available wt entries\n"));
                 }
 #pragma CTC ENDSKIP
@@ -2714,7 +2714,7 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
                 wmb_entry_idx_start_ += total_wmb_entries - comp_released_wmb_entries;
 #pragma CTC SKIP
                 if (total_wmb_entries - comp_released_wmb_entries != comp_updated_wmb_entry_num) {
-                    cslInfo(("total_wmb_entries=0x%x comp_released_wmb_entries=0x%x comp_updated_wmb_entry_num=0x%x\n", total_wmb_entries, comp_released_wmb_entries, comp_updated_wmb_entry_num));
+                    //cslInfo(("total_wmb_entries=0x%x comp_released_wmb_entries=0x%x comp_updated_wmb_entry_num=0x%x\n", total_wmb_entries, comp_released_wmb_entries, comp_updated_wmb_entry_num));
                     FAIL(("In the end of last kernel group in weight compression mode, the wmb entry num used should be same as available wmb entries\n"));
                 }
 #pragma CTC ENDSKIP
@@ -2735,12 +2735,12 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
             weight_kernel_num_used_ += kernel_per_group;
             wt_up_sc2cdma_payload.wt_kernels = kernel_per_group;
             wt_up_sc2cdma_b_transport(&wt_up_sc2cdma_payload, b_transport_delay_);
-            cslInfo(("after wt_up_sc2cdma_b_transport.    wt_kernels = 0x%x\ wt_entries=0x%x wmb_entries=0x%xn", wt_up_sc2cdma_payload.wt_kernels, wt_up_sc2cdma_payload.wt_entries, wt_up_sc2cdma_payload.wmb_entries));
+            //cslInfo(("after wt_up_sc2cdma_b_transport.    wt_kernels = 0x%x\ wt_entries=0x%x wmb_entries=0x%xn", wt_up_sc2cdma_payload.wt_kernels, wt_up_sc2cdma_payload.wt_entries, wt_up_sc2cdma_payload.wmb_entries));
         }
         if (NVDLA_CSC_D_WEIGHT_FORMAT_0_WEIGHT_FORMAT_COMPRESSED==weight_format) {
             save_info_kernel_group();
         }
-        cslDebug((30, "end of kernel_group_iter=%d\n", kernel_group_iter));
+        //cslDebug((30, "end of kernel_group_iter=%d\n", kernel_group_iter));
     }
 
     delete [] read_data_curr_ptr;
@@ -2750,10 +2750,10 @@ void NV_NVDLA_csc::SendWeightToMacSequencerWinoConvCommon() {
 void NV_NVDLA_csc::WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput(uint32_t required_entry_num) {
     uint32_t dat_entries;
     while (true) {
-        cslDebug((50, "NV_NVDLA_csc::WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput\n"));
-        cslDebug((50, "    data_entry_idx_available_ is 0x%lx\n", data_entry_idx_available_));
-        cslDebug((50, "    data_entry_idx_free_ is 0x%lx\n", data_entry_idx_free_));
-        cslDebug((50, "    required_entry_num is 0x%x\n", required_entry_num));
+        //cslDebug((50, "NV_NVDLA_csc::WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput\n"));
+        //cslDebug((50, "    data_entry_idx_available_ is 0x%lx\n", data_entry_idx_available_));
+        //cslDebug((50, "    data_entry_idx_free_ is 0x%lx\n", data_entry_idx_free_));
+        //cslDebug((50, "    required_entry_num is 0x%x\n", required_entry_num));
 
         if ((data_entry_idx_available_ - data_entry_idx_free_) >= required_entry_num) {
             break;
@@ -2768,14 +2768,14 @@ void NV_NVDLA_csc::WaitUntilCBufferHasEnoughtAvailiableDataEntriesFullInput(uint
 
 void NV_NVDLA_csc::WaitUntilThereAreEnoughKernel(uint32_t kernel_num) {
     while ( (weight_kernel_num_available_ - weight_kernel_num_used_) < kernel_num) {
-        cslDebug((50, "NV_NVDLA_csc::WaitUntilThereAreEnoughKernel: wait cdma_updated_cbuf_weight_usage_. weight_kernel_num_available_=0x%lx weight_kernel_num_used_=0x%lx kernel_num=0x%u\n", weight_kernel_num_available_, weight_kernel_num_used_, kernel_num));
+        //cslDebug((50, "NV_NVDLA_csc::WaitUntilThereAreEnoughKernel: wait cdma_updated_cbuf_weight_usage_. weight_kernel_num_available_=0x%lx weight_kernel_num_used_=0x%lx kernel_num=0x%u\n", weight_kernel_num_available_, weight_kernel_num_used_, kernel_num));
         wait(cdma_updated_cbuf_weight_usage_);
     }
 }
 
 void NV_NVDLA_csc::WaitUntilThereIsEnoughSpaceInCaccu (uint32_t num) {
     while (true) {
-        cslDebug((50, "NV_NVDLA_csc::WaitUntilThereIsEnoughSpaceInCaccu. cacc_free_entry_num_=%lu, num=%u\n", cacc_free_entry_num_, num));
+        //cslDebug((50, "NV_NVDLA_csc::WaitUntilThereIsEnoughSpaceInCaccu. cacc_free_entry_num_=%lu, num=%u\n", cacc_free_entry_num_, num));
         if (cacc_free_entry_num_ < num) {
             wait(accu_free_entry_num_update_);
         } else {
@@ -2786,14 +2786,14 @@ void NV_NVDLA_csc::WaitUntilThereIsEnoughSpaceInCaccu (uint32_t num) {
 
 void NV_NVDLA_csc::WaitUntilKernelsAreReady() {
     while (kernel_switch_round_data_ >= kernel_switch_round_weight_) {
-        cslDebug((50, "NV_NVDLA_csc::WaitUntilKernelsAreReady, kernel_switch_round_data_ = %lx kernel_switch_round_weight_ = %lx\n", kernel_switch_round_data_, kernel_switch_round_weight_));
+        //cslDebug((50, "NV_NVDLA_csc::WaitUntilKernelsAreReady, kernel_switch_round_data_ = %lx kernel_switch_round_weight_ = %lx\n", kernel_switch_round_data_, kernel_switch_round_weight_));
         wait(kernel_switch_updated_);
     }
 }
 
 void NV_NVDLA_csc::WaitStripeBeginHasSent() {
     while (kernel_switch_round_data_ < kernel_switch_round_weight_) {
-        cslDebug((50, "NV_NVDLA_csc::WaitStripeBeginHasSent, kernel_switch_round_data_ = %lu kernel_switch_round_weight_ = %lu\n", kernel_switch_round_data_, kernel_switch_round_weight_));
+        //cslDebug((50, "NV_NVDLA_csc::WaitStripeBeginHasSent, kernel_switch_round_data_ = %lu kernel_switch_round_weight_ = %lu\n", kernel_switch_round_data_, kernel_switch_round_weight_));
         wait(stripe_begin_updated_);
     }
 }
@@ -2805,8 +2805,8 @@ void NV_NVDLA_csc::dat_up_cdma2sc_b_transport(int ID, nvdla_dat_info_update_t* p
     slice_idx_available_+= payload->dat_slices;
     slice_idx_dma_fetched_mutex_.unlock();
     // data_entry_idx_available_ += payload->dat_entries;
-    cslDebug((50, "NV_NVDLA_csc::dat_up_cdma2sc_b_transport, data_entry_idx_available_ is 0x%lx\n", data_entry_idx_available_));
-    cslDebug((50, "NV_NVDLA_csc::dat_up_cdma2sc_b_transport, slice_idx_available_[%d] is 0x%x\n", csc_consumer_, slice_idx_available_));
+    //cslDebug((50, "NV_NVDLA_csc::dat_up_cdma2sc_b_transport, data_entry_idx_available_ is 0x%lx\n", data_entry_idx_available_));
+    //cslDebug((50, "NV_NVDLA_csc::dat_up_cdma2sc_b_transport, slice_idx_available_[%d] is 0x%x\n", csc_consumer_, slice_idx_available_));
     // cdma_updated_cbuf_data_usage_.notify();
     cdma_updated_cbuf_data_fifo_->write(payload->dat_entries);
 }
@@ -2815,8 +2815,8 @@ void NV_NVDLA_csc::wt_up_cdma2sc_b_transport(int ID, nvdla_wt_info_update_t* pay
     weight_kernel_num_available_ +=  payload->wt_kernels;
     weight_entry_idx_available_  +=  payload->wt_entries;
     wmb_entry_idx_available_     +=  payload->wmb_entries;
-    cslDebug((50, "NV_NVDLA_csc::wt_up_cdma2sc_b_transport, weight_entry_idx_available_ is 0x%lx\n", weight_entry_idx_available_));
-    cslDebug((50, "NV_NVDLA_csc::wt_up_cdma2sc_b_transport, wmb_entry_idx_available_ is 0x%lx\n", wmb_entry_idx_available_));
+    //cslDebug((50, "NV_NVDLA_csc::wt_up_cdma2sc_b_transport, weight_entry_idx_available_ is 0x%lx\n", weight_entry_idx_available_));
+    //cslDebug((50, "NV_NVDLA_csc::wt_up_cdma2sc_b_transport, wmb_entry_idx_available_ is 0x%lx\n", wmb_entry_idx_available_));
     cdma_updated_cbuf_weight_usage_.notify();
 }
 
@@ -2865,7 +2865,7 @@ void NV_NVDLA_csc::sc2buf_wmb_rd_nvdla_ram_data_valid_DATA_WIDTH_1024_ECC_SIZE_1
 // CACC->CSC entry info credit target socket
 void NV_NVDLA_csc::accu2sc_credit_b_transport (int ID, nvdla_cc_credit_t* payload, sc_time& delay){
     cacc_free_entry_num_ += payload->size;
-    cslDebug((50, "NV_NVDLA_csc::accu2sc_credit_b_transport size=0x%x cacc_free_entry_num_=%lu\n", (uint32_t)(payload->size), cacc_free_entry_num_));
+    //cslDebug((50, "NV_NVDLA_csc::accu2sc_credit_b_transport size=0x%x cacc_free_entry_num_=%lu\n", (uint32_t)(payload->size), cacc_free_entry_num_));
     accu_free_entry_num_update_.notify();
 }
 
@@ -2883,7 +2883,7 @@ void NV_NVDLA_csc::csc_read_one_image_entry(uint8_t post_y_extension, uint32_t p
     cbuf_entry_for_data     = (csc_data_bank_ + 1) * CBUF_ENTRY_PER_BANK;
 
     if ( ((input_atom_coor_height + post_y_extension_idx) < 0) || ((input_atom_coor_height + post_y_extension_idx) >= int32_t(cube_in_height)) ) {
-        cslDebug((50, "Top or bottom padding , no data in CBUF, fill with pad value\n"));
+        //cslDebug((50, "Top or bottom padding , no data in CBUF, fill with pad value\n"));
         switch (precision) {
             case DATA_FORMAT_INT8:
                 for (i=0; i < PARALLEL_CHANNEL_NUM; i++) {
@@ -2914,7 +2914,7 @@ void NV_NVDLA_csc::csc_read_one_image_entry(uint8_t post_y_extension, uint32_t p
 
     bool across_cbuf_entry = ((input_atom_coor_width * element_size) % CBUF_ENTRY_SIZE) != 0;
     uint32_t cbuf_entry_addr = (data_entry_idx_free_ + ((input_atom_coor_height + post_y_extension_idx) * cbuf_entry_per_line) + (input_atom_coor_width * element_size) / CBUF_ENTRY_SIZE)%cbuf_entry_for_data;
-    cslDebug((50, "NV_NVDLA_csc::csc_read_one_image_entry. cbuf_entry_addr=0x%x\n", cbuf_entry_addr));
+    //cslDebug((50, "NV_NVDLA_csc::csc_read_one_image_entry. cbuf_entry_addr=0x%x\n", cbuf_entry_addr));
     read_cbuf_entry(cbuf_entry_addr, read_data_ptr0);
 
     if (across_cbuf_entry) {
@@ -2922,7 +2922,7 @@ void NV_NVDLA_csc::csc_read_one_image_entry(uint8_t post_y_extension, uint32_t p
             cbuf_entry_addr = 0;
         else
             cbuf_entry_addr ++;
-        cslDebug((50, "NV_NVDLA_csc::csc_read_one_image_entry. 2nd reading of cbuf when across_cbuf_entry. cbuf_entry_addr=0x%x\n", cbuf_entry_addr));
+        //cslDebug((50, "NV_NVDLA_csc::csc_read_one_image_entry. 2nd reading of cbuf when across_cbuf_entry. cbuf_entry_addr=0x%x\n", cbuf_entry_addr));
         read_cbuf_entry(cbuf_entry_addr, read_data_ptr1);
     }
 
@@ -3009,7 +3009,7 @@ void NV_NVDLA_csc::get_decompressed_weight(uint8_t *read_data_curr_ptr, uint32_t
     // next_wmb_idx's range: [0 ~ 128*8-1]
     for(i=0;i<current_kernel_channel;i++) {
 #if LOG_DETAIL
-        cslDebug((90, "NV_NVDLA_csc::get_decompressed_weight. i=%d wt_payload_available=%d next_wt_idx=%d next_wmb_idx=%d\n", i, wt_payload_available, next_wt_idx, next_wmb_idx));
+        //cslDebug((90, "NV_NVDLA_csc::get_decompressed_weight. i=%d wt_payload_available=%d next_wt_idx=%d next_wmb_idx=%d\n", i, wt_payload_available, next_wt_idx, next_wmb_idx));
 #endif
 /*        if (wt_payload_available==0) {
             // Read next entry of compressed weight
@@ -3031,7 +3031,7 @@ void NV_NVDLA_csc::get_decompressed_weight(uint8_t *read_data_curr_ptr, uint32_t
         if (next_wmb_idx==0) {
             // Read next entry of WMB
             sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr = cbuf_wmb_entry_addr;
-            cslDebug((50, "NV_NVDLA_csc::get_decompressed_weight. read wmb from cbuf. sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr));
+            //cslDebug((50, "NV_NVDLA_csc::get_decompressed_weight. read wmb from cbuf. sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr));
             if (cbuf_wmb_entry_addr == (15*CBUF_ENTRY_PER_BANK + CBUF_ENTRY_PER_BANK - 1))
                 cbuf_wmb_entry_addr = 15*CBUF_ENTRY_PER_BANK;
             else
@@ -3046,12 +3046,12 @@ void NV_NVDLA_csc::get_decompressed_weight(uint8_t *read_data_curr_ptr, uint32_t
 
         current_bit = (comp_entry_wmb[next_wmb_idx/8]>>(next_wmb_idx%8))&0x1;
 #if LOG_DETAIL
-        cslDebug((90, "current_bit=%d weight_ori_int8[next_wt_idx]=0x%02x weight_ori_int16[next_wt_idx]=0x%04x\n", current_bit, weight_ori_int8[next_wt_idx], weight_ori_int16[next_wt_idx]));
+        //cslDebug((90, "current_bit=%d weight_ori_int8[next_wt_idx]=0x%02x weight_ori_int16[next_wt_idx]=0x%04x\n", current_bit, weight_ori_int8[next_wt_idx], weight_ori_int16[next_wt_idx]));
 #endif
         if ((current_bit!=0) && (wt_payload_available==0)) {
             // Read next entry of compressed weight only when necessary
             sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr = cbuf_wt_entry_addr;
-            cslDebug((50, "NV_NVDLA_csc::get_decompressed_weight. read wt from cbuf. sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", cbuf_wt_entry_addr));
+            //cslDebug((50, "NV_NVDLA_csc::get_decompressed_weight. read wt from cbuf. sc2buf_wt_rd_payload.nvdla_ram_addr_ADDR_WIDTH_12_BE_1.addr is 0x%x\n", cbuf_wt_entry_addr));
             if (cbuf_wt_entry_addr == (cbuf_entry_for_data+cbuf_entry_for_weight-1))
                 cbuf_wt_entry_addr = cbuf_entry_for_data;
             else
@@ -3110,7 +3110,7 @@ void NV_NVDLA_csc::get_decompressed_weight(uint8_t *read_data_curr_ptr, uint32_t
         }
     }
 
-    cslDebug((70, "NV_NVDLA_csc::get_decompressed_weight result:\n"));
+    //cslDebug((70, "NV_NVDLA_csc::get_decompressed_weight result:\n"));
 
     // Got 64 elements of decompressed weight
     switch(precision) {
@@ -3118,7 +3118,7 @@ void NV_NVDLA_csc::get_decompressed_weight(uint8_t *read_data_curr_ptr, uint32_t
             for(i=0;i<64;i++) {
                 read_data_curr_ptr[i] = weight_int8[i];
 #if LOG_DETAIL
-                cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", i, read_data_curr_ptr[i]));
+                //cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", i, read_data_curr_ptr[i]));
 #endif
             }
             break; 
@@ -3127,8 +3127,8 @@ void NV_NVDLA_csc::get_decompressed_weight(uint8_t *read_data_curr_ptr, uint32_t
                 read_data_curr_ptr[2*i]     = weight_int16[i] & 0xff;
                 read_data_curr_ptr[2*i+1]   = (weight_int16[i] >> 8) & 0xff;
 #if LOG_DETAIL
-                cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", 2*i, read_data_curr_ptr[2*i]));
-                cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", 2*i+1, read_data_curr_ptr[2*i+1]));
+                //cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", 2*i, read_data_curr_ptr[2*i]));
+                //cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", 2*i+1, read_data_curr_ptr[2*i+1]));
 #endif
             }
             break; 
@@ -3137,8 +3137,8 @@ void NV_NVDLA_csc::get_decompressed_weight(uint8_t *read_data_curr_ptr, uint32_t
                 read_data_curr_ptr[2*i]     = weight_fp16[i] & 0xff;
                 read_data_curr_ptr[2*i+1]   = (weight_fp16[i] >> 8) & 0xff;
 #if LOG_DETAIL
-                cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", 2*i, read_data_curr_ptr[2*i]));
-                cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", 2*i+1, read_data_curr_ptr[2*i+1]));
+                //cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", 2*i, read_data_curr_ptr[2*i]));
+                //cslDebug((90, "    read_data_curr_ptr[%d]: 0x%02x\n", 2*i+1, read_data_curr_ptr[2*i+1]));
 #endif
             }
             break; 
@@ -3242,16 +3242,16 @@ void NV_NVDLA_csc::save_info_kernel_group() {
     wt_payload_available_bak = wt_payload_available;
     next_wt_idx_bak = next_wt_idx;
     next_wmb_idx_bak = next_wmb_idx;
-    cslDebug((70, "NV_NVDLA_csc::save_info_kernel_group wt_payload_available=%d next_wt_idx=%d next_wmb_idx=%d\n", wt_payload_available, next_wt_idx, next_wmb_idx));
-    cslDebug((70, "comp_entry_wt:\n"));
-    for(i=0;i<CBUF_ENTRY_SIZE/8;i++)
-        cslDebug((70, "0x%016lx ", comp_entry_wt[i]));
-    cslDebug((70, "\n"));
-
-    cslDebug((70, "comp_entry_wmb:\n"));
-    for(i=0;i<CBUF_ENTRY_SIZE;i++)
-        cslDebug((70, "0x%02x ", comp_entry_wmb[i]));
-    cslDebug((70, "\n"));
+    //cslDebug((70, "NV_NVDLA_csc::save_info_kernel_group wt_payload_available=%d next_wt_idx=%d next_wmb_idx=%d\n", wt_payload_available, next_wt_idx, next_wmb_idx));
+    //cslDebug((70, "comp_entry_wt:\n"));
+    //for(i=0;i<CBUF_ENTRY_SIZE/8;i++)
+        //cslDebug((70, "0x%016lx ", comp_entry_wt[i]));
+    //cslDebug((70, "\n"));
+
+    //cslDebug((70, "comp_entry_wmb:\n"));
+    //for(i=0;i<CBUF_ENTRY_SIZE;i++)
+        //cslDebug((70, "0x%02x ", comp_entry_wmb[i]));
+    //cslDebug((70, "\n"));
 }
 
 // void NV_NVDLA_csc::recover_info_kernel_group() {
diff --git a/cmod/csc/gen/csc_reg_model.cpp b/cmod/csc/gen/csc_reg_model.cpp
index b59b3eb..6904038 100644
--- a/cmod/csc/gen/csc_reg_model.cpp
+++ b/cmod/csc/gen/csc_reg_model.cpp
@@ -85,7 +85,7 @@ bool csc_reg_model::CscAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 csc_register_group_0->SetWritable(offset, data);
                 if (csc_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_csc_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "csc_reg_model::CscAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "csc_reg_model::CscAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -97,7 +97,7 @@ bool csc_reg_model::CscAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 csc_register_group_1->SetWritable(offset, data);
                 if (csc_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_csc_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "csc_reg_model::CscAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "csc_reg_model::CscAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/cvif/gen/NV_NVDLA_cvif.cpp b/cmod/cvif/gen/NV_NVDLA_cvif.cpp
index e877744..4b78365 100644
--- a/cmod/cvif/gen/NV_NVDLA_cvif.cpp
+++ b/cmod/cvif/gen/NV_NVDLA_cvif.cpp
@@ -306,7 +306,7 @@ void NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -328,14 +328,14 @@ void NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
     // Push the number of atoms of the request
     // bdma2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     bdma2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, write 0x%x to bdma2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, write 0x%x to bdma2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -354,7 +354,7 @@ void NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -407,25 +407,25 @@ void NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_\x0A"));
                     bdma_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_\x0A"));
                     bdma_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_\x0A"));
                     bdma_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(BDMA_AXI_ID);
@@ -436,14 +436,14 @@ void NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
             FAIL(("NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, before sending data to bdma_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, before sending data to bdma_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         bdma_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, after sending data to bdma_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, after sending data to bdma_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::bdma2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2bdma() {
@@ -457,9 +457,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2bdma() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = bdma2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, update atom_num_left from bdma2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, update atom_num_left from bdma2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -469,7 +469,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2bdma() {
         // Aligen to 32B
         axi_atom_ptr = cvif2bdma_rd_rsp_fifo_->read();
         credit_cvif2bdma_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, read 1st atom of the 64B from cvif2bdma_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, read 1st atom of the 64B from cvif2bdma_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -480,21 +480,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2bdma() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2bdma_rd_rsp_fifo_->read();
             credit_cvif2bdma_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, read 2nd atom of the 64B from cvif2bdma_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, read 2nd atom of the 64B from cvif2bdma_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2bdma, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2bdma, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2bdma, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2bdma, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, before NV_NVDLA_cvif_base::cvif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, before NV_NVDLA_cvif_base::cvif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, after NV_NVDLA_cvif_base::cvif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2bdma, after NV_NVDLA_cvif_base::cvif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -527,7 +527,7 @@ void NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -549,14 +549,14 @@ void NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
     // Push the number of atoms of the request
     // sdp2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     sdp2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, write 0x%x to sdp2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, write 0x%x to sdp2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -575,7 +575,7 @@ void NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -628,25 +628,25 @@ void NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_\x0A"));
                     sdp_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_\x0A"));
                     sdp_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_\x0A"));
                     sdp_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(SDP_AXI_ID);
@@ -657,14 +657,14 @@ void NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
             FAIL(("NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, before sending data to sdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, before sending data to sdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         sdp_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, after sending data to sdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, after sending data to sdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2sdp() {
@@ -678,9 +678,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = sdp2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, update atom_num_left from sdp2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, update atom_num_left from sdp2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -690,7 +690,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp() {
         // Aligen to 32B
         axi_atom_ptr = cvif2sdp_rd_rsp_fifo_->read();
         credit_cvif2sdp_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, read 1st atom of the 64B from cvif2sdp_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, read 1st atom of the 64B from cvif2sdp_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -701,21 +701,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2sdp_rd_rsp_fifo_->read();
             credit_cvif2sdp_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, read 2nd atom of the 64B from cvif2sdp_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, read 2nd atom of the 64B from cvif2sdp_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, before NV_NVDLA_cvif_base::cvif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, before NV_NVDLA_cvif_base::cvif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, after NV_NVDLA_cvif_base::cvif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp, after NV_NVDLA_cvif_base::cvif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -748,7 +748,7 @@ void NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -770,14 +770,14 @@ void NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
     // Push the number of atoms of the request
     // pdp2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     pdp2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, write 0x%x to pdp2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, write 0x%x to pdp2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -796,7 +796,7 @@ void NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -849,25 +849,25 @@ void NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_\x0A"));
                     pdp_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_\x0A"));
                     pdp_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_\x0A"));
                     pdp_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(PDP_AXI_ID);
@@ -878,14 +878,14 @@ void NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
             FAIL(("NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, before sending data to pdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, before sending data to pdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         pdp_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, after sending data to pdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, after sending data to pdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::pdp2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2pdp() {
@@ -899,9 +899,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2pdp() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = pdp2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, update atom_num_left from pdp2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, update atom_num_left from pdp2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -911,7 +911,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2pdp() {
         // Aligen to 32B
         axi_atom_ptr = cvif2pdp_rd_rsp_fifo_->read();
         credit_cvif2pdp_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, read 1st atom of the 64B from cvif2pdp_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, read 1st atom of the 64B from cvif2pdp_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -922,21 +922,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2pdp() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2pdp_rd_rsp_fifo_->read();
             credit_cvif2pdp_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, read 2nd atom of the 64B from cvif2pdp_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, read 2nd atom of the 64B from cvif2pdp_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2pdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2pdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2pdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2pdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, before NV_NVDLA_cvif_base::cvif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, before NV_NVDLA_cvif_base::cvif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, after NV_NVDLA_cvif_base::cvif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2pdp, after NV_NVDLA_cvif_base::cvif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -969,7 +969,7 @@ void NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -991,14 +991,14 @@ void NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
     // Push the number of atoms of the request
     // cdp2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     cdp2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, write 0x%x to cdp2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, write 0x%x to cdp2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1017,7 +1017,7 @@ void NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -1070,25 +1070,25 @@ void NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_\x0A"));
                     cdp_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_\x0A"));
                     cdp_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_\x0A"));
                     cdp_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(CDP_AXI_ID);
@@ -1099,14 +1099,14 @@ void NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
             FAIL(("NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, before sending data to cdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, before sending data to cdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         cdp_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, after sending data to cdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, after sending data to cdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::cdp2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2cdp() {
@@ -1120,9 +1120,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2cdp() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = cdp2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, update atom_num_left from cdp2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, update atom_num_left from cdp2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -1132,7 +1132,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2cdp() {
         // Aligen to 32B
         axi_atom_ptr = cvif2cdp_rd_rsp_fifo_->read();
         credit_cvif2cdp_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, read 1st atom of the 64B from cvif2cdp_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, read 1st atom of the 64B from cvif2cdp_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -1143,21 +1143,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2cdp() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2cdp_rd_rsp_fifo_->read();
             credit_cvif2cdp_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, read 2nd atom of the 64B from cvif2cdp_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, read 2nd atom of the 64B from cvif2cdp_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, before NV_NVDLA_cvif_base::cvif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, before NV_NVDLA_cvif_base::cvif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, after NV_NVDLA_cvif_base::cvif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdp, after NV_NVDLA_cvif_base::cvif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1190,7 +1190,7 @@ void NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -1212,14 +1212,14 @@ void NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
     // Push the number of atoms of the request
     // rbk2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     rbk2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, write 0x%x to rbk2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, write 0x%x to rbk2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1238,7 +1238,7 @@ void NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -1291,25 +1291,25 @@ void NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_\x0A"));
                     rbk_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_\x0A"));
                     rbk_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_\x0A"));
                     rbk_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(RBK_AXI_ID);
@@ -1320,14 +1320,14 @@ void NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
             FAIL(("NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, before sending data to rbk_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, before sending data to rbk_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         rbk_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, after sending data to rbk_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, after sending data to rbk_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::rbk2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2rbk() {
@@ -1341,9 +1341,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2rbk() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = rbk2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, update atom_num_left from rbk2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, update atom_num_left from rbk2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -1353,7 +1353,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2rbk() {
         // Aligen to 32B
         axi_atom_ptr = cvif2rbk_rd_rsp_fifo_->read();
         credit_cvif2rbk_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, read 1st atom of the 64B from cvif2rbk_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, read 1st atom of the 64B from cvif2rbk_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -1364,21 +1364,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2rbk() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2rbk_rd_rsp_fifo_->read();
             credit_cvif2rbk_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, read 2nd atom of the 64B from cvif2rbk_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, read 2nd atom of the 64B from cvif2rbk_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2rbk, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2rbk, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2rbk, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2rbk, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, before NV_NVDLA_cvif_base::cvif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, before NV_NVDLA_cvif_base::cvif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, after NV_NVDLA_cvif_base::cvif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2rbk, after NV_NVDLA_cvif_base::cvif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1411,7 +1411,7 @@ void NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -1433,14 +1433,14 @@ void NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
     // Push the number of atoms of the request
     // sdp_b2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     sdp_b2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, write 0x%x to sdp_b2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, write 0x%x to sdp_b2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1459,7 +1459,7 @@ void NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -1512,25 +1512,25 @@ void NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_\x0A"));
                     sdp_b_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_\x0A"));
                     sdp_b_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_\x0A"));
                     sdp_b_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(SDP_B_AXI_ID);
@@ -1541,14 +1541,14 @@ void NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
             FAIL(("NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, before sending data to sdp_b_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, before sending data to sdp_b_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         sdp_b_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, after sending data to sdp_b_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, after sending data to sdp_b_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp_b2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2sdp_b() {
@@ -1562,9 +1562,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp_b() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = sdp_b2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, update atom_num_left from sdp_b2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, update atom_num_left from sdp_b2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -1574,7 +1574,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp_b() {
         // Aligen to 32B
         axi_atom_ptr = cvif2sdp_b_rd_rsp_fifo_->read();
         credit_cvif2sdp_b_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, read 1st atom of the 64B from cvif2sdp_b_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, read 1st atom of the 64B from cvif2sdp_b_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -1585,21 +1585,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp_b() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2sdp_b_rd_rsp_fifo_->read();
             credit_cvif2sdp_b_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, read 2nd atom of the 64B from cvif2sdp_b_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, read 2nd atom of the 64B from cvif2sdp_b_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, before NV_NVDLA_cvif_base::cvif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, before NV_NVDLA_cvif_base::cvif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, after NV_NVDLA_cvif_base::cvif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_b, after NV_NVDLA_cvif_base::cvif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1632,7 +1632,7 @@ void NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -1654,14 +1654,14 @@ void NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
     // Push the number of atoms of the request
     // sdp_n2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     sdp_n2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, write 0x%x to sdp_n2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, write 0x%x to sdp_n2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1680,7 +1680,7 @@ void NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -1733,25 +1733,25 @@ void NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_\x0A"));
                     sdp_n_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_\x0A"));
                     sdp_n_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_\x0A"));
                     sdp_n_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(SDP_N_AXI_ID);
@@ -1762,14 +1762,14 @@ void NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
             FAIL(("NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, before sending data to sdp_n_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, before sending data to sdp_n_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         sdp_n_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, after sending data to sdp_n_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, after sending data to sdp_n_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp_n2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2sdp_n() {
@@ -1783,9 +1783,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp_n() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = sdp_n2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, update atom_num_left from sdp_n2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, update atom_num_left from sdp_n2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -1795,7 +1795,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp_n() {
         // Aligen to 32B
         axi_atom_ptr = cvif2sdp_n_rd_rsp_fifo_->read();
         credit_cvif2sdp_n_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, read 1st atom of the 64B from cvif2sdp_n_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, read 1st atom of the 64B from cvif2sdp_n_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -1806,21 +1806,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp_n() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2sdp_n_rd_rsp_fifo_->read();
             credit_cvif2sdp_n_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, read 2nd atom of the 64B from cvif2sdp_n_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, read 2nd atom of the 64B from cvif2sdp_n_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, before NV_NVDLA_cvif_base::cvif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, before NV_NVDLA_cvif_base::cvif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, after NV_NVDLA_cvif_base::cvif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_n, after NV_NVDLA_cvif_base::cvif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1853,7 +1853,7 @@ void NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -1875,14 +1875,14 @@ void NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
     // Push the number of atoms of the request
     // sdp_e2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     sdp_e2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, write 0x%x to sdp_e2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, write 0x%x to sdp_e2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1901,7 +1901,7 @@ void NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -1954,25 +1954,25 @@ void NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_\x0A"));
                     sdp_e_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_\x0A"));
                     sdp_e_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_\x0A"));
                     sdp_e_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(SDP_E_AXI_ID);
@@ -1983,14 +1983,14 @@ void NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
             FAIL(("NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, before sending data to sdp_e_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, before sending data to sdp_e_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         sdp_e_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, after sending data to sdp_e_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, after sending data to sdp_e_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::sdp_e2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2sdp_e() {
@@ -2004,9 +2004,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp_e() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = sdp_e2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, update atom_num_left from sdp_e2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, update atom_num_left from sdp_e2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -2016,7 +2016,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp_e() {
         // Aligen to 32B
         axi_atom_ptr = cvif2sdp_e_rd_rsp_fifo_->read();
         credit_cvif2sdp_e_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, read 1st atom of the 64B from cvif2sdp_e_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, read 1st atom of the 64B from cvif2sdp_e_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -2027,21 +2027,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2sdp_e() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2sdp_e_rd_rsp_fifo_->read();
             credit_cvif2sdp_e_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, read 2nd atom of the 64B from cvif2sdp_e_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, read 2nd atom of the 64B from cvif2sdp_e_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, before NV_NVDLA_cvif_base::cvif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, before NV_NVDLA_cvif_base::cvif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, after NV_NVDLA_cvif_base::cvif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2sdp_e, after NV_NVDLA_cvif_base::cvif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -2074,7 +2074,7 @@ void NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -2096,14 +2096,14 @@ void NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
     // Push the number of atoms of the request
     // cdma_dat2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     cdma_dat2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, write 0x%x to cdma_dat2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, write 0x%x to cdma_dat2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -2122,7 +2122,7 @@ void NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -2175,25 +2175,25 @@ void NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_\x0A"));
                     cdma_dat_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_\x0A"));
                     cdma_dat_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_\x0A"));
                     cdma_dat_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(CDMA_DAT_AXI_ID);
@@ -2204,14 +2204,14 @@ void NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
             FAIL(("NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, before sending data to cdma_dat_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, before sending data to cdma_dat_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         cdma_dat_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, after sending data to cdma_dat_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, after sending data to cdma_dat_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::cdma_dat2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2cdma_dat() {
@@ -2225,9 +2225,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2cdma_dat() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = cdma_dat2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, update atom_num_left from cdma_dat2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, update atom_num_left from cdma_dat2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -2237,7 +2237,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2cdma_dat() {
         // Aligen to 32B
         axi_atom_ptr = cvif2cdma_dat_rd_rsp_fifo_->read();
         credit_cvif2cdma_dat_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, read 1st atom of the 64B from cvif2cdma_dat_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, read 1st atom of the 64B from cvif2cdma_dat_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -2248,21 +2248,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2cdma_dat() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2cdma_dat_rd_rsp_fifo_->read();
             credit_cvif2cdma_dat_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, read 2nd atom of the 64B from cvif2cdma_dat_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, read 2nd atom of the 64B from cvif2cdma_dat_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, before NV_NVDLA_cvif_base::cvif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, before NV_NVDLA_cvif_base::cvif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, after NV_NVDLA_cvif_base::cvif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_dat, after NV_NVDLA_cvif_base::cvif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -2295,7 +2295,7 @@ void NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
     last_base_addr = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-    cslDebug((30, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, first_base_addr=0x%lx last_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, last_base_addr, total_axi_size, payload_addr, payload_size));
     // if ( total_axi_size <= (first_base_addr % (CVIF_MAX_MEM_TRANSACTION_SIZE)) ) {
     //     last_base_addr = first_base_addr;
     // } else if ((first_base_addr + total_axi_size)%CVIF_MAX_MEM_TRANSACTION_SIZE != 0) {
@@ -2317,14 +2317,14 @@ void NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
     // Push the number of atoms of the request
     // cdma_wt2cvif_rd_req_atom_num_fifo_->write(total_axi_size/DMA_TRANSACTION_ATOM_SIZE);
     cdma_wt2cvif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, write 0x%x to cdma_wt2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
+    //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, write 0x%x to cdma_wt2cvif_rd_req_atom_num_fifo_.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE));
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, before spliting DMA transaction\x0A"));
     while(cur_address <= last_base_addr) {
         base_addr    = cur_address;
         size_in_byte = AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -2343,7 +2343,7 @@ void NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
         }
         // start address of next axi transaction
         cur_address += AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, cur_address=0x%lx base_addr=0x%lx size_in_byte=0x%x\x0A", cur_address, base_addr, size_in_byte));
 
         // Allocating memory for dla_b_transport_payload
         bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -2396,25 +2396,25 @@ void NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
                 // Diable 1st DMA atom of the unaligned first_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_\x0A"));
                     cdma_wt_rd_atom_enable_fifo_->write(false);
                 }
             } else if (( (base_addr + size_in_byte) == (last_base_addr+AXI_TRANSACTION_ATOM_SIZE)) && (false == is_rear_64byte_align) && (byte_iter >= size_in_byte - DMA_TRANSACTION_ATOM_SIZE)) {
                 // Diable 2nd DMA atom of the unaligned last_base_addr
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_\x0A"));
                     cdma_wt_rd_atom_enable_fifo_->write(false);
                 }
             } else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_\x0A"));
                     cdma_wt_rd_atom_enable_fifo_->write(true);
                 }
             }
         }
-        cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, TLM_BYTE_ENABLE is done\x0A"));
         bt_payload->configure_gp(base_addr, size_in_byte, is_read);
         bt_payload->gp.get_extension(nvdla_dbb_ext);
         nvdla_dbb_ext->set_id(CDMA_WT_AXI_ID);
@@ -2425,14 +2425,14 @@ void NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
             FAIL(("NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
         }
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, before sending data to cdma_wt_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, before sending data to cdma_wt_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
         cdma_wt_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, after sending data to cdma_wt_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, after sending data to cdma_wt_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         // total_axi_size -= size_in_byte;
         // base_addr      += size_in_byte;
     }
-    cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::cdma_wt2cvif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_cvif::ReadResp_cvif2cdma_wt() {
@@ -2446,9 +2446,9 @@ void NV_NVDLA_cvif::ReadResp_cvif2cdma_wt() {
     while(true) {
         if(0 == atom_num_left) {
             atom_num_left = cdma_wt2cvif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, update atom_num_left from cdma_wt2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, update atom_num_left from cdma_wt2cvif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -2458,7 +2458,7 @@ void NV_NVDLA_cvif::ReadResp_cvif2cdma_wt() {
         // Aligen to 32B
         axi_atom_ptr = cvif2cdma_wt_rd_rsp_fifo_->read();
         credit_cvif2cdma_wt_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, read 1st atom of the 64B from cvif2cdma_wt_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, read 1st atom of the 64B from cvif2cdma_wt_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -2469,21 +2469,21 @@ void NV_NVDLA_cvif::ReadResp_cvif2cdma_wt() {
             // 2nd atom of the 64B
             axi_atom_ptr = cvif2cdma_wt_rd_rsp_fifo_->read();
             credit_cvif2cdma_wt_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, read 2nd atom of the 64B from cvif2cdma_wt_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, read 2nd atom of the 64B from cvif2cdma_wt_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, before NV_NVDLA_cvif_base::cvif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, before NV_NVDLA_cvif_base::cvif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_cvif_base::cvif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, after NV_NVDLA_cvif_base::cvif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::ReadResp_cvif2cdma_wt, after NV_NVDLA_cvif_base::cvif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -2513,9 +2513,9 @@ void NV_NVDLA_cvif::bdma2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* pay
         bdma_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         bdma_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         bdma_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "before write to bdma2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "before write to bdma2cvif_wr_cmd_fifo_\x0A"));
         bdma2cvif_wr_cmd_fifo_->write(bdma_wr_req);
-        cslDebug((50, "after write to bdma2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "after write to bdma2cvif_wr_cmd_fifo_\x0A"));
         bdma_wr_req_got_size_ = 0;
         bdma_wr_req_size_ = bdma_wr_req->size;
 
@@ -2525,23 +2525,23 @@ void NV_NVDLA_cvif::bdma2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* pay
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "before write to bdma2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "before write to bdma2cvif_wr_data_fifo_\x0A"));
         bdma2cvif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
-        cslDebug((50, "after write to bdma2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "after write to bdma2cvif_wr_data_fifo_\x0A"));
         bdma_wr_req_got_size_ += incoming_size;
         for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
+            //cslDebug((50, "%x ", data_ptr[i]));
         }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "\x0A"));
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to bdma2cvif_wr_data_fifo_\x0A"));
+            //cslDebug((50, "write to bdma2cvif_wr_data_fifo_\x0A"));
             bdma2cvif_wr_data_fifo_->write(data_ptr);
             for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
+                //cslDebug((50, "%x ", data_ptr[i]));
             }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "\x0A"));
         }
 
         if (bdma_wr_req_got_size_ == bdma_wr_req_size_) {
@@ -2576,9 +2576,9 @@ void NV_NVDLA_cvif::WriteRequest_bdma2cvif() {
         bdma_wr_req = bdma2cvif_wr_cmd_fifo_->read();
         payload_addr = bdma_wr_req->addr;   // It's aligend to 32B, not 64B
         payload_size = bdma_wr_req->size;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, got one write command from bdma2cvif_wr_cmd_fifo_\x0A"));
-        cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
-        cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, got one write command from bdma2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
+        //cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
 
         is_base_64byte_align = payload_addr%AXI_TRANSACTION_ATOM_SIZE == 0;
         first_base_addr = is_base_64byte_align? payload_addr: payload_addr - DMA_TRANSACTION_ATOM_SIZE; // Align to 64B
@@ -2611,10 +2611,10 @@ void NV_NVDLA_cvif::WriteRequest_bdma2cvif() {
         //         last_base_addr = first_base_addr;
         //     }
         // }
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif:\x0A"));
-        cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
-        cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
-        cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif:\x0A"));
+        //cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
+        //cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
+        //cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
 
         // cur_address = payload_addr;
         cur_address = is_base_64byte_align? payload_addr: first_base_addr; // Align to 64B
@@ -2639,7 +2639,7 @@ void NV_NVDLA_cvif::WriteRequest_bdma2cvif() {
 
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
             axi_byte_enable_ptr = bt_payload->gp.get_byte_enable_ptr();
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
 
             for (byte_iter=0; byte_iter < size_in_byte; byte_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE)) {
@@ -2652,7 +2652,7 @@ void NV_NVDLA_cvif::WriteRequest_bdma2cvif() {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 }
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, TLM_BYTE_ENABLE is done\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, TLM_BYTE_ENABLE is done\x0A"));
 
             for (atom_iter=0; atom_iter < atom_num; atom_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (0 == atom_iter)) {
@@ -2663,14 +2663,14 @@ void NV_NVDLA_cvif::WriteRequest_bdma2cvif() {
                     // Disable 2nd DMA atom of the unaligned last_base_addr
                     memset(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], 0, DMA_TRANSACTION_ATOM_SIZE);
                 } else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, before read an atom from bdma2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, before read an atom from bdma2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
 
                     axi_atom_ptr = bdma2cvif_wr_data_fifo_->read();
                     for(int i=0; i<DMA_TRANSACTION_ATOM_SIZE; i++) {
-                        cslDebug((50, "%02x ", axi_atom_ptr[i]));
+                        //cslDebug((50, "%02x ", axi_atom_ptr[i]));
                     }
-                    cslDebug((50, "\x0A"));
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, after read an atom from bdma2cvif_wr_data_fifo_\x0A"));
+                    //cslDebug((50, "\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, after read an atom from bdma2cvif_wr_data_fifo_\x0A"));
                     memcpy(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
                     delete[] axi_atom_ptr;
                 }
@@ -2679,13 +2679,13 @@ void NV_NVDLA_cvif::WriteRequest_bdma2cvif() {
             if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) ) {
                 base_addr += DMA_TRANSACTION_ATOM_SIZE;
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, sending write command to bdma_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, sending write command to bdma_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(BDMA_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -2700,21 +2700,21 @@ void NV_NVDLA_cvif::WriteRequest_bdma2cvif() {
             // When the last split req is sent to ext, write true to bdma_wr_required_ack_fifo_ when ack is required.
             if (cur_address >= (payload_addr + payload_size)) {
                 if(bdma_wr_req->require_ack!=0) {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, require ack.\x0A"));
                     bdma_wr_required_ack_fifo_->write(true);
                 }
                 else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, does not require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, does not require ack.\x0A"));
                     bdma_wr_required_ack_fifo_->write(false);
                 }
             }
             else {
-                cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, does not require ack.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, does not require ack.\x0A"));
                 bdma_wr_required_ack_fifo_->write(false);
             }
         }
         delete bdma_wr_req;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, write command processing done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_bdma2cvif, write command processing done\x0A"));
     }
 }
 
@@ -2741,9 +2741,9 @@ void NV_NVDLA_cvif::sdp2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         sdp_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         sdp_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         sdp_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "before write to sdp2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "before write to sdp2cvif_wr_cmd_fifo_\x0A"));
         sdp2cvif_wr_cmd_fifo_->write(sdp_wr_req);
-        cslDebug((50, "after write to sdp2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "after write to sdp2cvif_wr_cmd_fifo_\x0A"));
         sdp_wr_req_got_size_ = 0;
         sdp_wr_req_size_ = sdp_wr_req->size;
 
@@ -2753,23 +2753,23 @@ void NV_NVDLA_cvif::sdp2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "before write to sdp2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "before write to sdp2cvif_wr_data_fifo_\x0A"));
         sdp2cvif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
-        cslDebug((50, "after write to sdp2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "after write to sdp2cvif_wr_data_fifo_\x0A"));
         sdp_wr_req_got_size_ += incoming_size;
         for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
+            //cslDebug((50, "%x ", data_ptr[i]));
         }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "\x0A"));
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to sdp2cvif_wr_data_fifo_\x0A"));
+            //cslDebug((50, "write to sdp2cvif_wr_data_fifo_\x0A"));
             sdp2cvif_wr_data_fifo_->write(data_ptr);
             for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
+                //cslDebug((50, "%x ", data_ptr[i]));
             }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "\x0A"));
         }
 
         if (sdp_wr_req_got_size_ == sdp_wr_req_size_) {
@@ -2804,9 +2804,9 @@ void NV_NVDLA_cvif::WriteRequest_sdp2cvif() {
         sdp_wr_req = sdp2cvif_wr_cmd_fifo_->read();
         payload_addr = sdp_wr_req->addr;   // It's aligend to 32B, not 64B
         payload_size = sdp_wr_req->size;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, got one write command from sdp2cvif_wr_cmd_fifo_\x0A"));
-        cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
-        cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, got one write command from sdp2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
+        //cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
 
         is_base_64byte_align = payload_addr%AXI_TRANSACTION_ATOM_SIZE == 0;
         first_base_addr = is_base_64byte_align? payload_addr: payload_addr - DMA_TRANSACTION_ATOM_SIZE; // Align to 64B
@@ -2839,10 +2839,10 @@ void NV_NVDLA_cvif::WriteRequest_sdp2cvif() {
         //         last_base_addr = first_base_addr;
         //     }
         // }
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif:\x0A"));
-        cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
-        cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
-        cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif:\x0A"));
+        //cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
+        //cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
+        //cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
 
         // cur_address = payload_addr;
         cur_address = is_base_64byte_align? payload_addr: first_base_addr; // Align to 64B
@@ -2867,7 +2867,7 @@ void NV_NVDLA_cvif::WriteRequest_sdp2cvif() {
 
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
             axi_byte_enable_ptr = bt_payload->gp.get_byte_enable_ptr();
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
 
             for (byte_iter=0; byte_iter < size_in_byte; byte_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE)) {
@@ -2880,7 +2880,7 @@ void NV_NVDLA_cvif::WriteRequest_sdp2cvif() {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 }
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, TLM_BYTE_ENABLE is done\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, TLM_BYTE_ENABLE is done\x0A"));
 
             for (atom_iter=0; atom_iter < atom_num; atom_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (0 == atom_iter)) {
@@ -2891,14 +2891,14 @@ void NV_NVDLA_cvif::WriteRequest_sdp2cvif() {
                     // Disable 2nd DMA atom of the unaligned last_base_addr
                     memset(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], 0, DMA_TRANSACTION_ATOM_SIZE);
                 } else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, before read an atom from sdp2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, before read an atom from sdp2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
 
                     axi_atom_ptr = sdp2cvif_wr_data_fifo_->read();
                     for(int i=0; i<DMA_TRANSACTION_ATOM_SIZE; i++) {
-                        cslDebug((50, "%02x ", axi_atom_ptr[i]));
+                        //cslDebug((50, "%02x ", axi_atom_ptr[i]));
                     }
-                    cslDebug((50, "\x0A"));
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, after read an atom from sdp2cvif_wr_data_fifo_\x0A"));
+                    //cslDebug((50, "\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, after read an atom from sdp2cvif_wr_data_fifo_\x0A"));
                     memcpy(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
                     delete[] axi_atom_ptr;
                 }
@@ -2907,13 +2907,13 @@ void NV_NVDLA_cvif::WriteRequest_sdp2cvif() {
             if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) ) {
                 base_addr += DMA_TRANSACTION_ATOM_SIZE;
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, sending write command to sdp_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, sending write command to sdp_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(SDP_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -2928,21 +2928,21 @@ void NV_NVDLA_cvif::WriteRequest_sdp2cvif() {
             // When the last split req is sent to ext, write true to sdp_wr_required_ack_fifo_ when ack is required.
             if (cur_address >= (payload_addr + payload_size)) {
                 if(sdp_wr_req->require_ack!=0) {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, require ack.\x0A"));
                     sdp_wr_required_ack_fifo_->write(true);
                 }
                 else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, does not require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, does not require ack.\x0A"));
                     sdp_wr_required_ack_fifo_->write(false);
                 }
             }
             else {
-                cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, does not require ack.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, does not require ack.\x0A"));
                 sdp_wr_required_ack_fifo_->write(false);
             }
         }
         delete sdp_wr_req;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, write command processing done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_sdp2cvif, write command processing done\x0A"));
     }
 }
 
@@ -2969,9 +2969,9 @@ void NV_NVDLA_cvif::pdp2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         pdp_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         pdp_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         pdp_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "before write to pdp2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "before write to pdp2cvif_wr_cmd_fifo_\x0A"));
         pdp2cvif_wr_cmd_fifo_->write(pdp_wr_req);
-        cslDebug((50, "after write to pdp2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "after write to pdp2cvif_wr_cmd_fifo_\x0A"));
         pdp_wr_req_got_size_ = 0;
         pdp_wr_req_size_ = pdp_wr_req->size;
 
@@ -2981,23 +2981,23 @@ void NV_NVDLA_cvif::pdp2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "before write to pdp2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "before write to pdp2cvif_wr_data_fifo_\x0A"));
         pdp2cvif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
-        cslDebug((50, "after write to pdp2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "after write to pdp2cvif_wr_data_fifo_\x0A"));
         pdp_wr_req_got_size_ += incoming_size;
         for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
+            //cslDebug((50, "%x ", data_ptr[i]));
         }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "\x0A"));
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to pdp2cvif_wr_data_fifo_\x0A"));
+            //cslDebug((50, "write to pdp2cvif_wr_data_fifo_\x0A"));
             pdp2cvif_wr_data_fifo_->write(data_ptr);
             for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
+                //cslDebug((50, "%x ", data_ptr[i]));
             }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "\x0A"));
         }
 
         if (pdp_wr_req_got_size_ == pdp_wr_req_size_) {
@@ -3032,9 +3032,9 @@ void NV_NVDLA_cvif::WriteRequest_pdp2cvif() {
         pdp_wr_req = pdp2cvif_wr_cmd_fifo_->read();
         payload_addr = pdp_wr_req->addr;   // It's aligend to 32B, not 64B
         payload_size = pdp_wr_req->size;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, got one write command from pdp2cvif_wr_cmd_fifo_\x0A"));
-        cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
-        cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, got one write command from pdp2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
+        //cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
 
         is_base_64byte_align = payload_addr%AXI_TRANSACTION_ATOM_SIZE == 0;
         first_base_addr = is_base_64byte_align? payload_addr: payload_addr - DMA_TRANSACTION_ATOM_SIZE; // Align to 64B
@@ -3067,10 +3067,10 @@ void NV_NVDLA_cvif::WriteRequest_pdp2cvif() {
         //         last_base_addr = first_base_addr;
         //     }
         // }
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif:\x0A"));
-        cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
-        cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
-        cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif:\x0A"));
+        //cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
+        //cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
+        //cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
 
         // cur_address = payload_addr;
         cur_address = is_base_64byte_align? payload_addr: first_base_addr; // Align to 64B
@@ -3095,7 +3095,7 @@ void NV_NVDLA_cvif::WriteRequest_pdp2cvif() {
 
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
             axi_byte_enable_ptr = bt_payload->gp.get_byte_enable_ptr();
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
 
             for (byte_iter=0; byte_iter < size_in_byte; byte_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE)) {
@@ -3108,7 +3108,7 @@ void NV_NVDLA_cvif::WriteRequest_pdp2cvif() {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 }
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, TLM_BYTE_ENABLE is done\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, TLM_BYTE_ENABLE is done\x0A"));
 
             for (atom_iter=0; atom_iter < atom_num; atom_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (0 == atom_iter)) {
@@ -3119,14 +3119,14 @@ void NV_NVDLA_cvif::WriteRequest_pdp2cvif() {
                     // Disable 2nd DMA atom of the unaligned last_base_addr
                     memset(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], 0, DMA_TRANSACTION_ATOM_SIZE);
                 } else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, before read an atom from pdp2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, before read an atom from pdp2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
 
                     axi_atom_ptr = pdp2cvif_wr_data_fifo_->read();
                     for(int i=0; i<DMA_TRANSACTION_ATOM_SIZE; i++) {
-                        cslDebug((50, "%02x ", axi_atom_ptr[i]));
+                        //cslDebug((50, "%02x ", axi_atom_ptr[i]));
                     }
-                    cslDebug((50, "\x0A"));
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, after read an atom from pdp2cvif_wr_data_fifo_\x0A"));
+                    //cslDebug((50, "\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, after read an atom from pdp2cvif_wr_data_fifo_\x0A"));
                     memcpy(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
                     delete[] axi_atom_ptr;
                 }
@@ -3135,13 +3135,13 @@ void NV_NVDLA_cvif::WriteRequest_pdp2cvif() {
             if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) ) {
                 base_addr += DMA_TRANSACTION_ATOM_SIZE;
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, sending write command to pdp_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, sending write command to pdp_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(PDP_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -3156,21 +3156,21 @@ void NV_NVDLA_cvif::WriteRequest_pdp2cvif() {
             // When the last split req is sent to ext, write true to pdp_wr_required_ack_fifo_ when ack is required.
             if (cur_address >= (payload_addr + payload_size)) {
                 if(pdp_wr_req->require_ack!=0) {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, require ack.\x0A"));
                     pdp_wr_required_ack_fifo_->write(true);
                 }
                 else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, does not require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, does not require ack.\x0A"));
                     pdp_wr_required_ack_fifo_->write(false);
                 }
             }
             else {
-                cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, does not require ack.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, does not require ack.\x0A"));
                 pdp_wr_required_ack_fifo_->write(false);
             }
         }
         delete pdp_wr_req;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, write command processing done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_pdp2cvif, write command processing done\x0A"));
     }
 }
 
@@ -3197,9 +3197,9 @@ void NV_NVDLA_cvif::cdp2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         cdp_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         cdp_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         cdp_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "before write to cdp2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "before write to cdp2cvif_wr_cmd_fifo_\x0A"));
         cdp2cvif_wr_cmd_fifo_->write(cdp_wr_req);
-        cslDebug((50, "after write to cdp2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "after write to cdp2cvif_wr_cmd_fifo_\x0A"));
         cdp_wr_req_got_size_ = 0;
         cdp_wr_req_size_ = cdp_wr_req->size;
 
@@ -3209,23 +3209,23 @@ void NV_NVDLA_cvif::cdp2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "before write to cdp2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "before write to cdp2cvif_wr_data_fifo_\x0A"));
         cdp2cvif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
-        cslDebug((50, "after write to cdp2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "after write to cdp2cvif_wr_data_fifo_\x0A"));
         cdp_wr_req_got_size_ += incoming_size;
         for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
+            //cslDebug((50, "%x ", data_ptr[i]));
         }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "\x0A"));
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to cdp2cvif_wr_data_fifo_\x0A"));
+            //cslDebug((50, "write to cdp2cvif_wr_data_fifo_\x0A"));
             cdp2cvif_wr_data_fifo_->write(data_ptr);
             for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
+                //cslDebug((50, "%x ", data_ptr[i]));
             }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "\x0A"));
         }
 
         if (cdp_wr_req_got_size_ == cdp_wr_req_size_) {
@@ -3260,9 +3260,9 @@ void NV_NVDLA_cvif::WriteRequest_cdp2cvif() {
         cdp_wr_req = cdp2cvif_wr_cmd_fifo_->read();
         payload_addr = cdp_wr_req->addr;   // It's aligend to 32B, not 64B
         payload_size = cdp_wr_req->size;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, got one write command from cdp2cvif_wr_cmd_fifo_\x0A"));
-        cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
-        cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, got one write command from cdp2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
+        //cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
 
         is_base_64byte_align = payload_addr%AXI_TRANSACTION_ATOM_SIZE == 0;
         first_base_addr = is_base_64byte_align? payload_addr: payload_addr - DMA_TRANSACTION_ATOM_SIZE; // Align to 64B
@@ -3295,10 +3295,10 @@ void NV_NVDLA_cvif::WriteRequest_cdp2cvif() {
         //         last_base_addr = first_base_addr;
         //     }
         // }
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif:\x0A"));
-        cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
-        cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
-        cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif:\x0A"));
+        //cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
+        //cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
+        //cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
 
         // cur_address = payload_addr;
         cur_address = is_base_64byte_align? payload_addr: first_base_addr; // Align to 64B
@@ -3323,7 +3323,7 @@ void NV_NVDLA_cvif::WriteRequest_cdp2cvif() {
 
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
             axi_byte_enable_ptr = bt_payload->gp.get_byte_enable_ptr();
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
 
             for (byte_iter=0; byte_iter < size_in_byte; byte_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE)) {
@@ -3336,7 +3336,7 @@ void NV_NVDLA_cvif::WriteRequest_cdp2cvif() {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 }
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, TLM_BYTE_ENABLE is done\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, TLM_BYTE_ENABLE is done\x0A"));
 
             for (atom_iter=0; atom_iter < atom_num; atom_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (0 == atom_iter)) {
@@ -3347,14 +3347,14 @@ void NV_NVDLA_cvif::WriteRequest_cdp2cvif() {
                     // Disable 2nd DMA atom of the unaligned last_base_addr
                     memset(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], 0, DMA_TRANSACTION_ATOM_SIZE);
                 } else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, before read an atom from cdp2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, before read an atom from cdp2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
 
                     axi_atom_ptr = cdp2cvif_wr_data_fifo_->read();
                     for(int i=0; i<DMA_TRANSACTION_ATOM_SIZE; i++) {
-                        cslDebug((50, "%02x ", axi_atom_ptr[i]));
+                        //cslDebug((50, "%02x ", axi_atom_ptr[i]));
                     }
-                    cslDebug((50, "\x0A"));
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, after read an atom from cdp2cvif_wr_data_fifo_\x0A"));
+                    //cslDebug((50, "\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, after read an atom from cdp2cvif_wr_data_fifo_\x0A"));
                     memcpy(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
                     delete[] axi_atom_ptr;
                 }
@@ -3363,13 +3363,13 @@ void NV_NVDLA_cvif::WriteRequest_cdp2cvif() {
             if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) ) {
                 base_addr += DMA_TRANSACTION_ATOM_SIZE;
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, sending write command to cdp_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, sending write command to cdp_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(CDP_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -3384,21 +3384,21 @@ void NV_NVDLA_cvif::WriteRequest_cdp2cvif() {
             // When the last split req is sent to ext, write true to cdp_wr_required_ack_fifo_ when ack is required.
             if (cur_address >= (payload_addr + payload_size)) {
                 if(cdp_wr_req->require_ack!=0) {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, require ack.\x0A"));
                     cdp_wr_required_ack_fifo_->write(true);
                 }
                 else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, does not require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, does not require ack.\x0A"));
                     cdp_wr_required_ack_fifo_->write(false);
                 }
             }
             else {
-                cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, does not require ack.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, does not require ack.\x0A"));
                 cdp_wr_required_ack_fifo_->write(false);
             }
         }
         delete cdp_wr_req;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, write command processing done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_cdp2cvif, write command processing done\x0A"));
     }
 }
 
@@ -3425,9 +3425,9 @@ void NV_NVDLA_cvif::rbk2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         rbk_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         rbk_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         rbk_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "before write to rbk2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "before write to rbk2cvif_wr_cmd_fifo_\x0A"));
         rbk2cvif_wr_cmd_fifo_->write(rbk_wr_req);
-        cslDebug((50, "after write to rbk2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "after write to rbk2cvif_wr_cmd_fifo_\x0A"));
         rbk_wr_req_got_size_ = 0;
         rbk_wr_req_size_ = rbk_wr_req->size;
 
@@ -3437,23 +3437,23 @@ void NV_NVDLA_cvif::rbk2cvif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "before write to rbk2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "before write to rbk2cvif_wr_data_fifo_\x0A"));
         rbk2cvif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
-        cslDebug((50, "after write to rbk2cvif_wr_data_fifo_\x0A"));
+        //cslDebug((50, "after write to rbk2cvif_wr_data_fifo_\x0A"));
         rbk_wr_req_got_size_ += incoming_size;
         for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
+            //cslDebug((50, "%x ", data_ptr[i]));
         }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "\x0A"));
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to rbk2cvif_wr_data_fifo_\x0A"));
+            //cslDebug((50, "write to rbk2cvif_wr_data_fifo_\x0A"));
             rbk2cvif_wr_data_fifo_->write(data_ptr);
             for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
+                //cslDebug((50, "%x ", data_ptr[i]));
             }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "\x0A"));
         }
 
         if (rbk_wr_req_got_size_ == rbk_wr_req_size_) {
@@ -3488,9 +3488,9 @@ void NV_NVDLA_cvif::WriteRequest_rbk2cvif() {
         rbk_wr_req = rbk2cvif_wr_cmd_fifo_->read();
         payload_addr = rbk_wr_req->addr;   // It's aligend to 32B, not 64B
         payload_size = rbk_wr_req->size;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, got one write command from rbk2cvif_wr_cmd_fifo_\x0A"));
-        cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
-        cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, got one write command from rbk2cvif_wr_cmd_fifo_\x0A"));
+        //cslDebug((50, "    payload_addr: 0x%lx\x0A", payload_addr));
+        //cslDebug((50, "    payload_size: 0x%x\x0A", payload_size));
 
         is_base_64byte_align = payload_addr%AXI_TRANSACTION_ATOM_SIZE == 0;
         first_base_addr = is_base_64byte_align? payload_addr: payload_addr - DMA_TRANSACTION_ATOM_SIZE; // Align to 64B
@@ -3523,10 +3523,10 @@ void NV_NVDLA_cvif::WriteRequest_rbk2cvif() {
         //         last_base_addr = first_base_addr;
         //     }
         // }
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif:\x0A"));
-        cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
-        cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
-        cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif:\x0A"));
+        //cslDebug((50, "    first_base_addr: 0x%lx\x0A", first_base_addr));
+        //cslDebug((50, "    last_base_addr: 0x%lx\x0A", last_base_addr));
+        //cslDebug((50, "    total_axi_size: 0x%x\x0A", total_axi_size));
 
         // cur_address = payload_addr;
         cur_address = is_base_64byte_align? payload_addr: first_base_addr; // Align to 64B
@@ -3551,7 +3551,7 @@ void NV_NVDLA_cvif::WriteRequest_rbk2cvif() {
 
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
             axi_byte_enable_ptr = bt_payload->gp.get_byte_enable_ptr();
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, base_addr=0x%lx size_in_byte=0x%x atom_num=0x%x\x0A", base_addr, size_in_byte, atom_num));
 
             for (byte_iter=0; byte_iter < size_in_byte; byte_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE)) {
@@ -3564,7 +3564,7 @@ void NV_NVDLA_cvif::WriteRequest_rbk2cvif() {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;  // All bytes should be enabled
                 }
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, TLM_BYTE_ENABLE is done\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, TLM_BYTE_ENABLE is done\x0A"));
 
             for (atom_iter=0; atom_iter < atom_num; atom_iter++) {
                 if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) && (0 == atom_iter)) {
@@ -3575,14 +3575,14 @@ void NV_NVDLA_cvif::WriteRequest_rbk2cvif() {
                     // Disable 2nd DMA atom of the unaligned last_base_addr
                     memset(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], 0, DMA_TRANSACTION_ATOM_SIZE);
                 } else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, before read an atom from rbk2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, before read an atom from rbk2cvif_wr_data_fifo_, base_addr = 0x%lx, atom_iter=0x%x\x0A", base_addr, atom_iter));
 
                     axi_atom_ptr = rbk2cvif_wr_data_fifo_->read();
                     for(int i=0; i<DMA_TRANSACTION_ATOM_SIZE; i++) {
-                        cslDebug((50, "%02x ", axi_atom_ptr[i]));
+                        //cslDebug((50, "%02x ", axi_atom_ptr[i]));
                     }
-                    cslDebug((50, "\x0A"));
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, after read an atom from rbk2cvif_wr_data_fifo_\x0A"));
+                    //cslDebug((50, "\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, after read an atom from rbk2cvif_wr_data_fifo_\x0A"));
                     memcpy(&bt_payload->data[atom_iter*DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
                     delete[] axi_atom_ptr;
                 }
@@ -3591,13 +3591,13 @@ void NV_NVDLA_cvif::WriteRequest_rbk2cvif() {
             if ( (base_addr == first_base_addr) && (false == is_base_64byte_align) ) {
                 base_addr += DMA_TRANSACTION_ATOM_SIZE;
             }
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, base_address=0x%lx size in byte=0x%x\x0A", base_addr, size_in_byte));
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, sending write command to rbk_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, sending write command to rbk_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%016lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(RBK_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -3612,21 +3612,21 @@ void NV_NVDLA_cvif::WriteRequest_rbk2cvif() {
             // When the last split req is sent to ext, write true to rbk_wr_required_ack_fifo_ when ack is required.
             if (cur_address >= (payload_addr + payload_size)) {
                 if(rbk_wr_req->require_ack!=0) {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, require ack.\x0A"));
                     rbk_wr_required_ack_fifo_->write(true);
                 }
                 else {
-                    cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, does not require ack.\x0A"));
+                    //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, does not require ack.\x0A"));
                     rbk_wr_required_ack_fifo_->write(false);
                 }
             }
             else {
-                cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, does not require ack.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, does not require ack.\x0A"));
                 rbk_wr_required_ack_fifo_->write(false);
             }
         }
         delete rbk_wr_req;
-        cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, write command processing done\x0A"));
+        //cslDebug((50, "NV_NVDLA_cvif::WriteRequest_rbk2cvif, write command processing done\x0A"));
     }
 }
 
@@ -3658,11 +3658,11 @@ void NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
     axi_length             =  tlm_gp.get_data_length();  // axi_length is max 256B for CVIF
     axi_byte_enable_ptr    =  tlm_gp.get_byte_enable_ptr();
     axi_byte_enable_length =  tlm_gp.get_byte_enable_length();
-    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport\x0A"));
-    cslDebug((50, "axi_data_ptr: 0x%p\x0A", (void *) axi_data_ptr));
-    cslDebug((50, "axi_length: %d\x0A", axi_length));
-    cslDebug((50, "axi_byte_enable_ptr: 0x%p\x0A", (void *) axi_byte_enable_ptr));
-    cslDebug((50, "axi_byte_enable_length: %d\x0A", axi_byte_enable_length));
+    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport\x0A"));
+    //cslDebug((50, "axi_data_ptr: 0x%p\x0A", (void *) axi_data_ptr));
+    //cslDebug((50, "axi_length: %d\x0A", axi_length));
+    //cslDebug((50, "axi_byte_enable_ptr: 0x%p\x0A", (void *) axi_byte_enable_ptr));
+    //cslDebug((50, "axi_byte_enable_length: %d\x0A", axi_byte_enable_length));
     axi_id                 =  nvdla_dbb_ext->get_id();
 
     // Data from general payload
@@ -3680,48 +3680,48 @@ void NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
     //  Parsing AXI payload and generating DMA response payloads
     dma_sent_size = 0;
     for (dma_sent_size = 0; dma_sent_size < axi_length; dma_sent_size += DMA_TRANSACTION_ATOM_SIZE) {
-        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, dma_sent_size: 0x%x\x0A", dma_sent_size));
+        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, dma_sent_size: 0x%x\x0A", dma_sent_size));
         switch (axi_id) {
 
            case BDMA_AXI_ID:
                     dma_payload_atom_mask = (true == bdma_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read bdma_rd_atom_enable_fifo_, bdma payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read bdma_rd_atom_enable_fifo_, bdma payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case SDP_AXI_ID:
                     dma_payload_atom_mask = (true == sdp_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read sdp_rd_atom_enable_fifo_, sdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read sdp_rd_atom_enable_fifo_, sdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case PDP_AXI_ID:
                     dma_payload_atom_mask = (true == pdp_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read pdp_rd_atom_enable_fifo_, pdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read pdp_rd_atom_enable_fifo_, pdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case CDP_AXI_ID:
                     dma_payload_atom_mask = (true == cdp_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read cdp_rd_atom_enable_fifo_, cdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read cdp_rd_atom_enable_fifo_, cdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case RBK_AXI_ID:
                     dma_payload_atom_mask = (true == rbk_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read rbk_rd_atom_enable_fifo_, rbk payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read rbk_rd_atom_enable_fifo_, rbk payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case SDP_B_AXI_ID:
                     dma_payload_atom_mask = (true == sdp_b_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read sdp_b_rd_atom_enable_fifo_, sdp_b payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read sdp_b_rd_atom_enable_fifo_, sdp_b payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case SDP_N_AXI_ID:
                     dma_payload_atom_mask = (true == sdp_n_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read sdp_n_rd_atom_enable_fifo_, sdp_n payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read sdp_n_rd_atom_enable_fifo_, sdp_n payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case SDP_E_AXI_ID:
                     dma_payload_atom_mask = (true == sdp_e_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read sdp_e_rd_atom_enable_fifo_, sdp_e payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read sdp_e_rd_atom_enable_fifo_, sdp_e payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case CDMA_DAT_AXI_ID:
                     dma_payload_atom_mask = (true == cdma_dat_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read cdma_dat_rd_atom_enable_fifo_, cdma_dat payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read cdma_dat_rd_atom_enable_fifo_, cdma_dat payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case CDMA_WT_AXI_ID:
                     dma_payload_atom_mask = (true == cdma_wt_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read cdma_wt_rd_atom_enable_fifo_, cdma_wt payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, read cdma_wt_rd_atom_enable_fifo_, cdma_wt payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
 
 #pragma CTC SKIP
@@ -3736,84 +3736,84 @@ void NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
             switch (axi_id) {
 
                  case BDMA_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2bdma_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, bdma payload atom mask is 0x1, write an atom to cvif2bdma_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, bdma payload atom mask is 0x1, write an atom to cvif2bdma_rd_rsp_fifo_.\x0A"));
                     break;
                  case SDP_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2sdp_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, sdp payload atom mask is 0x1, write an atom to cvif2sdp_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, sdp payload atom mask is 0x1, write an atom to cvif2sdp_rd_rsp_fifo_.\x0A"));
                     break;
                  case PDP_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2pdp_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, pdp payload atom mask is 0x1, write an atom to cvif2pdp_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, pdp payload atom mask is 0x1, write an atom to cvif2pdp_rd_rsp_fifo_.\x0A"));
                     break;
                  case CDP_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2cdp_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, cdp payload atom mask is 0x1, write an atom to cvif2cdp_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, cdp payload atom mask is 0x1, write an atom to cvif2cdp_rd_rsp_fifo_.\x0A"));
                     break;
                  case RBK_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2rbk_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, rbk payload atom mask is 0x1, write an atom to cvif2rbk_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, rbk payload atom mask is 0x1, write an atom to cvif2rbk_rd_rsp_fifo_.\x0A"));
                     break;
                  case SDP_B_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2sdp_b_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, sdp_b payload atom mask is 0x1, write an atom to cvif2sdp_b_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, sdp_b payload atom mask is 0x1, write an atom to cvif2sdp_b_rd_rsp_fifo_.\x0A"));
                     break;
                  case SDP_N_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2sdp_n_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, sdp_n payload atom mask is 0x1, write an atom to cvif2sdp_n_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, sdp_n payload atom mask is 0x1, write an atom to cvif2sdp_n_rd_rsp_fifo_.\x0A"));
                     break;
                  case SDP_E_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2sdp_e_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, sdp_e payload atom mask is 0x1, write an atom to cvif2sdp_e_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, sdp_e payload atom mask is 0x1, write an atom to cvif2sdp_e_rd_rsp_fifo_.\x0A"));
                     break;
                  case CDMA_DAT_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2cdma_dat_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, cdma_dat payload atom mask is 0x1, write an atom to cvif2cdma_dat_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, cdma_dat payload atom mask is 0x1, write an atom to cvif2cdma_dat_rd_rsp_fifo_.\x0A"));
                     break;
                  case CDMA_WT_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
+                        //cslDebug((70, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, axi_atom_ptr value:\x0A"));
                         for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
                         }
                         cvif2cdma_wt_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, cdma_wt payload atom mask is 0x1, write an atom to cvif2cdma_wt_rd_rsp_fifo_.\x0A"));
+                        //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, cdma_wt payload atom mask is 0x1, write an atom to cvif2cdma_wt_rd_rsp_fifo_.\x0A"));
                     break;
 
 #pragma CTC SKIP
@@ -3822,7 +3822,7 @@ void NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
 #pragma CTC ENDSKIP
             }
         } else {
-            cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, {client} payload atom mask is 0x0, ignore current atom, dma_payload_atom_mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+            //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport, {client} payload atom mask is 0x0, ignore current atom, dma_payload_atom_mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
         }
     }
 
@@ -3832,7 +3832,7 @@ void NV_NVDLA_cvif::ext2cvif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
 void NV_NVDLA_cvif::ext2cvif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload& tlm_gp, sc_time& delay) {
     uint8_t             axi_id;
     nvdla_dbb_extension *nvdla_dbb_ext = NULL;
-    cslDebug((50, "NV_NVDLA_cvif::ext2cvif_wr_rsp_b_transport.\x0A"));
+    //cslDebug((50, "NV_NVDLA_cvif::ext2cvif_wr_rsp_b_transport.\x0A"));
 
     // Get DBB extension
     tlm_gp.get_extension(nvdla_dbb_ext);
@@ -3850,7 +3850,7 @@ void NV_NVDLA_cvif::ext2cvif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             // Read a new reques id from fifo
             bdma_wr_req_expected_ack = bdma_wr_required_ack_fifo_->read();
             if (true == bdma_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to bdma\x0A"));
+                //cslDebug((50, "send wr rsp to bdma\x0A"));
                 //FIXME(skip-t194): we can add assertion bdma_wr_rsp_count_ == bdma_wr_cmd_count_fifo_->read 
                 NV_NVDLA_cvif_base::cvif2bdma_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -3865,7 +3865,7 @@ void NV_NVDLA_cvif::ext2cvif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             // Read a new reques id from fifo
             sdp_wr_req_expected_ack = sdp_wr_required_ack_fifo_->read();
             if (true == sdp_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to sdp\x0A"));
+                //cslDebug((50, "send wr rsp to sdp\x0A"));
                 //FIXME(skip-t194): we can add assertion sdp_wr_rsp_count_ == sdp_wr_cmd_count_fifo_->read 
                 NV_NVDLA_cvif_base::cvif2sdp_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -3880,7 +3880,7 @@ void NV_NVDLA_cvif::ext2cvif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             // Read a new reques id from fifo
             pdp_wr_req_expected_ack = pdp_wr_required_ack_fifo_->read();
             if (true == pdp_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to pdp\x0A"));
+                //cslDebug((50, "send wr rsp to pdp\x0A"));
                 //FIXME(skip-t194): we can add assertion pdp_wr_rsp_count_ == pdp_wr_cmd_count_fifo_->read 
                 NV_NVDLA_cvif_base::cvif2pdp_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -3895,7 +3895,7 @@ void NV_NVDLA_cvif::ext2cvif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             // Read a new reques id from fifo
             cdp_wr_req_expected_ack = cdp_wr_required_ack_fifo_->read();
             if (true == cdp_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to cdp\x0A"));
+                //cslDebug((50, "send wr rsp to cdp\x0A"));
                 //FIXME(skip-t194): we can add assertion cdp_wr_rsp_count_ == cdp_wr_cmd_count_fifo_->read 
                 NV_NVDLA_cvif_base::cvif2cdp_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -3910,7 +3910,7 @@ void NV_NVDLA_cvif::ext2cvif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             // Read a new reques id from fifo
             rbk_wr_req_expected_ack = rbk_wr_required_ack_fifo_->read();
             if (true == rbk_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to rbk\x0A"));
+                //cslDebug((50, "send wr rsp to rbk\x0A"));
                 //FIXME(skip-t194): we can add assertion rbk_wr_rsp_count_ == rbk_wr_cmd_count_fifo_->read 
                 NV_NVDLA_cvif_base::cvif2rbk_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -4079,9 +4079,9 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                
         if( !cdma_dat_ready && !cdma_wt_ready && !bdma_ready && !sdp_ready &&
         !pdp_ready && !cdp_ready && !rbk_ready && !sdp_b_ready && !sdp_n_ready && !sdp_e_ready) {{   
-            cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, no pending request, waiting.\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, no pending request, waiting.\x0A"));
             wait();
-            cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, get new request, wake up.\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, get new request, wake up.\x0A"));
         }}
 
         // Get a FIFO write event, query dma read request FIFOs
@@ -4095,10 +4095,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2bdma_rd_rsp_fifo_ >= atom_num) {   // Same as bdma_ready
                 credit_cvif2bdma_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from bdma, begin, atom:%d, num_free:%d credit_cvif2bdma_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2bdma_rd_rsp_fifo_->num_free(), credit_cvif2bdma_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from bdma, begin, atom:%d, num_free:%d credit_cvif2bdma_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2bdma_rd_rsp_fifo_->num_free(), credit_cvif2bdma_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(bdma_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from bdma, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from bdma, end.\x0A"));
                 delete bdma_rd_req_payload_;
                 bdma_rd_req_payload_ = NULL;
             }
@@ -4112,10 +4112,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2sdp_rd_rsp_fifo_ >= atom_num) {   // Same as sdp_ready
                 credit_cvif2sdp_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp, begin, atom:%d, num_free:%d credit_cvif2sdp_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2sdp_rd_rsp_fifo_->num_free(), credit_cvif2sdp_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp, begin, atom:%d, num_free:%d credit_cvif2sdp_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2sdp_rd_rsp_fifo_->num_free(), credit_cvif2sdp_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(sdp_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp, end.\x0A"));
                 delete sdp_rd_req_payload_;
                 sdp_rd_req_payload_ = NULL;
             }
@@ -4129,10 +4129,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2pdp_rd_rsp_fifo_ >= atom_num) {   // Same as pdp_ready
                 credit_cvif2pdp_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from pdp, begin, atom:%d, num_free:%d credit_cvif2pdp_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2pdp_rd_rsp_fifo_->num_free(), credit_cvif2pdp_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from pdp, begin, atom:%d, num_free:%d credit_cvif2pdp_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2pdp_rd_rsp_fifo_->num_free(), credit_cvif2pdp_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(pdp_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from pdp, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from pdp, end.\x0A"));
                 delete pdp_rd_req_payload_;
                 pdp_rd_req_payload_ = NULL;
             }
@@ -4146,10 +4146,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2cdp_rd_rsp_fifo_ >= atom_num) {   // Same as cdp_ready
                 credit_cvif2cdp_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdp, begin, atom:%d, num_free:%d credit_cvif2cdp_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2cdp_rd_rsp_fifo_->num_free(), credit_cvif2cdp_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdp, begin, atom:%d, num_free:%d credit_cvif2cdp_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2cdp_rd_rsp_fifo_->num_free(), credit_cvif2cdp_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(cdp_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdp, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdp, end.\x0A"));
                 delete cdp_rd_req_payload_;
                 cdp_rd_req_payload_ = NULL;
             }
@@ -4163,10 +4163,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2rbk_rd_rsp_fifo_ >= atom_num) {   // Same as rbk_ready
                 credit_cvif2rbk_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from rbk, begin, atom:%d, num_free:%d credit_cvif2rbk_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2rbk_rd_rsp_fifo_->num_free(), credit_cvif2rbk_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from rbk, begin, atom:%d, num_free:%d credit_cvif2rbk_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2rbk_rd_rsp_fifo_->num_free(), credit_cvif2rbk_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(rbk_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from rbk, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from rbk, end.\x0A"));
                 delete rbk_rd_req_payload_;
                 rbk_rd_req_payload_ = NULL;
             }
@@ -4180,10 +4180,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2sdp_b_rd_rsp_fifo_ >= atom_num) {   // Same as sdp_b_ready
                 credit_cvif2sdp_b_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_b, begin, atom:%d, num_free:%d credit_cvif2sdp_b_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2sdp_b_rd_rsp_fifo_->num_free(), credit_cvif2sdp_b_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_b, begin, atom:%d, num_free:%d credit_cvif2sdp_b_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2sdp_b_rd_rsp_fifo_->num_free(), credit_cvif2sdp_b_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(sdp_b_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_b, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_b, end.\x0A"));
                 delete sdp_b_rd_req_payload_;
                 sdp_b_rd_req_payload_ = NULL;
             }
@@ -4197,10 +4197,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2sdp_n_rd_rsp_fifo_ >= atom_num) {   // Same as sdp_n_ready
                 credit_cvif2sdp_n_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_n, begin, atom:%d, num_free:%d credit_cvif2sdp_n_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2sdp_n_rd_rsp_fifo_->num_free(), credit_cvif2sdp_n_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_n, begin, atom:%d, num_free:%d credit_cvif2sdp_n_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2sdp_n_rd_rsp_fifo_->num_free(), credit_cvif2sdp_n_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(sdp_n_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_n, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_n, end.\x0A"));
                 delete sdp_n_rd_req_payload_;
                 sdp_n_rd_req_payload_ = NULL;
             }
@@ -4214,10 +4214,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2sdp_e_rd_rsp_fifo_ >= atom_num) {   // Same as sdp_e_ready
                 credit_cvif2sdp_e_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_e, begin, atom:%d, num_free:%d credit_cvif2sdp_e_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2sdp_e_rd_rsp_fifo_->num_free(), credit_cvif2sdp_e_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_e, begin, atom:%d, num_free:%d credit_cvif2sdp_e_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2sdp_e_rd_rsp_fifo_->num_free(), credit_cvif2sdp_e_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(sdp_e_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_e, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from sdp_e, end.\x0A"));
                 delete sdp_e_rd_req_payload_;
                 sdp_e_rd_req_payload_ = NULL;
             }
@@ -4231,10 +4231,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2cdma_dat_rd_rsp_fifo_ >= atom_num) {   // Same as cdma_dat_ready
                 credit_cvif2cdma_dat_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdma_dat, begin, atom:%d, num_free:%d credit_cvif2cdma_dat_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2cdma_dat_rd_rsp_fifo_->num_free(), credit_cvif2cdma_dat_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdma_dat, begin, atom:%d, num_free:%d credit_cvif2cdma_dat_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2cdma_dat_rd_rsp_fifo_->num_free(), credit_cvif2cdma_dat_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(cdma_dat_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdma_dat, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdma_dat, end.\x0A"));
                 delete cdma_dat_rd_req_payload_;
                 cdma_dat_rd_req_payload_ = NULL;
             }
@@ -4248,10 +4248,10 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
                 atom_num += axi_byte_enable_ptr[i*DMA_TRANSACTION_ATOM_SIZE] == TLM_BYTE_ENABLED;
             if (credit_cvif2cdma_wt_rd_rsp_fifo_ >= atom_num) {   // Same as cdma_wt_ready
                 credit_cvif2cdma_wt_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdma_wt, begin, atom:%d, num_free:%d credit_cvif2cdma_wt_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2cdma_wt_rd_rsp_fifo_->num_free(), credit_cvif2cdma_wt_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdma_wt, begin, atom:%d, num_free:%d credit_cvif2cdma_wt_rd_rsp_fifo_=%d.\x0A", atom_num, cvif2cdma_wt_rd_rsp_fifo_->num_free(), credit_cvif2cdma_wt_rd_rsp_fifo_));
 
                 cvif2ext_rd_req->b_transport(cdma_wt_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdma_wt, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_cvif::ReadRequestArbiter, send read request, payload from cdma_wt, end.\x0A"));
                 delete cdma_wt_rd_req_payload_;
                 cdma_wt_rd_req_payload_ = NULL;
             }
@@ -4264,7 +4264,7 @@ void NV_NVDLA_cvif::ReadRequestArbiter() {
 void NV_NVDLA_cvif::WriteRequestArbiter() {
     dla_b_transport_payload *payload;
     while (true) {
-        cslDebug((50, "Calling WriteRequestArbiter\x0A"));
+        //cslDebug((50, "Calling WriteRequestArbiter\x0A"));
         if((bdma_wr_req_fifo_->num_available()==0) && (rbk_wr_req_fifo_->num_available()==0) && (sdp_wr_req_fifo_->num_available()==0) && (pdp_wr_req_fifo_->num_available()==0) && (cdp_wr_req_fifo_->num_available()==0))
             wait();
 
@@ -4272,31 +4272,31 @@ void NV_NVDLA_cvif::WriteRequestArbiter() {
 
         // For BDMA
         if (bdma_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from bdma.\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from bdma.\x0A"));
             cvif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
         // For SDP
         if (sdp_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from sdp.\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from sdp.\x0A"));
             cvif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
         // For PDP
         if (pdp_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from pdp.\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from pdp.\x0A"));
             cvif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
         // For CDP
         if (cdp_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from cdp.\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from cdp.\x0A"));
             cvif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
         // For RBK
         if (rbk_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from rbk.\x0A"));
+            //cslDebug((50, "NV_NVDLA_cvif::WriteRequestArbiter, send write request, payload from rbk.\x0A"));
             cvif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
diff --git a/cmod/glb/NV_NVDLA_glb.cpp b/cmod/glb/NV_NVDLA_glb.cpp
index 55363a8..61238d8 100644
--- a/cmod/glb/NV_NVDLA_glb.cpp
+++ b/cmod/glb/NV_NVDLA_glb.cpp
@@ -161,7 +161,7 @@ void NV_NVDLA_glb::UpdatePdpIntrStatus_1() {
 void NV_NVDLA_glb::UpdateSdpIntrStatus_0() {
     if(sdp2glb_done_intr[0]==true) {
         glb_reg_model::GlbUpdateSdpIntrStatus_0(true);
-        cslDebug((50, "glb_reg_model::GlbUpdateSdpIntrStatus_0 is called\n"));
+        //cslDebug((50, "glb_reg_model::GlbUpdateSdpIntrStatus_0 is called\n"));
     }
 }
 
diff --git a/cmod/hls/csc_libs/csc_cvt.cpp b/cmod/hls/csc_libs/csc_cvt.cpp
index f2976fa..6ae43a1 100644
--- a/cmod/hls/csc_libs/csc_cvt.cpp
+++ b/cmod/hls/csc_libs/csc_cvt.cpp
@@ -48,7 +48,7 @@ void NV_NVDLA_CSC_pra_cell (
     vDataStruct   o_data;
     
     #ifdef HLS_TRACE
-        cslDebug((30, "%s call NV_NVDLA_CSC_pra_cell on %d iter\n", "HLS_CALL", hls_call_iter++));
+        //cslDebug((30, "%s call NV_NVDLA_CSC_pra_cell on %d iter\n", "HLS_CALL", hls_call_iter++));
     #endif
     //=====================================================
     // C^T * Input
@@ -137,11 +137,11 @@ void NV_NVDLA_CSC_pra_cell (
     }
     
     #ifdef HLS_TRACE
-        cslDebug((30, "Matrix: after C^T "));
+        //cslDebug((30, "Matrix: after C^T "));
         for (int i=0; i<16; i++) {
-            cslDebug((30, "0x%08x ", m_data.data[i].to_int()));
+            //cslDebug((30, "0x%08x ", m_data.data[i].to_int()));
         }
-        cslDebug((30, "\n"));
+        //cslDebug((30, "\n"));
     #endif
     
     //=====================================================
@@ -218,17 +218,17 @@ void NV_NVDLA_CSC_pra_cell (
     
     #ifdef HLS_TRACE
         if (cfg_precision==ENUM_FP16) {
-            cslDebug((30, "Matrix: after C "));
+            //cslDebug((30, "Matrix: after C "));
             for (int i=0; i<16; i++) {
-                cslDebug((30, "0x%08x ", f_data.data[i].to_int()));
+                //cslDebug((30, "0x%08x ", f_data.data[i].to_int()));
             }
-            cslDebug((30, "\n"));
+            //cslDebug((30, "\n"));
         } else {
-            cslDebug((30, "Matrix: after C "));
+            //cslDebug((30, "Matrix: after C "));
             for (int i=0; i<16; i++) {
-                cslDebug((30, "0x%08x ", t_data.data[i].to_int()));
+                //cslDebug((30, "0x%08x ", t_data.data[i].to_int()));
             }
-            cslDebug((30, "\n"));
+            //cslDebug((30, "\n"));
         }
     #endif
     
diff --git a/cmod/hls/sdp/sdp_y_core.cpp b/cmod/hls/sdp/sdp_y_core.cpp
index 1562369..b1de64e 100644
--- a/cmod/hls/sdp/sdp_y_core.cpp
+++ b/cmod/hls/sdp/sdp_y_core.cpp
@@ -40,11 +40,11 @@ void Y_alu (
     yDataOutStruct AluOut;
         
     #ifdef HLS_TRACE
-        cslDebug((30, "ALU-IN:  "));
+        //cslDebug((30, "ALU-IN:  "));
         for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", AluIn.data[i].to_int()));
+            //cslDebug((30, "0x%08x ", AluIn.data[i].to_int()));
         }
-        cslDebug((30, "\n"));
+        //cslDebug((30, "\n"));
     #endif
         
     if (cfg_alu_bypass) {
@@ -74,11 +74,11 @@ void Y_alu (
         }
     
         #ifdef HLS_TRACE
-            cslDebug((30, "ALU-OP:  "));
+            //cslDebug((30, "ALU-OP:  "));
             for (int i=0; i<SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", AluOp.data[i].to_int()));
+                //cslDebug((30, "0x%08x ", AluOp.data[i].to_int()));
             }
-            cslDebug((30, "\n"));
+            //cslDebug((30, "\n"));
         #endif
     
         #ifdef SYNTHESIS
@@ -114,11 +114,11 @@ void Y_alu (
     
     }
     #ifdef HLS_TRACE
-        cslDebug((30, "ALU-OUT: "));
+        //cslDebug((30, "ALU-OUT: "));
         for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", AluOut.data[i].to_int()));
+            //cslDebug((30, "0x%08x ", AluOut.data[i].to_int()));
         }
-        cslDebug((30, "\n"));
+        //cslDebug((30, "\n"));
     #endif
         
     chn_alu_out.write(AluOut);
@@ -172,16 +172,16 @@ void Y_mul (
         }
         
         #ifdef HLS_TRACE
-            cslDebug((30, "MUL-IN: "));
+            //cslDebug((30, "MUL-IN: "));
             for (int i=0; i<SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", MulIn.data[i].to_int()));
+                //cslDebug((30, "0x%08x ", MulIn.data[i].to_int()));
             }
-            cslDebug((30, "\n"));
-            cslDebug((30, "MUL-OP: "));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "MUL-OP: "));
             for (int i=0; i<SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", MulOp.data[i].to_int()));
+                //cslDebug((30, "0x%08x ", MulOp.data[i].to_int()));
             }
-            cslDebug((30, "\n"));
+            //cslDebug((30, "\n"));
         #endif
     
 
@@ -210,11 +210,11 @@ void Y_mul (
         }
     
         #ifdef HLS_TRACE
-            cslDebug((30, "MUL-OUT: "));
+            //cslDebug((30, "MUL-OUT: "));
             for (int i=0; i<SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", MulOut.data[i].to_int()));
+                //cslDebug((30, "0x%08x ", MulOut.data[i].to_int()));
             }
-            cslDebug((30, "\n"));
+            //cslDebug((30, "\n"));
         #endif
     }
 
@@ -244,29 +244,29 @@ void NV_NVDLA_SDP_CORE_Y_core (
 {
         
         #ifdef HLS_TRACE
-            cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_core on %d iter\n", "HLS_CALL", hls_call_iter++));
-            cslDebug((30, "CONFIG: "));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_alu_bypass:0x%08x ", cfg_alu_bypass.to_int()));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_alu_src:0x%08x ", cfg_alu_src.to_int()));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_alu_op:0x%08x ", cfg_alu_op.to_int()));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_alu_algo:0x%08x ", cfg_alu_algo.to_int()));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_mul_bypass:0x%08x ", cfg_mul_bypass.to_int()));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_mul_src:0x%08x ", cfg_mul_src.to_int()));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_mul_op:0x%08x ", cfg_mul_op.to_int()));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_truncate:0x%08x ", cfg_truncate.to_int()));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_mul_prelu:0x%08x ", cfg_mul_prelu.to_int()));
-            cslDebug((30, "\n"));
-            cslDebug((30, "cfg_precision:0x%08x ", cfg_precision.to_int()));
-            cslDebug((30, "\n"));
+            //cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_core on %d iter\n", "HLS_CALL", hls_call_iter++));
+            //cslDebug((30, "CONFIG: "));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_alu_bypass:0x%08x ", cfg_alu_bypass.to_int()));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_alu_src:0x%08x ", cfg_alu_src.to_int()));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_alu_op:0x%08x ", cfg_alu_op.to_int()));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_alu_algo:0x%08x ", cfg_alu_algo.to_int()));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_mul_bypass:0x%08x ", cfg_mul_bypass.to_int()));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_mul_src:0x%08x ", cfg_mul_src.to_int()));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_mul_op:0x%08x ", cfg_mul_op.to_int()));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_truncate:0x%08x ", cfg_truncate.to_int()));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_mul_prelu:0x%08x ", cfg_mul_prelu.to_int()));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "cfg_precision:0x%08x ", cfg_precision.to_int()));
+            //cslDebug((30, "\n"));
         #endif
 
         static ac_channel<yDataOutStruct>  chn_mul_out;
diff --git a/cmod/hls/sdp/sdp_y_cvt.cpp b/cmod/hls/sdp/sdp_y_cvt.cpp
index b688b61..306c39c 100644
--- a/cmod/hls/sdp/sdp_y_cvt.cpp
+++ b/cmod/hls/sdp/sdp_y_cvt.cpp
@@ -95,7 +95,7 @@ void NV_NVDLA_SDP_CORE_Y_cvt (
     data_in = chn_in.read();
         
     #ifdef HLS_TRACE
-        cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_cvt on %d iter\n", "HLS_CALL", hls_call_iter++));
+        //cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_cvt on %d iter\n", "HLS_CALL", hls_call_iter++));
     #endif
 
     #ifdef SYNTHESIS
@@ -119,25 +119,25 @@ void NV_NVDLA_SDP_CORE_Y_cvt (
     #ifdef HLS_TRACE
         #pragma CTC SKIP
         if (hls_call_iter % 2) {
-            cslDebug((30, "ALU:  "));
+            //cslDebug((30, "ALU:  "));
         } else {
-            cslDebug((30, "MUL:  "));
+            //cslDebug((30, "MUL:  "));
         }
         #pragma CTC ENDSKIP
 
-        cslDebug((30, "\n"));
-        cslDebug((30, "Y-CVT-IN:  "));
-        cslDebug((30, "\n"));
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "Y-CVT-IN:  "));
+        //cslDebug((30, "\n"));
         for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", data_in.data[i].to_int()));
+            //cslDebug((30, "0x%08x ", data_in.data[i].to_int()));
         }
-        cslDebug((30, "\n"));
-        cslDebug((30, "Y-CVT-OUT: "));
-        cslDebug((30, "\n"));
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "Y-CVT-OUT: "));
+        //cslDebug((30, "\n"));
         for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", data_out.data[i].to_int()));
+            //cslDebug((30, "0x%08x ", data_out.data[i].to_int()));
         }
-        cslDebug((30, "\n"));
+        //cslDebug((30, "\n"));
     #endif
     chn_out.write(data_out);
 }
diff --git a/cmod/hls/sdp/sdp_y_idx.cpp b/cmod/hls/sdp/sdp_y_idx.cpp
index ad9b122..d0eae51 100644
--- a/cmod/hls/sdp/sdp_y_idx.cpp
+++ b/cmod/hls/sdp/sdp_y_idx.cpp
@@ -44,7 +44,7 @@ void NV_NVDLA_SDP_CORE_Y_idx (
 {
 
     #ifdef HLS_TRACE
-        cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_idx on %d iter\n", "HLS_CALL", hls_call_iter++));
+        //cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_idx on %d iter\n", "HLS_CALL", hls_call_iter++));
     #endif
 
     yLutOutStruct lut_out;
@@ -330,47 +330,47 @@ void NV_NVDLA_SDP_CORE_Y_idx (
     }
     
     #ifdef HLS_TRACE
-        cslDebug((30, "LutIn\n "));
-        for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", lut_in.data[i].to_int()));
-        }
-        cslDebug((30, "\n"));
-        
-        cslDebug((30, "LutOut.ram_addr\n "));
-        for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", lut_out.ram_addr[i].to_int()));
-        }
-        cslDebug((30, "\n"));
-        cslDebug((30, "LutOut.ram_sel\n "));
-        for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", lut_out.ram_sel[i].to_int()));
-        }
-        cslDebug((30, "\n"));
-        cslDebug((30, "LutOut.fraction\n "));
-        for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08llx ", lut_out.fraction[i].to_int64()));
-        }
-        cslDebug((30, "\n"));
-        cslDebug((30, "LutOut.uflow\n "));
-        for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", lut_out.uflow[i].to_int()));
-        }
-        cslDebug((30, "\n"));
-        cslDebug((30, "LutOut.oflow\n "));
-        for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", lut_out.oflow[i].to_int()));
-        }
-        cslDebug((30, "\n"));
-        cslDebug((30, "LutOut.le_hit\n "));
-        for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", lut_out.le_hit[i].to_int()));
-        }
-        cslDebug((30, "\n"));
-        cslDebug((30, "LutOut.lo_hit\n "));
-        for (int i=0; i<SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", lut_out.lo_hit[i].to_int()));
-        }
-        cslDebug((30, "\n"));
+        //cslDebug((30, "LutIn\n "));
+        //for (int i=0; i<SPEED_Y; i++) {
+        //    cslDebug((30, "0x%08x ", lut_in.data[i].to_int()));
+        //}
+        //cslDebug((30, "\n"));
+        //
+        //cslDebug((30, "LutOut.ram_addr\n "));
+        //for (int i=0; i<SPEED_Y; i++) {
+        //    cslDebug((30, "0x%08x ", lut_out.ram_addr[i].to_int()));
+        //}
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "LutOut.ram_sel\n "));
+        //for (int i=0; i<SPEED_Y; i++) {
+        //    cslDebug((30, "0x%08x ", lut_out.ram_sel[i].to_int()));
+        //}
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "LutOut.fraction\n "));
+        //for (int i=0; i<SPEED_Y; i++) {
+        //    cslDebug((30, "0x%08llx ", lut_out.fraction[i].to_int64()));
+        //}
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "LutOut.uflow\n "));
+        //for (int i=0; i<SPEED_Y; i++) {
+        //    cslDebug((30, "0x%08x ", lut_out.uflow[i].to_int()));
+        //}
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "LutOut.oflow\n "));
+        //for (int i=0; i<SPEED_Y; i++) {
+        //    cslDebug((30, "0x%08x ", lut_out.oflow[i].to_int()));
+        //}
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "LutOut.le_hit\n "));
+        //for (int i=0; i<SPEED_Y; i++) {
+        //    cslDebug((30, "0x%08x ", lut_out.le_hit[i].to_int()));
+        //}
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "LutOut.lo_hit\n "));
+        //for (int i=0; i<SPEED_Y; i++) {
+        //    cslDebug((30, "0x%08x ", lut_out.lo_hit[i].to_int()));
+        //}
+        //cslDebug((30, "\n"));
     #endif
 
     chn_lut_out.write(lut_out);
diff --git a/cmod/hls/sdp/sdp_y_inp.cpp b/cmod/hls/sdp/sdp_y_inp.cpp
index 41d4344..4f248d5 100644
--- a/cmod/hls/sdp/sdp_y_inp.cpp
+++ b/cmod/hls/sdp/sdp_y_inp.cpp
@@ -31,7 +31,7 @@ void NV_NVDLA_SDP_CORE_Y_inp (
          )
 {
     #ifdef HLS_TRACE
-        cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_inp on %d iter\n", "HLS_CALL", hls_call_iter++));
+        //cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_inp on %d iter\n", "HLS_CALL", hls_call_iter++));
     #endif
 
     yInpInStruct inp_in = chn_inp_in.read();
@@ -69,33 +69,33 @@ void NV_NVDLA_SDP_CORE_Y_inp (
                 Fp17Type o = Fp17Add(y,b); //stepheng. 20170515
                 
                 #ifdef HLS_TRACE
-                    cslDebug((30, "Inp.x.fp32 %d:", i));
-                    cslDebug((30, "0x%08x ", x.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "Inp.bias.fp32 %d:", i));
-                    cslDebug((30, "0x%08x ", bias.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "Inp.offset.fp32 %d:", i));
-                    cslDebug((30, "0x%08x ", offset.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "Inp.offset+bias.fp32 %d:", i));
-                    cslDebug((30, "0x%08x ", ob.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "Inp.x-(offset+bias).fp32 %d:", i));
-                    cslDebug((30, "0x%08x ", xob.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "Inp.scale.fp17 %d:", i));
-                    cslDebug((30, "0x%08x ", scale.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "Inp.(x-(offset+bias)) x scale.fp17 %d:", i));
-                    cslDebug((30, "0x%08x ", b.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "Inp.y.fp17 %d:", i));
-                    cslDebug((30, "0x%08x ", y.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "Inp.out.fp17 %d:", i));
-                    cslDebug((30, "0x%08x ", o.to_int()));
-                    cslDebug((30, "\n"));
+                    //cslDebug((30, "Inp.x.fp32 %d:", i));
+                    //cslDebug((30, "0x%08x ", x.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "Inp.bias.fp32 %d:", i));
+                    //cslDebug((30, "0x%08x ", bias.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "Inp.offset.fp32 %d:", i));
+                    //cslDebug((30, "0x%08x ", offset.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "Inp.offset+bias.fp32 %d:", i));
+                    //cslDebug((30, "0x%08x ", ob.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "Inp.x-(offset+bias).fp32 %d:", i));
+                    //cslDebug((30, "0x%08x ", xob.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "Inp.scale.fp17 %d:", i));
+                    //cslDebug((30, "0x%08x ", scale.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "Inp.(x-(offset+bias)) x scale.fp17 %d:", i));
+                    //cslDebug((30, "0x%08x ", b.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "Inp.y.fp17 %d:", i));
+                    //cslDebug((30, "0x%08x ", y.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "Inp.out.fp17 %d:", i));
+                    //cslDebug((30, "0x%08x ", o.to_int()));
+                    //cslDebug((30, "\n"));
                 #endif
                 inp_out.data[i] = Fp17ToFp32(o);
             } else {
@@ -151,36 +151,36 @@ void NV_NVDLA_SDP_CORE_Y_inp (
                 inp_out.data[i] = Fp17ToFp32(o);
                 
                 #ifdef HLS_TRACE
-                    cslDebug((30, "a0.fraction %d:", i));
-                    cslDebug((30, "0x%08llx ", a0_frac.to_int64()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "a0 fp17 %d:", i));
-                    cslDebug((30, "0x%08x ", a0.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "a1.fraction %d:", i));
-                    cslDebug((30, "0x%08llx ", a1_frac.to_int64()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "a1 fp17 %d:", i));
-                    cslDebug((30, "0x%08x ", a1.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "y0 fp16 %d:", i));
-                    cslDebug((30, "0x%08x ", inp_in.y0[i].to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "y0 fp17 %d:", i));
-                    cslDebug((30, "0x%08x ", y0.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "y1 fp16 %d:", i));
-                    cslDebug((30, "0x%08x ", inp_in.y1[i].to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "y1 fp17 %d:", i));
-                    cslDebug((30, "0x%08x ", y1.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "o fp17 %d:", i));
-                    cslDebug((30, "0x%08x ", o.to_int()));
-                    cslDebug((30, "\n"));
-                    cslDebug((30, "OUT fp32 %d:", i));
-                    cslDebug((30, "0x%08x ", inp_out.data[i].to_int()));
-                    cslDebug((30, "\n"));
+                    //cslDebug((30, "a0.fraction %d:", i));
+                    //cslDebug((30, "0x%08llx ", a0_frac.to_int64()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "a0 fp17 %d:", i));
+                    //cslDebug((30, "0x%08x ", a0.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "a1.fraction %d:", i));
+                    //cslDebug((30, "0x%08llx ", a1_frac.to_int64()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "a1 fp17 %d:", i));
+                    //cslDebug((30, "0x%08x ", a1.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "y0 fp16 %d:", i));
+                    //cslDebug((30, "0x%08x ", inp_in.y0[i].to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "y0 fp17 %d:", i));
+                    //cslDebug((30, "0x%08x ", y0.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "y1 fp16 %d:", i));
+                    //cslDebug((30, "0x%08x ", inp_in.y1[i].to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "y1 fp17 %d:", i));
+                    //cslDebug((30, "0x%08x ", y1.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "o fp17 %d:", i));
+                    //cslDebug((30, "0x%08x ", o.to_int()));
+                    //cslDebug((30, "\n"));
+                    //cslDebug((30, "OUT fp32 %d:", i));
+                    //cslDebug((30, "0x%08x ", inp_out.data[i].to_int()));
+                    //cslDebug((30, "\n"));
                 #endif
             } else {
                 yInpDataFMidType a0 = (yInpDataFMidType)((1ull<<yLutFracSize) - inp_in.fraction[i]);
diff --git a/cmod/hls_wrapper/cdma_hls_wrapper.cpp b/cmod/hls_wrapper/cdma_hls_wrapper.cpp
index 7149ed7..4ef730c 100644
--- a/cmod/hls_wrapper/cdma_hls_wrapper.cpp
+++ b/cmod/hls_wrapper/cdma_hls_wrapper.cpp
@@ -56,7 +56,7 @@ void cdma_cvt_hls (
     // Prepare 17bits Input
     if(unsigned_int8) {
         data_in = (*cdma_cvt_data_in) & 0xff; // Set MSB to 0
-        cslDebug((70, "cdma_hls_wrapper unsigned_int8: *cdma_cvt_data_in=0x%x data_in=0x%x\n", *cdma_cvt_data_in, data_in.to_int()));
+        //cslDebug((70, "cdma_hls_wrapper unsigned_int8: *cdma_cvt_data_in=0x%x data_in=0x%x\n", *cdma_cvt_data_in, data_in.to_int()));
     }
     else if(signed_int8) {
         if (((*cdma_cvt_data_in) & 0x80) !=0)  // negative
@@ -66,21 +66,21 @@ void cdma_cvt_hls (
     }
     else if(unsigned_int16) {
         data_in = (*cdma_cvt_data_in) & 0xffff; // Set MSB to 0
-        cslDebug((70, "cdma_hls_wrapper unsigned_int16: *cdma_cvt_data_in=0x%x data_in=0x%x\n", *cdma_cvt_data_in, data_in.to_int()));
+        //cslDebug((70, "cdma_hls_wrapper unsigned_int16: *cdma_cvt_data_in=0x%x data_in=0x%x\n", *cdma_cvt_data_in, data_in.to_int()));
     }
     else if(signed_int16) {
         if (((*cdma_cvt_data_in) & 0x8000) !=0)  // negative
             data_in = (*cdma_cvt_data_in) | 0x10000;
         else
             data_in = (*cdma_cvt_data_in) & 0xffff; // Set MSB to 0
-        cslDebug((70, "cdma_hls_wrapper signed_int16: *cdma_cvt_data_in=0x%x data_in=0x%x\n", *cdma_cvt_data_in, data_in.to_int()));
+        //cslDebug((70, "cdma_hls_wrapper signed_int16: *cdma_cvt_data_in=0x%x data_in=0x%x\n", *cdma_cvt_data_in, data_in.to_int()));
     }
 #pragma CTC SKIP
     else if(fp16) {  // FP16
         data_in = *cdma_cvt_data_in;
     }
     else {
-        cslInfo(("Invalid data type\n"));
+        //cslInfo(("Invalid data type\n"));
     }
 #pragma CTC ENDSKIP
 
@@ -92,11 +92,11 @@ void cdma_cvt_hls (
     cfg_out_precision   = cdma_cvt_out_precission;
     cfg_truncate        = cdma_cvt_truncate;
 
-    cslDebug((70, "cdma_cvt_hls data_in=0x%x alu_in=0x%x mul_in=0x%x in_precision=%d out_precision=%d truncate=0x%x\n", data_in.to_int(), cfg_alu_in.to_int(), cfg_mul_in.to_int(), cfg_in_precision.to_int(), cfg_out_precision.to_int(), cfg_truncate.to_int()));
+    //cslDebug((70, "cdma_cvt_hls data_in=0x%x alu_in=0x%x mul_in=0x%x in_precision=%d out_precision=%d truncate=0x%x\n", data_in.to_int(), cfg_alu_in.to_int(), cfg_mul_in.to_int(), cfg_in_precision.to_int(), cfg_out_precision.to_int(), cfg_truncate.to_int()));
 
     NV_NVDLA_CDMA_CVT_cell(chn_data_in, chn_alu_in, cfg_mul_in, cfg_in_precision, cfg_out_precision, cfg_truncate, chn_data_out);
 
     // Get output
     *cdma_cvt_data_out = chn_data_out.read().to_uint();
-    cslDebug((70, "cdma_cvt_hls data_out=0x%x\n", *cdma_cvt_data_out));
+    //cslDebug((70, "cdma_cvt_hls data_out=0x%x\n", *cdma_cvt_data_out));
 }
diff --git a/cmod/hls_wrapper/cdp_hls_wrapper.cpp b/cmod/hls_wrapper/cdp_hls_wrapper.cpp
index 162deaf..90a90e1 100644
--- a/cmod/hls_wrapper/cdp_hls_wrapper.cpp
+++ b/cmod/hls_wrapper/cdp_hls_wrapper.cpp
@@ -246,7 +246,7 @@ void HLS_CDP_lookup_lut (
     lut_sub_result_fp32 = chn_lut_sub_result_fp32.read();
     lut_sub_result_float = *(float *)(&lut_sub_result_fp32); // vFp32Type is actually integer type
 
-    cslDebug((70, "lut_start=0x%x, lut_sub_result=0x%x\n", (uint32_t)lut_start_fp32, (uint32_t)lut_sub_result_fp32));
+    //cslDebug((70, "lut_start=0x%x, lut_sub_result=0x%x\n", (uint32_t)lut_start_fp32, (uint32_t)lut_sub_result_fp32));
 
     if(lut_sub_result_float <= 0 || std::isnan(lut_sub_result_float))
     {
@@ -274,7 +274,7 @@ void HLS_CDP_lookup_lut (
                 overflow = true;
             }
 
-            cslDebug((70, "exp=%d, index_offset=%d, lut_index=%d, lut_offset=%d\n", exp, index_offset, lut_index, lut_offset));
+            //cslDebug((70, "exp=%d, index_offset=%d, lut_index=%d, lut_offset=%d\n", exp, index_offset, lut_index, lut_offset));
         }
         else {
             // lo or (le && linear_mode)
@@ -290,7 +290,7 @@ void HLS_CDP_lookup_lut (
             lut_index  = lut_shifted;
             lut_offset = (lut_shifted - int32_t(lut_shifted)) * 0x10000; // 16 MSB bits of fraction
 
-            cslDebug((70, "index_select=%d, lut_shifted=%f, lut_index=%d, lut_offset=%d\n", index_select, lut_shifted, lut_index, lut_offset));
+            //cslDebug((70, "index_select=%d, lut_shifted=%f, lut_index=%d, lut_offset=%d\n", index_select, lut_shifted, lut_index, lut_offset));
         }
     }
     
@@ -306,7 +306,7 @@ void HLS_CDP_lookup_lut (
         result_0 = lut[0];
         result_0_fp16 = result_0;
         chn_result_0_fp16.write(result_0_fp16);
-        cslDebug((70, "L0=0x%x\n", result_0));
+        //cslDebug((70, "L0=0x%x\n", result_0));
         // Convert result_lo_0 of HLS FP16 to HLS_FP17
         HLS_fp16_to_fp17(chn_result_0_fp16, chn_result_0_fp17);
         
@@ -350,7 +350,7 @@ void HLS_CDP_lookup_lut (
         result_1 = lut[lut_upper_index];
         result_1_fp16 = result_1;
         chn_result_1_fp16.write(result_1_fp16);
-        cslDebug((70, "L1=0x%x\n", result_1));
+        //cslDebug((70, "L1=0x%x\n", result_1));
         // Convert result_lo_0 of HLS FP16 to HLS_FP17
         HLS_fp16_to_fp17(chn_result_1_fp16, chn_result_1_fp17);
 
@@ -377,7 +377,7 @@ void HLS_CDP_lookup_lut (
         chn_result_0_fp16.write(result_0_fp16);
         chn_result_1_fp16.write(result_1_fp16);
         
-        cslDebug((70, "L0=0x%x, L1=0x%x\n", result_0, result_1));
+        //cslDebug((70, "L0=0x%x, L1=0x%x\n", result_0, result_1));
 
         // Convert HLS_FP16 to HLS_FP32
         HLS_fp16_to_fp32(chn_result_0_fp16, chn_result_0_fp32);
@@ -488,21 +488,21 @@ void HLS_CDP_lookup_fp16 (
     half2single(&din_offset, &datin_offset, 1);
     half2single(&din_scale,  &datin_scale,  1);
 
-    cslDebug((70, "Data before input converter(float)\n"));
+    //cslDebug((70, "Data before input converter(float)\n"));
     for(i=0; i<12; i++)
     {
         half2single(&tmp[i], &data_in[i], 1);
-        cslDebug((70, "%f(0x%x) ", tmp[i], *(int *)(&tmp[i]) ));
+        //cslDebug((70, "%f(0x%x) ", tmp[i], *(int *)(&tmp[i]) ));
     }
-    cslDebug((70, "\n"));
+    //cslDebug((70, "\n"));
 
-    cslDebug((70, "Data after square(float)\n"));
+    //cslDebug((70, "Data after square(float)\n"));
     for(i=0; i<12; i++)
     {
         tmp[i] = tmp[i] * tmp[i];
-        cslDebug((70, "%f(0x%x) ", tmp[i], *(int *)(&tmp[i]) ));
+        //cslDebug((70, "%f(0x%x) ", tmp[i], *(int *)(&tmp[i]) ));
     }
-    cslDebug((70, "\n"));
+    //cslDebug((70, "\n"));
 
     for(i=0; i<12; i++) {
         //***** Input Convertor (FP16->FP17) ******
@@ -531,13 +531,13 @@ void HLS_CDP_lookup_fp16 (
 //    for(int i=0;i<12;i++) cslDebug((70,"%x ", *(int*)(&icvt_data_out[i]) ));
 //    cslDebug((70, "\n"));
 
-    cslDebug((70, "Data after input convertor(FP32):\n"));
-    for(int i=0;i<12;i++) cslDebug((70,"%x ", *(int*)(&icvt_data_out_fp32[i]) ));
-    cslDebug((70, "\n"));
+    //cslDebug((70, "Data after input convertor(FP32):\n"));
+    //for(int i=0;i<12;i++) cslDebug((70,"%x ", *(int*)(&icvt_data_out_fp32[i]) ));
+    //cslDebug((70, "\n"));
 
-    cslDebug((70, "Data after square:\n"));
-    for(int i=0;i<12;i++) cslDebug((70,"%x ", *(int*)(&square_result[i]) ));
-    cslDebug((70, "\n"));
+    //cslDebug((70, "Data after square:\n"));
+    //for(int i=0;i<12;i++) cslDebug((70,"%x ", *(int*)(&square_result[i]) ));
+    //cslDebug((70, "\n"));
 
     //***** Per Element ******
     for (i=0; i<4; i++) {
@@ -602,19 +602,19 @@ void HLS_CDP_lookup_fp16 (
 #pragma CTC ENDSKIP
             }
         }
-        cslDebug((70, "Square sum: %x\n", *(int *)(&square_sum_result) ));
+        //cslDebug((70, "Square sum: %x\n", *(int *)(&square_sum_result) ));
 
         // Look up Raw table
         if(NVDLA_CDP_S_LUT_CFG_0_LUT_LE_FUNCTION_EXPONENT == raw_method) {    //raw lut is exponential
-            cslDebug((70, "Lookup exp table\n"));
+            //cslDebug((70, "Lookup exp table\n"));
             HLS_CDP_lookup_lut(square_sum_result, 64, true, true, le_lut, le_start, le_end, le_slope_uflow_scale, le_slope_oflow_scale, le_index_offset, le_index_select, le_underflow, le_overflow, le_hit, chn_result_le_fp17);
         }
         else { // raw lut is linear
-            cslDebug((70, "Lookup lin table\n"));
+            //cslDebug((70, "Lookup lin table\n"));
             HLS_CDP_lookup_lut(square_sum_result, 64, true, false, le_lut, le_start, le_end, le_slope_uflow_scale, le_slope_oflow_scale, le_index_offset, le_index_select, le_underflow, le_overflow, le_hit, chn_result_le_fp17);
         }
 
-        cslDebug((70, "Lookup lo table\n"));
+        //cslDebug((70, "Lookup lo table\n"));
         // Look up LO(Linear Only) table
         HLS_CDP_lookup_lut(square_sum_result, 256, false, false, lo_lut, lo_start, lo_end, lo_slope_uflow_scale, lo_slope_oflow_scale, 0, lo_index_select, lo_underflow, lo_overflow, lo_hit, chn_result_lo_fp17);
 
@@ -652,7 +652,7 @@ void HLS_CDP_lookup_fp16 (
             }
         }
 
-        cslDebug((70, "le:%x, lo:%x, out:%x\n" , *(int *)(&result_le), *(int *)(&result_lo), *(int *)(&result_out) ));
+        //cslDebug((70, "le:%x, lo:%x, out:%x\n" , *(int *)(&result_le), *(int *)(&result_lo), *(int *)(&result_out) ));
 
         if(mul_bypass)
         {
@@ -677,7 +677,7 @@ void HLS_CDP_lookup_fp16 (
 
         // Output Converter
         int64_t ocvt_data_in = chn_result_to_ocvt_fp17.read();
-        cslDebug((70, "ocvt_data_in:%x\n", (int)ocvt_data_in));
+        //cslDebug((70, "ocvt_data_in:%x\n", (int)ocvt_data_in));
         uint8_t flag;
         cdp_ocvt_hls(&ocvt_data_in, datout_offset, datout_scale, datout_shifter, NVDLA_CDP_RDMA_D_DATA_FORMAT_0_INPUT_DATA_FP16, &normalz_out[i], &flag);
     }
diff --git a/cmod/hls_wrapper/cdp_icvt_wrapper.cpp b/cmod/hls_wrapper/cdp_icvt_wrapper.cpp
index fdeed5d..0e614dc 100644
--- a/cmod/hls_wrapper/cdp_icvt_wrapper.cpp
+++ b/cmod/hls_wrapper/cdp_icvt_wrapper.cpp
@@ -43,11 +43,11 @@ void cdp_icvt_hls (
     cfg_truncate    = cdp_icvt_truncate;
     cfg_precision   = cdp_icvt_precision;
 
-    cslDebug((70, "cdp_icvt input: 0x%08x\n", cdp_icvt_data_in[0]));
+    //cslDebug((70, "cdp_icvt input: 0x%08x\n", cdp_icvt_data_in[0]));
 
     HLS_cdp_icvt(chn_data_in, cfg_alu_in, cfg_mul_in, cfg_truncate, cfg_precision, chn_data_out);
 
     // Get output
     cdp_icvt_data_out[0] = chn_data_out.read().to_int();
-    cslDebug((70, "cdp_icvt output: 0x%08x\n", cdp_icvt_data_out[0]));
+    //cslDebug((70, "cdp_icvt output: 0x%08x\n", cdp_icvt_data_out[0]));
 }
diff --git a/cmod/hls_wrapper/cdp_ocvt_wrapper.cpp b/cmod/hls_wrapper/cdp_ocvt_wrapper.cpp
index 8d850ba..375eff6 100644
--- a/cmod/hls_wrapper/cdp_ocvt_wrapper.cpp
+++ b/cmod/hls_wrapper/cdp_ocvt_wrapper.cpp
@@ -45,7 +45,7 @@ void cdp_ocvt_hls(
     cfg_truncate    = cdp_ocvt_truncate;
     cfg_precision   = cdp_ocvt_precision;
 
-    cslDebug((70, "cdp_ocvt input: 0x%08x\n", (uint32_t)cdp_ocvt_data_in[0]));
+    //cslDebug((70, "cdp_ocvt input: 0x%08x\n", (uint32_t)cdp_ocvt_data_in[0]));
 
     HLS_cdp_ocvt(chn_data_in, cfg_alu_in, cfg_mul_in, cfg_truncate, cfg_precision, chn_data_out);
 
@@ -53,5 +53,5 @@ void cdp_ocvt_hls(
     vOutStruct cdp_ocvt_out = chn_data_out.read();
     cdp_ocvt_data_out[0] = cdp_ocvt_out.data.to_int();
     *o_flow              = cdp_ocvt_out.sat.to_int();
-    cslDebug((70, "cdp_ocvt output data: 0x%08x\n", (uint32_t)cdp_ocvt_data_out[0]));
+    //cslDebug((70, "cdp_ocvt output data: 0x%08x\n", (uint32_t)cdp_ocvt_data_out[0]));
 }
diff --git a/cmod/hls_wrapper/csc_hls_wrapper.cpp b/cmod/hls_wrapper/csc_hls_wrapper.cpp
index 980d74d..6364642 100644
--- a/cmod/hls_wrapper/csc_hls_wrapper.cpp
+++ b/cmod/hls_wrapper/csc_hls_wrapper.cpp
@@ -36,7 +36,7 @@ void csc_pra_hls (
     vDataStruct             data_out;
     ac_channel<vDataStruct> chn_data_out;
 
-    cslDebug((70, "%s enter\n", __FUNCTION__));
+    //cslDebug((70, "%s enter\n", __FUNCTION__));
 
     // Prepare Inputs
     for (i=0; i<16; i++) {
@@ -55,6 +55,6 @@ void csc_pra_hls (
     for (i=0; i<16; i++) {
         csc_pra_data_out[i] = data_out.data[i];
     }
-    cslDebug((70, "%s end\n", __FUNCTION__));
+    //cslDebug((70, "%s end\n", __FUNCTION__));
     //cslDebug((70, "cdp_ipra output: 0x%08x\n", cdp_ipra_data_out[0]));
 }
diff --git a/cmod/hls_wrapper/pdp_hls_wrapper.cpp b/cmod/hls_wrapper/pdp_hls_wrapper.cpp
index d6d47a8..383a16c 100644
--- a/cmod/hls_wrapper/pdp_hls_wrapper.cpp
+++ b/cmod/hls_wrapper/pdp_hls_wrapper.cpp
@@ -62,7 +62,7 @@ void HLS_PDP_PoolingStage0Calc_FP16_W(
         vFp16Type b = atomic_data_in[src_element_idx];
         chn_b_fp16.write(b);
 
-        cslDebug((70, "HLS_PDP_PoolingStage0Calc_FP16_W, a=0x%x, b=0x%x, pl=0x%x, pr=0x%x, is_first=%d\n", (uint32_t)a, (uint32_t)b, padding_value_left, padding_value_right, is_first_element));
+        //cslDebug((70, "HLS_PDP_PoolingStage0Calc_FP16_W, a=0x%x, b=0x%x, pl=0x%x, pr=0x%x, is_first=%d\n", (uint32_t)a, (uint32_t)b, padding_value_left, padding_value_right, is_first_element));
     }
     else
     {
@@ -74,7 +74,7 @@ void HLS_PDP_PoolingStage0Calc_FP16_W(
 
         HLS_fp16_to_fp17(chn_b_fp16, chn_b);
         
-        cslDebug((70, "HLS_PDP_PoolingStage0Calc_FP16_W, a=0x%x, b=0x%x, pl=0x%x, pr=0x%x, is_first=%d\n", (uint32_t)a, (uint32_t)b, padding_value_left, padding_value_right, is_first_element));
+        //cslDebug((70, "HLS_PDP_PoolingStage0Calc_FP16_W, a=0x%x, b=0x%x, pl=0x%x, pr=0x%x, is_first=%d\n", (uint32_t)a, (uint32_t)b, padding_value_left, padding_value_right, is_first_element));
     }
 
     if (true == is_first_element) {
@@ -181,7 +181,7 @@ void HLS_PDP_PoolingStage0Calc_FP16_H(
         vFp16Type b = line_buffer_ptr[des_element_idx];   // Read HLS_FP16 from uint32_t
         chn_b_fp16.write(b);
 
-        cslDebug((70, "HLS_PDP_PoolingStage0Calc_FP16_H, a=0x%x, b=0x%x, is_first=%d\n", (uint32_t)a, (uint32_t)b, is_first_element));
+        //cslDebug((70, "HLS_PDP_PoolingStage0Calc_FP16_H, a=0x%x, b=0x%x, is_first=%d\n", (uint32_t)a, (uint32_t)b, is_first_element));
     }
     else
     {
@@ -191,7 +191,7 @@ void HLS_PDP_PoolingStage0Calc_FP16_H(
         vFp17Type b = line_buffer_ptr[des_element_idx];   // Read HLS_FP17 from uint32_t
         chn_b.write(b);
 
-        cslDebug((70, "HLS_PDP_PoolingStage0Calc_FP16_H, a=0x%x, b=0x%x, is_first=%d\n", (uint32_t)a, (uint32_t)b, is_first_element));
+        //cslDebug((70, "HLS_PDP_PoolingStage0Calc_FP16_H, a=0x%x, b=0x%x, is_first=%d\n", (uint32_t)a, (uint32_t)b, is_first_element));
     }
 
     if (true == is_first_element) {
@@ -264,8 +264,8 @@ void HLS_PDP_PoolingStage1Calc_FP16(
     chn_recip_kernel_width_fp17.write(recip_kernel_width_fp17);
     chn_recip_kernel_height_fp17.write(recip_kernel_height_fp17);
                 
-    cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, recip_kernel_width=0x%x\n", recip_kernel_width));
-    cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, recip_kernel_height=0x%x\n", recip_kernel_height));
+    //cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, recip_kernel_width=0x%x\n", recip_kernel_width));
+    //cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, recip_kernel_height=0x%x\n", recip_kernel_height));
 
     switch (pdp_pooling_method_) {
         case POOLING_METHOD_MIN:
@@ -285,18 +285,18 @@ void HLS_PDP_PoolingStage1Calc_FP16(
             // Read HLS_FP17 from uint32_t
             a = line_buffer_ptr[src_element_idx];
             chn_a.write(a);
-            cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, sum=0x%x\n", (uint32_t)a));
+            //cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, sum=0x%x\n", (uint32_t)a));
             HLS_fp17_mul(chn_a, chn_recip_kernel_width_fp17, chn_o1);
             o1 = chn_o1.read();
-            cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, sum*rw=0x%x\n", (uint32_t)o1));
+            //cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, sum*rw=0x%x\n", (uint32_t)o1));
             chn_o1.write(o1);
             HLS_fp17_mul(chn_o1, chn_recip_kernel_height_fp17, chn_o2);
             o2 = chn_o2.read();
-            cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, sum*rw*rh=0x%x\n", (uint32_t)o2));
+            //cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, sum*rw*rh=0x%x\n", (uint32_t)o2));
             chn_o2.write(o2);
             HLS_fp17_to_fp16(chn_o2, chn_o3);
             o3 = chn_o3.read();
-            cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, result=0x%x\n", (uint32_t)o3));
+            //cslDebug((70, "HLS_PDP_PoolingStage1Calc_FP16, result=0x%x\n", (uint32_t)o3));
             atomic_data_out[des_element_idx] = o3;
             break;
         }
diff --git a/cmod/hls_wrapper/sdp_hls_wrapper.cpp b/cmod/hls_wrapper/sdp_hls_wrapper.cpp
index 64961fd..f01ad81 100644
--- a/cmod/hls_wrapper/sdp_hls_wrapper.cpp
+++ b/cmod/hls_wrapper/sdp_hls_wrapper.cpp
@@ -72,40 +72,40 @@ void sdp_hls_wrapper::sdp_x(bool is_x1, int32_t *sdp_data_in, int16_t *sdp_alu_o
         sdp_data[i] = x_data_out.data[i].to_int();
     }
 #ifdef HLS_TRACE
-    cslDebug((30, "%s call NV_NVDLA_SDP_CORE_x on %d iter\n", HLS_TRACE, hls_call_iter++));
-    cslDebug((30, "data_in:\n"));
+    //cslDebug((30, "%s call NV_NVDLA_SDP_CORE_x on %d iter\n", HLS_TRACE, hls_call_iter++));
+    //cslDebug((30, "data_in:\n"));
     for (i=0; i<16; i++) {
-        cslDebug((30, "0x%08x ", (uint32_t)data_in.data[i]));
+        //cslDebug((30, "0x%08x ", (uint32_t)data_in.data[i]));
     }
-    cslDebug((30, "\n"));
-    cslDebug((30, "alu_op:\n"));
+    //cslDebug((30, "\n"));
+    //cslDebug((30, "alu_op:\n"));
     for (i=0; i<16; i++) {
-        cslDebug((30, "0x%08x ", (uint32_t)sdp_alu_op[i]));
+        //cslDebug((30, "0x%08x ", (uint32_t)sdp_alu_op[i]));
     }
-    cslDebug((30, "\n"));
-    cslDebug((30, "mul_op:\n"));
+    //cslDebug((30, "\n"));
+    //cslDebug((30, "mul_op:\n"));
     for (i=0; i<16; i++) {
-        cslDebug((30, "0x%08x ", (uint32_t)sdp_mul_op[i]));
+        //cslDebug((30, "0x%08x ", (uint32_t)sdp_mul_op[i]));
     }
-    cslDebug((30, "\n"));
-    cslDebug((30, "cfg_mul_op:      0x%x\n", (uint32_t)(is_x1 ? (xMulOpType)sdp_cfg_x1_mul_op : (xMulOpType)sdp_cfg_x2_mul_op )));
-    cslDebug((30, "cfg_alu_op:      0x%x\n", (uint32_t)(is_x1 ? (xAluOpType)sdp_cfg_x1_alu_op : (xAluOpType)sdp_cfg_x2_alu_op )));
-    cslDebug((30, "cfg_alu_bypass:  0x%x\n", (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_alu_bypass : (ACINTF(1))sdp_cfg_x2_alu_bypass )));
-    cslDebug((30, "cfg_alu_algo:    0x%x\n", (uint32_t)(is_x1 ? (ACINTF(2))sdp_cfg_x1_alu_algo : (ACINTF(2))sdp_cfg_x2_alu_algo )));
-    cslDebug((30, "cfg_alu_src:     0x%x\n", (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_alu_src : (ACINTF(1))sdp_cfg_x2_alu_src )));
-    cslDebug((30, "cfg_alu_shift_value:0x%x\n",         (uint32_t)(is_x1 ? (ACINTF(8))sdp_cfg_x1_alu_shift_value : (ACINTF(8))sdp_cfg_x2_alu_shift_value)));
-    cslDebug((30, "cfg_mul_bypass:  0x%x\n",            (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_mul_bypass : (ACINTF(1))sdp_cfg_x2_mul_bypass          )));
-    cslDebug((30, "cfg_mul_src:     0x%x\n",            (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_mul_src : (ACINTF(1))sdp_cfg_x2_mul_src                )));
-    cslDebug((30, "cfg_mul_shift_value:0x%x\n",         (uint32_t)(is_x1 ? (ACINTF(8))sdp_cfg_x1_mul_shift_value : (ACINTF(8))sdp_cfg_x2_mul_shift_value)));
-    cslDebug((30, "cfg_mul_prelu    :0x%x\n",           (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_mul_prelu : (ACINTF(1))sdp_cfg_x2_mul_prelu            )));
-    cslDebug((30, "cfg_relu_bypass  :0x%x\n",           (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_relu_bypass : (ACINTF(1))sdp_cfg_x2_relu_bypass        )));
-    cslDebug((30, "cfg_nan_to_zero  :0x%x\n", (uint32_t)sdp_cfg_nan_to_zero));
-    cslDebug((30, "cfg_precision    :0x%x\n", (uint32_t)sdp_cfg_proc_precision));
-    cslDebug((30, "chn_data_out:\n"));
+    //cslDebug((30, "\n"));
+    //cslDebug((30, "cfg_mul_op:      0x%x\n", (uint32_t)(is_x1 ? (xMulOpType)sdp_cfg_x1_mul_op : (xMulOpType)sdp_cfg_x2_mul_op )));
+    //cslDebug((30, "cfg_alu_op:      0x%x\n", (uint32_t)(is_x1 ? (xAluOpType)sdp_cfg_x1_alu_op : (xAluOpType)sdp_cfg_x2_alu_op )));
+    //cslDebug((30, "cfg_alu_bypass:  0x%x\n", (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_alu_bypass : (ACINTF(1))sdp_cfg_x2_alu_bypass )));
+    //cslDebug((30, "cfg_alu_algo:    0x%x\n", (uint32_t)(is_x1 ? (ACINTF(2))sdp_cfg_x1_alu_algo : (ACINTF(2))sdp_cfg_x2_alu_algo )));
+    //cslDebug((30, "cfg_alu_src:     0x%x\n", (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_alu_src : (ACINTF(1))sdp_cfg_x2_alu_src )));
+    //cslDebug((30, "cfg_alu_shift_value:0x%x\n",         (uint32_t)(is_x1 ? (ACINTF(8))sdp_cfg_x1_alu_shift_value : (ACINTF(8))sdp_cfg_x2_alu_shift_value)));
+    //cslDebug((30, "cfg_mul_bypass:  0x%x\n",            (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_mul_bypass : (ACINTF(1))sdp_cfg_x2_mul_bypass          )));
+    //cslDebug((30, "cfg_mul_src:     0x%x\n",            (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_mul_src : (ACINTF(1))sdp_cfg_x2_mul_src                )));
+    //cslDebug((30, "cfg_mul_shift_value:0x%x\n",         (uint32_t)(is_x1 ? (ACINTF(8))sdp_cfg_x1_mul_shift_value : (ACINTF(8))sdp_cfg_x2_mul_shift_value)));
+    //cslDebug((30, "cfg_mul_prelu    :0x%x\n",           (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_mul_prelu : (ACINTF(1))sdp_cfg_x2_mul_prelu            )));
+    //cslDebug((30, "cfg_relu_bypass  :0x%x\n",           (uint32_t)(is_x1 ? (ACINTF(1))sdp_cfg_x1_relu_bypass : (ACINTF(1))sdp_cfg_x2_relu_bypass        )));
+    //cslDebug((30, "cfg_nan_to_zero  :0x%x\n", (uint32_t)sdp_cfg_nan_to_zero));
+    //cslDebug((30, "cfg_precision    :0x%x\n", (uint32_t)sdp_cfg_proc_precision));
+    //cslDebug((30, "chn_data_out:\n"));
     for (i=0; i<16; i++) {
-        cslDebug((30, "0x%08x ", (uint32_t)sdp_data[i]));
+        //cslDebug((30, "0x%08x ", (uint32_t)sdp_data[i]));
     }
-    cslDebug((30, "\n"));
+    //cslDebug((30, "\n"));
 #endif
 
 
@@ -233,103 +233,103 @@ void sdp_hls_wrapper::sdp_y(int32_t *sdp_data_in, int16_t *sdp_alu_op, int16_t *
                 );
 
 #ifdef  HLS_TRACE
-        cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_top on %d iter\n", HLS_TRACE, hls_core_y_iter++));
-        cslDebug((30, "chn_data_in:\n"));
+        //cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_top on %d iter\n", HLS_TRACE, hls_core_y_iter++));
+        //cslDebug((30, "chn_data_in:\n"));
         for(i = 0; i < SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", (uint32_t)data_in.data[i]));
+            //cslDebug((30, "0x%08x ", (uint32_t)data_in.data[i]));
         }
-        cslDebug((30, "\n"));
-        cslDebug((30, "cfg_alu_bypass:      0x%x\n", (uint32_t)sdp_cfg_y_alu_bypass));
-        cslDebug((30, "cfg_alu_algo:        0x%x\n", (uint32_t)sdp_cfg_y_alu_algo));
-        cslDebug((30, "cfg_mul_bypass:      0x%x\n", (uint32_t)sdp_cfg_y_mul_bypass));
-        cslDebug((30, "cfg_truncate:        0x%x\n", (uint32_t)sdp_cfg_y_truncate));
-        cslDebug((30, "cfg_mul_prelu:       0x%x\n", (uint32_t)sdp_cfg_y_mul_prelu));
-        cslDebug((30, "cfg_nan_to_zero:     0x%x\n", (uint32_t)sdp_cfg_nan_to_zero));
-        cslDebug((30, "cfg_precision:       0x%x\n", (uint32_t)sdp_cfg_proc_precision));
-        cslDebug((30, "chn_alu_in:\n"));
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "cfg_alu_bypass:      0x%x\n", (uint32_t)sdp_cfg_y_alu_bypass));
+        //cslDebug((30, "cfg_alu_algo:        0x%x\n", (uint32_t)sdp_cfg_y_alu_algo));
+        //cslDebug((30, "cfg_mul_bypass:      0x%x\n", (uint32_t)sdp_cfg_y_mul_bypass));
+        //cslDebug((30, "cfg_truncate:        0x%x\n", (uint32_t)sdp_cfg_y_truncate));
+        //cslDebug((30, "cfg_mul_prelu:       0x%x\n", (uint32_t)sdp_cfg_y_mul_prelu));
+        //cslDebug((30, "cfg_nan_to_zero:     0x%x\n", (uint32_t)sdp_cfg_nan_to_zero));
+        //cslDebug((30, "cfg_precision:       0x%x\n", (uint32_t)sdp_cfg_proc_precision));
+        //cslDebug((30, "chn_alu_in:\n"));
         for(i = 0; i < SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", (uint32_t)alu_op.data[i]));
+            //cslDebug((30, "0x%08x ", (uint32_t)alu_op.data[i]));
         }
-        cslDebug((30, "\n"));
-        cslDebug((30, "cfg_alu_in:          0x%x\n", (uint32_t)sdp_cfg_y_alu_op));
-        cslDebug((30, "cfg_alu_src:         0x%x\n", (uint32_t)sdp_cfg_y_alu_src));
-        cslDebug((30, "cfg_alu_cvt_bypass:  0x%x\n", (uint32_t)sdp_cfg_y_alu_cvt_bypass));
-        cslDebug((30, "cfg_alu_cvt_offset:  0x%x\n", (uint32_t)sdp_cfg_y_alu_cvt_offset));
-        cslDebug((30, "cfg_alu_cvt_scale:   0x%x\n", (uint32_t)sdp_cfg_y_alu_cvt_scale));
-        cslDebug((30, "cfg_alu_cvt_truncate:0x%x\n", (uint32_t)sdp_cfg_y_alu_cvt_truncate));
-        cslDebug((30, "chn_mul_in:\n"));
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "cfg_alu_in:          0x%x\n", (uint32_t)sdp_cfg_y_alu_op));
+        //cslDebug((30, "cfg_alu_src:         0x%x\n", (uint32_t)sdp_cfg_y_alu_src));
+        //cslDebug((30, "cfg_alu_cvt_bypass:  0x%x\n", (uint32_t)sdp_cfg_y_alu_cvt_bypass));
+        //cslDebug((30, "cfg_alu_cvt_offset:  0x%x\n", (uint32_t)sdp_cfg_y_alu_cvt_offset));
+        //cslDebug((30, "cfg_alu_cvt_scale:   0x%x\n", (uint32_t)sdp_cfg_y_alu_cvt_scale));
+        //cslDebug((30, "cfg_alu_cvt_truncate:0x%x\n", (uint32_t)sdp_cfg_y_alu_cvt_truncate));
+        //cslDebug((30, "chn_mul_in:\n"));
         for(i = 0; i < SPEED_Y; i++) {
-            cslDebug((30, "0x%08x ", (uint32_t)mul_op.data[i]));
+            //cslDebug((30, "0x%08x ", (uint32_t)mul_op.data[i]));
         }
-        cslDebug((30, "\n"));
-        cslDebug((30, "cfg_mul_in:          0x%x\n", (uint32_t)sdp_cfg_y_mul_op));
-        cslDebug((30, "cfg_mul_src:         0x%x\n", (uint32_t)sdp_cfg_y_mul_src));
-        cslDebug((30, "cfg_mul_cvt_bypass:  0x%x\n", (uint32_t)sdp_cfg_y_mul_cvt_bypass));
-        cslDebug((30, "cfg_mul_cvt_offset:  0x%x\n", (uint32_t)sdp_cfg_y_mul_cvt_offset));
-        cslDebug((30, "cfg_mul_cvt_scale:   0x%x\n", (uint32_t)sdp_cfg_y_mul_cvt_scale));
-        cslDebug((30, "cfg_mul_cvt_truncate:0x%x\n", (uint32_t)sdp_cfg_y_mul_cvt_truncate));
-
-        cslDebug((30, "cfg_lut_le_start:0x%x\n",        (uint32_t)sdp_cfg_y_lut_le_start));
-        cslDebug((30, "cfg_lut_lo_start:0x%x\n",        (uint32_t)sdp_cfg_y_lut_lo_start));
-        cslDebug((30, "cfg_lut_le_index_offset:0x%x\n", (uint32_t)sdp_cfg_y_lut_le_index_offset));
-        cslDebug((30, "cfg_lut_le_index_select:0x%x\n", (uint32_t)sdp_cfg_y_lut_le_index_select));
-        cslDebug((30, "cfg_lut_lo_index_select:0x%x\n", (uint32_t)sdp_cfg_y_lut_lo_index_select));
-        cslDebug((30, "cfg_lut_le_function:0x%x\n",     (uint32_t)sdp_cfg_y_lut_le_function));
-        cslDebug((30, "cfg_lut_uflow_priority:0x%x\n",  (uint32_t)sdp_cfg_y_lut_out_sel_u_miss));
-        cslDebug((30, "cfg_lut_oflow_priority:0x%x\n",  (uint32_t)sdp_cfg_y_lut_out_sel_o_miss));
-        cslDebug((30, "cfg_lut_hybrid_priority:0x%x\n", (uint32_t)sdp_cfg_y_lut_out_sel_hybrid));
-        cslDebug((30, "cfg_lut_bypass:0x%x\n",          (uint32_t)sdp_cfg_y_lut_bypass));
+        //cslDebug((30, "\n"));
+        //cslDebug((30, "cfg_mul_in:          0x%x\n", (uint32_t)sdp_cfg_y_mul_op));
+        //cslDebug((30, "cfg_mul_src:         0x%x\n", (uint32_t)sdp_cfg_y_mul_src));
+        //cslDebug((30, "cfg_mul_cvt_bypass:  0x%x\n", (uint32_t)sdp_cfg_y_mul_cvt_bypass));
+        //cslDebug((30, "cfg_mul_cvt_offset:  0x%x\n", (uint32_t)sdp_cfg_y_mul_cvt_offset));
+        //cslDebug((30, "cfg_mul_cvt_scale:   0x%x\n", (uint32_t)sdp_cfg_y_mul_cvt_scale));
+        //cslDebug((30, "cfg_mul_cvt_truncate:0x%x\n", (uint32_t)sdp_cfg_y_mul_cvt_truncate));
+
+        //cslDebug((30, "cfg_lut_le_start:0x%x\n",        (uint32_t)sdp_cfg_y_lut_le_start));
+        //cslDebug((30, "cfg_lut_lo_start:0x%x\n",        (uint32_t)sdp_cfg_y_lut_lo_start));
+        //cslDebug((30, "cfg_lut_le_index_offset:0x%x\n", (uint32_t)sdp_cfg_y_lut_le_index_offset));
+        //cslDebug((30, "cfg_lut_le_index_select:0x%x\n", (uint32_t)sdp_cfg_y_lut_le_index_select));
+        //cslDebug((30, "cfg_lut_lo_index_select:0x%x\n", (uint32_t)sdp_cfg_y_lut_lo_index_select));
+        //cslDebug((30, "cfg_lut_le_function:0x%x\n",     (uint32_t)sdp_cfg_y_lut_le_function));
+        //cslDebug((30, "cfg_lut_uflow_priority:0x%x\n",  (uint32_t)sdp_cfg_y_lut_out_sel_u_miss));
+        //cslDebug((30, "cfg_lut_oflow_priority:0x%x\n",  (uint32_t)sdp_cfg_y_lut_out_sel_o_miss));
+        //cslDebug((30, "cfg_lut_hybrid_priority:0x%x\n", (uint32_t)sdp_cfg_y_lut_out_sel_hybrid));
+        //cslDebug((30, "cfg_lut_bypass:0x%x\n",          (uint32_t)sdp_cfg_y_lut_bypass));
         if (chn_y_lut_out.size() > 0) {
             y_lut_out = chn_y_lut_out.read();
 
-            cslDebug((30, "chn_y_lut_out.fraction:\n"));
+            //cslDebug((30, "chn_y_lut_out.fraction:\n"));
             for(i = 0; i < SPEED_Y; i++) {
-                cslDebug((30, "0x%016lx ", (int64_t)y_lut_out.fraction[i].to_int64()));
+                //cslDebug((30, "0x%016lx ", (int64_t)y_lut_out.fraction[i].to_int64()));
             }
-            cslDebug((30, "\n"));   
-            cslDebug((30, "chn_y_lut_out.x:\n"));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "chn_y_lut_out.x:\n"));
             for(i = 0; i < SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.x[i]));
+                //cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.x[i]));
             }
-            cslDebug((30, "\n"));   
-            cslDebug((30, "chn_y_lut_out.oflow:\n"));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "chn_y_lut_out.oflow:\n"));
             for(i = 0; i < SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.oflow[i]));
+                //cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.oflow[i]));
             }
-            cslDebug((30, "\n"));   
-            cslDebug((30, "chn_y_lut_out.uflow:\n"));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "chn_y_lut_out.uflow:\n"));
             for(i = 0; i < SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.uflow[i]));
+                //cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.uflow[i]));
             }
-            cslDebug((30, "\n"));   
-            cslDebug((30, "chn_y_lut_out.ram_sel:\n"));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "chn_y_lut_out.ram_sel:\n"));
             for(i = 0; i < SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.ram_sel[i]));
+                //cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.ram_sel[i]));
             }
-            cslDebug((30, "\n"));   
-            cslDebug((30, "chn_y_lut_out.ram_addr:\n"));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "chn_y_lut_out.ram_addr:\n"));
             for(i = 0; i < SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.ram_addr[i]));
+                //cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.ram_addr[i]));
             }
-            cslDebug((30, "\n"));   
-            cslDebug((30, "chn_y_lut_out.le_hit:\n"));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "chn_y_lut_out.le_hit:\n"));
             for(i = 0; i < SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.le_hit[i]));
+                //cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.le_hit[i]));
             }
-            cslDebug((30, "\n"));   
-            cslDebug((30, "chn_y_lut_out.lo_hit:\n"));
+            //cslDebug((30, "\n"));
+            //cslDebug((30, "chn_y_lut_out.lo_hit:\n"));
             for(i = 0; i < SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.lo_hit[i]));
+                //cslDebug((30, "0x%08x ", (uint32_t)y_lut_out.lo_hit[i]));
             }
-            cslDebug((30, "\n"));  
+            //cslDebug((30, "\n"));
         }
         if (chn_y_data_out.size() > 0) {
             y_out = chn_y_data_out.read();
-            cslDebug((30, "chn_y_data_out.data:\n"));
+            //cslDebug((30, "chn_y_data_out.data:\n"));
             for(i = 0; i < SPEED_Y; i++) {
-                cslDebug((30, "0x%08x ", (uint32_t)y_out.data[i].to_int()));
+                //cslDebug((30, "0x%08x ", (uint32_t)y_out.data[i].to_int()));
             }
-            cslDebug((30, "\n"));   
+            //cslDebug((30, "\n"));
         }
 #endif
 
@@ -399,57 +399,57 @@ void sdp_hls_wrapper::sdp_y(int32_t *sdp_data_in, int16_t *sdp_alu_op, int16_t *
                 out[iter*SPEED_Y + i] = inp_out.data[i].to_int();
             }
 #ifdef HLS_TRACE
-            cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_inp on %d iter\n", HLS_TRACE, hls_core_y_inp_iter++));
-            cslDebug((70, "\t inp_op.x:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%08x, ", (uint32_t)inp_op.x[i]));
-            }
-            cslDebug((70, "\n"));
-            cslDebug((70, "\t inp_op.fraction:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%020lx, ", (uint64_t)inp_op.fraction[i]));
-            }
-            cslDebug((70, "\n"));
-            cslDebug((70, "\t inp_op.y0:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%08x, ", (uint32_t)inp_op.y0[i]));
-            }
-            cslDebug((70, "\n"));
-            cslDebug((70, "\t inp_op.y1:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%08x, ", (uint32_t)inp_op.y1[i]));
-            }
-            cslDebug((70, "\n"));
-            cslDebug((70, "\t inp_op.scale:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%08x, ", (uint32_t)inp_op.scale[i]));
-            }
-            cslDebug((70, "\n"));
-            cslDebug((70, "\t inp_op.shift:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%08x, ", (uint32_t)inp_op.shift[i]));
-            }
-            cslDebug((70, "\n"));
-            cslDebug((70, "\t inp_op.offset:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%08x, ", (uint32_t)inp_op.offset[i]));
-            }
-            cslDebug((70, "\n"));
-            cslDebug((70, "\t inp_op.flow:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%08x, ", (uint32_t)inp_op.flow[i]));
-            }
-            cslDebug((70, "\n"));
-            cslDebug((70, "\t inp_op.bias:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%08x, ", (uint32_t)inp_op.bias[i]));
-            }
-            cslDebug((70, "\n"));
-            cslDebug((70, "\t chn_inp_out.data:\n\t"));
-            for(int i = 0; i < SPEED_Y; i++) {
-                cslDebug((70, "0x%08x, ", (uint32_t)out[iter*SPEED_Y+i]));
-            }
-            cslDebug((70, "\n"));
+            //cslDebug((30, "%s call NV_NVDLA_SDP_CORE_Y_inp on %d iter\n", HLS_TRACE, hls_core_y_inp_iter++));
+            //cslDebug((70, "\t inp_op.x:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%08x, ", (uint32_t)inp_op.x[i]));
+            //}
+            //cslDebug((70, "\n"));
+            //cslDebug((70, "\t inp_op.fraction:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%020lx, ", (uint64_t)inp_op.fraction[i]));
+            //}
+            //cslDebug((70, "\n"));
+            //cslDebug((70, "\t inp_op.y0:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%08x, ", (uint32_t)inp_op.y0[i]));
+            //}
+            //cslDebug((70, "\n"));
+            //cslDebug((70, "\t inp_op.y1:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%08x, ", (uint32_t)inp_op.y1[i]));
+            //}
+            //cslDebug((70, "\n"));
+            //cslDebug((70, "\t inp_op.scale:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%08x, ", (uint32_t)inp_op.scale[i]));
+            //}
+            //cslDebug((70, "\n"));
+            //cslDebug((70, "\t inp_op.shift:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%08x, ", (uint32_t)inp_op.shift[i]));
+            //}
+            //cslDebug((70, "\n"));
+            //cslDebug((70, "\t inp_op.offset:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%08x, ", (uint32_t)inp_op.offset[i]));
+            //}
+            //cslDebug((70, "\n"));
+            //cslDebug((70, "\t inp_op.flow:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%08x, ", (uint32_t)inp_op.flow[i]));
+            //}
+            //cslDebug((70, "\n"));
+            //cslDebug((70, "\t inp_op.bias:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%08x, ", (uint32_t)inp_op.bias[i]));
+            //}
+            //cslDebug((70, "\n"));
+            //cslDebug((70, "\t chn_inp_out.data:\n\t"));
+            //for(int i = 0; i < SPEED_Y; i++) {
+            //    cslDebug((70, "0x%08x, ", (uint32_t)out[iter*SPEED_Y+i]));
+            //}
+            //cslDebug((70, "\n"));
 #endif
 
         } else {
@@ -496,24 +496,24 @@ void sdp_hls_wrapper::sdp_c(ac_channel<cDataInStruct> & chn_in)
     }
 
 #ifdef HLS_TRACE
-    cslDebug((30, "%s call NV_NVDLA_SDP_CORE_c on %d iter\n", HLS_TRACE, hls_core_c_iter++));
-    cslDebug((30, "chn_in.data:\n"));
-    for(i = 0; i < 16; i++) {
-        cslDebug((30, "0x%08x ", in.data[i].to_int()));
-    }
-    cslDebug((30, "\n"));   
-    cslDebug((30, "cfg_offset:          0x%x\n", (uint32_t)sdp_cfg_cvt_offset));
-    cslDebug((30, "cfg_scale:           0x%x\n", (uint32_t)sdp_cfg_cvt_scale));
-    cslDebug((30, "cfg_shift:           0x%x\n", (uint32_t)sdp_cfg_cvt_shift));
-    cslDebug((30, "cfg_proc_precision:  0x%x\n", (uint32_t)sdp_cfg_proc_precision));
-    cslDebug((30, "cfg_out_precision:   0x%x\n", (uint32_t)sdp_cfg_out_precision));
-    //cslDebug((30, "status_saturation:   0x%x\n", status_saturation));
-    cslDebug((30, "chn_out.data:\n"));
-    for(i = 0; i < 16; i++) {
-        cslDebug((30, "0x%08x ", (uint32_t)sdp_data_out[i]));
-        cslDebug((30, "0x%08x ", (uint32_t)saturate[i]));
-    }
-    cslDebug((30, "\n"));   
+    //cslDebug((30, "%s call NV_NVDLA_SDP_CORE_c on %d iter\n", HLS_TRACE, hls_core_c_iter++));
+    //cslDebug((30, "chn_in.data:\n"));
+    //for(i = 0; i < 16; i++) {
+    //    cslDebug((30, "0x%08x ", in.data[i].to_int()));
+    //}
+    //cslDebug((30, "\n"));
+    //cslDebug((30, "cfg_offset:          0x%x\n", (uint32_t)sdp_cfg_cvt_offset));
+    //cslDebug((30, "cfg_scale:           0x%x\n", (uint32_t)sdp_cfg_cvt_scale));
+    //cslDebug((30, "cfg_shift:           0x%x\n", (uint32_t)sdp_cfg_cvt_shift));
+    //cslDebug((30, "cfg_proc_precision:  0x%x\n", (uint32_t)sdp_cfg_proc_precision));
+    //cslDebug((30, "cfg_out_precision:   0x%x\n", (uint32_t)sdp_cfg_out_precision));
+    ////cslDebug((30, "status_saturation:   0x%x\n", status_saturation));
+    //cslDebug((30, "chn_out.data:\n"));
+    //for(i = 0; i < 16; i++) {
+    //    cslDebug((30, "0x%08x ", (uint32_t)sdp_data_out[i]));
+    //    cslDebug((30, "0x%08x ", (uint32_t)saturate[i]));
+    //}
+    //cslDebug((30, "\n"));
 #endif
 }
 
diff --git a/cmod/include/NvdlaAvgPooling.h b/cmod/include/NvdlaAvgPooling.h
index 9799294..c505785 100644
--- a/cmod/include/NvdlaAvgPooling.h
+++ b/cmod/include/NvdlaAvgPooling.h
@@ -51,7 +51,7 @@ class NvdlaAvgPooling {
 };
 
 NvdlaAvgPooling::NvdlaAvgPooling(uint8_t    data_type, uint32_t * scaling_factor, uint8_t    truncation_lsb, uint8_t    truncation_bit_width) {
-    cslInfo(("NvdlaAvgPooling::NvdlaAvgPooling: Enter constructor.\n"));
+    //cslInfo(("NvdlaAvgPooling::NvdlaAvgPooling: Enter constructor.\n"));
     set_data_type(data_type);
     set_scaling_factor(scaling_factor);
     set_truncation_lsb(truncation_lsb);
@@ -60,7 +60,7 @@ NvdlaAvgPooling::NvdlaAvgPooling(uint8_t    data_type, uint32_t * scaling_factor
 
 void NvdlaAvgPooling::set_data_type        (uint8_t    data_type){
     data_type_ = data_type;
-    cslInfo(("NvdlaAvgPooling::set_data_type: data type is %d\n", uint16_t(data_type_)));
+    //cslInfo(("NvdlaAvgPooling::set_data_type: data type is %d\n", uint16_t(data_type_)));
 }
 
 void NvdlaAvgPooling::set_scaling_factor   (uint32_t   * scaling_factor){
@@ -77,12 +77,12 @@ void NvdlaAvgPooling::set_scaling_factor   (uint32_t   * scaling_factor){
 
 void NvdlaAvgPooling::set_truncation_lsb  (uint8_t    truncation_lsb){
     truncation_lsb_ = truncation_lsb;
-    cslInfo(("NvdlaAvgPooling::set_truncation_lsb: truncation lsb is %d\n", uint16_t(truncation_lsb_)));
+    //cslInfo(("NvdlaAvgPooling::set_truncation_lsb: truncation lsb is %d\n", uint16_t(truncation_lsb_)));
 }
 
 void NvdlaAvgPooling::set_truncation_bit_width (uint8_t    truncation_bit_width){
     truncation_bit_width_ = truncation_bit_width;
-    cslInfo(("NvdlaAvgPooling::set_truncation_bit_width: truncation bit width is %d\n", uint16_t(truncation_bit_width_)));
+    //cslInfo(("NvdlaAvgPooling::set_truncation_bit_width: truncation bit width is %d\n", uint16_t(truncation_bit_width_)));
 }
 
 template <typename T_IN, typename T_OUT>
diff --git a/cmod/include/NvdlaDataFormatConvertor.h b/cmod/include/NvdlaDataFormatConvertor.h
index 744a28b..467bcd0 100644
--- a/cmod/include/NvdlaDataFormatConvertor.h
+++ b/cmod/include/NvdlaDataFormatConvertor.h
@@ -103,13 +103,13 @@ void NvdlaDataFormatConvertor::do_conversion (T_IN * const data_in, T_OUT * cons
         }
         mask = mask << truncation_lsb_;
         for (idx=0; idx < data_num; idx ++) {
-            cslInfo(("Input data is 0x%x\n", *data_in));
+            //cslInfo(("Input data is 0x%x\n", *data_in));
             data_template = (int64_t(data_in[idx]) - offset_int_) * scaling_factor_int_;
-            cslInfo(("Data template is 0x%x\n", data_template));
+            //cslInfo(("Data template is 0x%x\n", data_template));
             // data_template = int64_t (mask & (*reinterpret_cast <uint64_t*> (&data_template)));
             // *data_out = T_OUT( (*reinterpret_cast <int64_t*> (mask & (*reinterpret_cast <uint64_t*> (&data_template))) >> truncation_lsb_) );
             data_out[idx] = T_OUT( (int64_t (mask & (*reinterpret_cast <uint64_t*> (&data_template))) >> truncation_lsb_) );
-            cslInfo(("Output data is 0x%x\n", *data_out));
+            //cslInfo(("Output data is 0x%x\n", *data_out));
         }
     }
 }
diff --git a/cmod/mcif/gen/NV_NVDLA_mcif.cpp b/cmod/mcif/gen/NV_NVDLA_mcif.cpp
index e7109b2..22e95d2 100644
--- a/cmod/mcif/gen/NV_NVDLA_mcif.cpp
+++ b/cmod/mcif/gen/NV_NVDLA_mcif.cpp
@@ -304,14 +304,14 @@ void NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     bdma2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write 0x%x to bdma2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, bdma2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write 0x%x to bdma2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, bdma2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -324,9 +324,9 @@ void NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -353,13 +353,13 @@ void NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
                         bdma_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write false to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write false to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
                         bdma_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -368,13 +368,13 @@ void NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
                         bdma_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write false to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write false to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
                         bdma_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -382,7 +382,7 @@ void NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, write true to bdma_rd_atom_enable_fifo_, num_free:%d\x0A", bdma_rd_atom_enable_fifo_->num_free()));
                     bdma_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -396,13 +396,13 @@ void NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pay
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, before sending data to bdma_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, bdma_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, before sending data to bdma_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, bdma_rd_req_fifo_->num_free()));
         bdma_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, after sending data to bdma_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, after sending data to bdma_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::bdma2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2bdma() {
@@ -415,11 +415,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2bdma() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, num_available:%d\x0A", bdma2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, num_available:%d\x0A", bdma2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = bdma2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, update atom_num_left from bdma2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, update atom_num_left from bdma2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -427,10 +427,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2bdma() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, num_available:%d\x0A", mcif2bdma_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, num_available:%d\x0A", mcif2bdma_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2bdma_rd_rsp_fifo_->read();
         credit_mcif2bdma_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, read 1st atom of the 64B from mcif2bdma_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, read 1st atom of the 64B from mcif2bdma_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -439,24 +439,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2bdma() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, num_available:%d\x0A", mcif2bdma_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, num_available:%d\x0A", mcif2bdma_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2bdma_rd_rsp_fifo_->read();
             credit_mcif2bdma_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, read 2nd atom of the 64B from mcif2bdma_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, read 2nd atom of the 64B from mcif2bdma_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2bdma, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2bdma, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2bdma, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2bdma, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, before NV_NVDLA_mcif_base::mcif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, before NV_NVDLA_mcif_base::mcif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, after NV_NVDLA_mcif_base::mcif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2bdma, after NV_NVDLA_mcif_base::mcif2bdma_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -487,14 +487,14 @@ void NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     sdp2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write 0x%x to sdp2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, sdp2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write 0x%x to sdp2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, sdp2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -507,9 +507,9 @@ void NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -536,13 +536,13 @@ void NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
                         sdp_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write false to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write false to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
                         sdp_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -551,13 +551,13 @@ void NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
                         sdp_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write false to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write false to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
                         sdp_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -565,7 +565,7 @@ void NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, write true to sdp_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_rd_atom_enable_fifo_->num_free()));
                     sdp_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -579,13 +579,13 @@ void NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, before sending data to sdp_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, sdp_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, before sending data to sdp_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, sdp_rd_req_fifo_->num_free()));
         sdp_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, after sending data to sdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, after sending data to sdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2sdp() {
@@ -598,11 +598,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, num_available:%d\x0A", sdp2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, num_available:%d\x0A", sdp2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = sdp2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, update atom_num_left from sdp2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, update atom_num_left from sdp2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -610,10 +610,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, num_available:%d\x0A", mcif2sdp_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, num_available:%d\x0A", mcif2sdp_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2sdp_rd_rsp_fifo_->read();
         credit_mcif2sdp_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, read 1st atom of the 64B from mcif2sdp_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, read 1st atom of the 64B from mcif2sdp_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -622,24 +622,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, num_available:%d\x0A", mcif2sdp_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, num_available:%d\x0A", mcif2sdp_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2sdp_rd_rsp_fifo_->read();
             credit_mcif2sdp_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, read 2nd atom of the 64B from mcif2sdp_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, read 2nd atom of the 64B from mcif2sdp_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, before NV_NVDLA_mcif_base::mcif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, before NV_NVDLA_mcif_base::mcif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, after NV_NVDLA_mcif_base::mcif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp, after NV_NVDLA_mcif_base::mcif2sdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -670,14 +670,14 @@ void NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     pdp2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write 0x%x to pdp2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, pdp2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write 0x%x to pdp2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, pdp2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -690,9 +690,9 @@ void NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -719,13 +719,13 @@ void NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
                         pdp_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write false to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write false to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
                         pdp_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -734,13 +734,13 @@ void NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
                         pdp_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write false to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write false to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
                         pdp_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -748,7 +748,7 @@ void NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, write true to pdp_rd_atom_enable_fifo_, num_free:%d\x0A", pdp_rd_atom_enable_fifo_->num_free()));
                     pdp_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -762,13 +762,13 @@ void NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, before sending data to pdp_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, pdp_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, before sending data to pdp_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, pdp_rd_req_fifo_->num_free()));
         pdp_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, after sending data to pdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, after sending data to pdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::pdp2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2pdp() {
@@ -781,11 +781,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2pdp() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, num_available:%d\x0A", pdp2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, num_available:%d\x0A", pdp2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = pdp2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, update atom_num_left from pdp2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, update atom_num_left from pdp2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -793,10 +793,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2pdp() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, num_available:%d\x0A", mcif2pdp_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, num_available:%d\x0A", mcif2pdp_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2pdp_rd_rsp_fifo_->read();
         credit_mcif2pdp_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, read 1st atom of the 64B from mcif2pdp_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, read 1st atom of the 64B from mcif2pdp_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -805,24 +805,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2pdp() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, num_available:%d\x0A", mcif2pdp_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, num_available:%d\x0A", mcif2pdp_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2pdp_rd_rsp_fifo_->read();
             credit_mcif2pdp_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, read 2nd atom of the 64B from mcif2pdp_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, read 2nd atom of the 64B from mcif2pdp_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2pdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2pdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2pdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2pdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, before NV_NVDLA_mcif_base::mcif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, before NV_NVDLA_mcif_base::mcif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, after NV_NVDLA_mcif_base::mcif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2pdp, after NV_NVDLA_mcif_base::mcif2pdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -853,14 +853,14 @@ void NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     cdp2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write 0x%x to cdp2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, cdp2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write 0x%x to cdp2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, cdp2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -873,9 +873,9 @@ void NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -902,13 +902,13 @@ void NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
                         cdp_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write false to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write false to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
                         cdp_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -917,13 +917,13 @@ void NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
                         cdp_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write false to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write false to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
                         cdp_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -931,7 +931,7 @@ void NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, write true to cdp_rd_atom_enable_fifo_, num_free:%d\x0A", cdp_rd_atom_enable_fifo_->num_free()));
                     cdp_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -945,13 +945,13 @@ void NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, before sending data to cdp_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, cdp_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, before sending data to cdp_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, cdp_rd_req_fifo_->num_free()));
         cdp_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, after sending data to cdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, after sending data to cdp_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::cdp2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2cdp() {
@@ -964,11 +964,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2cdp() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, num_available:%d\x0A", cdp2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, num_available:%d\x0A", cdp2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = cdp2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, update atom_num_left from cdp2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, update atom_num_left from cdp2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -976,10 +976,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2cdp() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, num_available:%d\x0A", mcif2cdp_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, num_available:%d\x0A", mcif2cdp_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2cdp_rd_rsp_fifo_->read();
         credit_mcif2cdp_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, read 1st atom of the 64B from mcif2cdp_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, read 1st atom of the 64B from mcif2cdp_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -988,24 +988,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2cdp() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, num_available:%d\x0A", mcif2cdp_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, num_available:%d\x0A", mcif2cdp_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2cdp_rd_rsp_fifo_->read();
             credit_mcif2cdp_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, read 2nd atom of the 64B from mcif2cdp_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, read 2nd atom of the 64B from mcif2cdp_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdp, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdp, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, before NV_NVDLA_mcif_base::mcif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, before NV_NVDLA_mcif_base::mcif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, after NV_NVDLA_mcif_base::mcif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdp, after NV_NVDLA_mcif_base::mcif2cdp_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1036,14 +1036,14 @@ void NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     rbk2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write 0x%x to rbk2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, rbk2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write 0x%x to rbk2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, rbk2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -1056,9 +1056,9 @@ void NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1085,13 +1085,13 @@ void NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
                         rbk_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write false to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write false to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
                         rbk_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1100,13 +1100,13 @@ void NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
                         rbk_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write false to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write false to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
                         rbk_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1114,7 +1114,7 @@ void NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, write true to rbk_rd_atom_enable_fifo_, num_free:%d\x0A", rbk_rd_atom_enable_fifo_->num_free()));
                     rbk_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -1128,13 +1128,13 @@ void NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* payl
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, before sending data to rbk_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, rbk_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, before sending data to rbk_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, rbk_rd_req_fifo_->num_free()));
         rbk_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, after sending data to rbk_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, after sending data to rbk_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::rbk2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2rbk() {
@@ -1147,11 +1147,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2rbk() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, num_available:%d\x0A", rbk2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, num_available:%d\x0A", rbk2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = rbk2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, update atom_num_left from rbk2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, update atom_num_left from rbk2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -1159,10 +1159,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2rbk() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, num_available:%d\x0A", mcif2rbk_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, num_available:%d\x0A", mcif2rbk_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2rbk_rd_rsp_fifo_->read();
         credit_mcif2rbk_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, read 1st atom of the 64B from mcif2rbk_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, read 1st atom of the 64B from mcif2rbk_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -1171,24 +1171,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2rbk() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, num_available:%d\x0A", mcif2rbk_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, num_available:%d\x0A", mcif2rbk_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2rbk_rd_rsp_fifo_->read();
             credit_mcif2rbk_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, read 2nd atom of the 64B from mcif2rbk_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, read 2nd atom of the 64B from mcif2rbk_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2rbk, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2rbk, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2rbk, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2rbk, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
         for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, before NV_NVDLA_mcif_base::mcif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, before NV_NVDLA_mcif_base::mcif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, after NV_NVDLA_mcif_base::mcif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2rbk, after NV_NVDLA_mcif_base::mcif2rbk_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1219,14 +1219,14 @@ void NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     sdp_b2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write 0x%x to sdp_b2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, sdp_b2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write 0x%x to sdp_b2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, sdp_b2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -1239,9 +1239,9 @@ void NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1268,13 +1268,13 @@ void NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
                         sdp_b_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write false to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write false to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
                         sdp_b_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1283,13 +1283,13 @@ void NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
                         sdp_b_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write false to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write false to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
                         sdp_b_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1297,7 +1297,7 @@ void NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, write true to sdp_b_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_b_rd_atom_enable_fifo_->num_free()));
                     sdp_b_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -1311,13 +1311,13 @@ void NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, before sending data to sdp_b_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, sdp_b_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, before sending data to sdp_b_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, sdp_b_rd_req_fifo_->num_free()));
         sdp_b_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, after sending data to sdp_b_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, after sending data to sdp_b_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp_b2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2sdp_b() {
@@ -1330,11 +1330,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp_b() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, num_available:%d\x0A", sdp_b2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, num_available:%d\x0A", sdp_b2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = sdp_b2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, update atom_num_left from sdp_b2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, update atom_num_left from sdp_b2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -1342,10 +1342,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp_b() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, num_available:%d\x0A", mcif2sdp_b_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, num_available:%d\x0A", mcif2sdp_b_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2sdp_b_rd_rsp_fifo_->read();
         credit_mcif2sdp_b_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, read 1st atom of the 64B from mcif2sdp_b_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, read 1st atom of the 64B from mcif2sdp_b_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -1354,24 +1354,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp_b() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, num_available:%d\x0A", mcif2sdp_b_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, num_available:%d\x0A", mcif2sdp_b_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2sdp_b_rd_rsp_fifo_->read();
             credit_mcif2sdp_b_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, read 2nd atom of the 64B from mcif2sdp_b_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, read 2nd atom of the 64B from mcif2sdp_b_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
-        for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
-        }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, before NV_NVDLA_mcif_base::mcif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+        //}
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, before NV_NVDLA_mcif_base::mcif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, after NV_NVDLA_mcif_base::mcif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_b, after NV_NVDLA_mcif_base::mcif2sdp_b_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1402,14 +1402,14 @@ void NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     sdp_n2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write 0x%x to sdp_n2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, sdp_n2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write 0x%x to sdp_n2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, sdp_n2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -1422,9 +1422,9 @@ void NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1451,13 +1451,13 @@ void NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
                         sdp_n_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write false to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write false to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
                         sdp_n_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1466,13 +1466,13 @@ void NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
                         sdp_n_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write false to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write false to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
                         sdp_n_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1480,7 +1480,7 @@ void NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, write true to sdp_n_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_n_rd_atom_enable_fifo_->num_free()));
                     sdp_n_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -1494,13 +1494,13 @@ void NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, before sending data to sdp_n_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, sdp_n_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, before sending data to sdp_n_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, sdp_n_rd_req_fifo_->num_free()));
         sdp_n_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, after sending data to sdp_n_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, after sending data to sdp_n_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp_n2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2sdp_n() {
@@ -1513,11 +1513,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp_n() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, num_available:%d\x0A", sdp_n2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, num_available:%d\x0A", sdp_n2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = sdp_n2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, update atom_num_left from sdp_n2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, update atom_num_left from sdp_n2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -1525,10 +1525,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp_n() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, num_available:%d\x0A", mcif2sdp_n_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, num_available:%d\x0A", mcif2sdp_n_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2sdp_n_rd_rsp_fifo_->read();
         credit_mcif2sdp_n_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, read 1st atom of the 64B from mcif2sdp_n_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, read 1st atom of the 64B from mcif2sdp_n_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -1537,24 +1537,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp_n() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, num_available:%d\x0A", mcif2sdp_n_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, num_available:%d\x0A", mcif2sdp_n_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2sdp_n_rd_rsp_fifo_->read();
             credit_mcif2sdp_n_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, read 2nd atom of the 64B from mcif2sdp_n_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, read 2nd atom of the 64B from mcif2sdp_n_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
-        for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
-        }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, before NV_NVDLA_mcif_base::mcif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+        //}
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, before NV_NVDLA_mcif_base::mcif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, after NV_NVDLA_mcif_base::mcif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_n, after NV_NVDLA_mcif_base::mcif2sdp_n_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1585,14 +1585,14 @@ void NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     sdp_e2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write 0x%x to sdp_e2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, sdp_e2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write 0x%x to sdp_e2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, sdp_e2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -1605,9 +1605,9 @@ void NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1634,13 +1634,13 @@ void NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
                         sdp_e_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write false to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write false to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
                         sdp_e_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1649,13 +1649,13 @@ void NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
                         sdp_e_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write false to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write false to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
                         sdp_e_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1663,7 +1663,7 @@ void NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, write true to sdp_e_rd_atom_enable_fifo_, num_free:%d\x0A", sdp_e_rd_atom_enable_fifo_->num_free()));
                     sdp_e_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -1677,13 +1677,13 @@ void NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t* pa
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, before sending data to sdp_e_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, sdp_e_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, before sending data to sdp_e_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, sdp_e_rd_req_fifo_->num_free()));
         sdp_e_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, after sending data to sdp_e_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, after sending data to sdp_e_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::sdp_e2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2sdp_e() {
@@ -1696,11 +1696,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp_e() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, num_available:%d\x0A", sdp_e2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, num_available:%d\x0A", sdp_e2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = sdp_e2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, update atom_num_left from sdp_e2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, update atom_num_left from sdp_e2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -1708,10 +1708,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp_e() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, num_available:%d\x0A", mcif2sdp_e_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, num_available:%d\x0A", mcif2sdp_e_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2sdp_e_rd_rsp_fifo_->read();
         credit_mcif2sdp_e_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, read 1st atom of the 64B from mcif2sdp_e_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, read 1st atom of the 64B from mcif2sdp_e_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -1720,24 +1720,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2sdp_e() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, num_available:%d\x0A", mcif2sdp_e_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, num_available:%d\x0A", mcif2sdp_e_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2sdp_e_rd_rsp_fifo_->read();
             credit_mcif2sdp_e_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, read 2nd atom of the 64B from mcif2sdp_e_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, read 2nd atom of the 64B from mcif2sdp_e_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
-        for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
-        }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, before NV_NVDLA_mcif_base::mcif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+        //}
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, before NV_NVDLA_mcif_base::mcif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, after NV_NVDLA_mcif_base::mcif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2sdp_e, after NV_NVDLA_mcif_base::mcif2sdp_e_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1768,14 +1768,14 @@ void NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     cdma_dat2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write 0x%x to cdma_dat2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, cdma_dat2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write 0x%x to cdma_dat2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, cdma_dat2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -1788,9 +1788,9 @@ void NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -1817,13 +1817,13 @@ void NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
                         cdma_dat_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write false to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write false to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
                         cdma_dat_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1832,13 +1832,13 @@ void NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
                         cdma_dat_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write false to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write false to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
                         cdma_dat_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -1846,7 +1846,7 @@ void NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, write true to cdma_dat_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_dat_rd_atom_enable_fifo_->num_free()));
                     cdma_dat_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -1860,13 +1860,13 @@ void NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, before sending data to cdma_dat_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, cdma_dat_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, before sending data to cdma_dat_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, cdma_dat_rd_req_fifo_->num_free()));
         cdma_dat_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, after sending data to cdma_dat_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, after sending data to cdma_dat_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::cdma_dat2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2cdma_dat() {
@@ -1879,11 +1879,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2cdma_dat() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, num_available:%d\x0A", cdma_dat2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, num_available:%d\x0A", cdma_dat2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = cdma_dat2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, update atom_num_left from cdma_dat2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, update atom_num_left from cdma_dat2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -1891,10 +1891,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2cdma_dat() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, num_available:%d\x0A", mcif2cdma_dat_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, num_available:%d\x0A", mcif2cdma_dat_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2cdma_dat_rd_rsp_fifo_->read();
         credit_mcif2cdma_dat_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, read 1st atom of the 64B from mcif2cdma_dat_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, read 1st atom of the 64B from mcif2cdma_dat_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -1903,24 +1903,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2cdma_dat() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, num_available:%d\x0A", mcif2cdma_dat_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, num_available:%d\x0A", mcif2cdma_dat_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2cdma_dat_rd_rsp_fifo_->read();
             credit_mcif2cdma_dat_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, read 2nd atom of the 64B from mcif2cdma_dat_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, read 2nd atom of the 64B from mcif2cdma_dat_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
-        for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
-        }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, before NV_NVDLA_mcif_base::mcif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+        //}
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, before NV_NVDLA_mcif_base::mcif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, after NV_NVDLA_mcif_base::mcif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_dat, after NV_NVDLA_mcif_base::mcif2cdma_dat_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -1951,14 +1951,14 @@ void NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
 
     is_rear_64byte_align = (payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE == 0;
     total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((30, "XXXXXXX NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+    //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
     last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
 
     base_addr = first_base_addr;
 
     // Push the number of atoms of the request
     cdma_wt2mcif_rd_req_atom_num_fifo_->write(payload_size/DMA_TRANSACTION_ATOM_SIZE);
-    cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write 0x%x to cdma_wt2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, cdma_wt2mcif_rd_req_atom_num_fifo_->num_free()));
+    //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write 0x%x to cdma_wt2mcif_rd_req_atom_num_fifo_, num_free:%d.\x0A", payload_size/DMA_TRANSACTION_ATOM_SIZE, cdma_wt2mcif_rd_req_atom_num_fifo_->num_free()));
 
     if (total_axi_size <= (MCIF_MAX_MEM_TRANSACTION_SIZE - first_base_addr % MCIF_MAX_MEM_TRANSACTION_SIZE))
         user_size_first = total_axi_size / AXI_TRANSACTION_ATOM_SIZE - 1;
@@ -1971,9 +1971,9 @@ void NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
         user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
     //Split dma request to axi requests
-    cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
+    //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, before spliting DMA transaction. user_size_first=0x%x user_size_last=0x%x\x0A", user_size_first, user_size_last));
     while(base_addr <= last_base_addr) {
-        cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, prepare AXI transaction for address: 0x%lx\x0A", base_addr));
         // base_addr should be aligned to 64B
         // size_in_byte should be multiple of 64
         // if the data size required by dma mster is 32B, MCIF will drop the extra 32B when AXI returns
@@ -2000,13 +2000,13 @@ void NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
                         ( ( ( (true == is_base_64byte_align) && (byte_iter < DMA_TRANSACTION_ATOM_SIZE) ) || ( (true == is_rear_64byte_align) && (byte_iter >= DMA_TRANSACTION_ATOM_SIZE)) ) && (first_base_addr == base_addr)) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
                         cdma_wt_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write false to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write false to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
                         cdma_wt_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -2015,13 +2015,13 @@ void NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
                 if ( (true == is_base_64byte_align) || (byte_iter >= DMA_TRANSACTION_ATOM_SIZE) ){
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
                         cdma_wt_rd_atom_enable_fifo_->write(true);
                     }
                 } else {
                     axi_byte_enable_ptr[byte_iter] = TLM_BYTE_DISABLED;
                     if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                    cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write false to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
+                    //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write false to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
                         cdma_wt_rd_atom_enable_fifo_->write(false);
                     }
                 }
@@ -2029,7 +2029,7 @@ void NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
             else {
                 axi_byte_enable_ptr[byte_iter] = TLM_BYTE_ENABLED;
                 if (0 == byte_iter%DMA_TRANSACTION_ATOM_SIZE) {
-                cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
+                //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, write true to cdma_wt_rd_atom_enable_fifo_, num_free:%d\x0A", cdma_wt_rd_atom_enable_fifo_->num_free()));
                     cdma_wt_rd_atom_enable_fifo_->write(true);
                 }
             }
@@ -2043,13 +2043,13 @@ void NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport(int ID, nvdla_dma_rd_req_t*
         if(size_in_byte%AXI_TRANSACTION_ATOM_SIZE!=0)
             FAIL(("NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, size_in_byte is not multiple of AXI_TRANSACTION_ATOM_SIZE. size_in_byte=0x%x", size_in_byte));
 #pragma CTC ENDSKIP
-        cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, before sending data to cdma_wt_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, cdma_wt_rd_req_fifo_->num_free()));
+        //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, before sending data to cdma_wt_rd_req_fifo_ addr=0x%lx, , num_free:%d\x0A", base_addr, cdma_wt_rd_req_fifo_->num_free()));
         cdma_wt_rd_req_fifo_->write(bt_payload);
-        cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, after sending data to cdma_wt_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
+        //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, after sending data to cdma_wt_rd_req_fifo_ addr=0x%lx\x0A", base_addr));
 
         base_addr    += AXI_TRANSACTION_ATOM_SIZE;
     }
-    cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::cdma_wt2mcif_rd_req_b_transport, after spliting DMA transaction\x0A"));
 }
 
 void NV_NVDLA_mcif::ReadResp_mcif2cdma_wt() {
@@ -2062,11 +2062,11 @@ void NV_NVDLA_mcif::ReadResp_mcif2cdma_wt() {
     atom_num_left = 0;
     while(true) {
         if(0 == atom_num_left) {
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, num_available:%d\x0A", cdma_wt2mcif_rd_req_atom_num_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, num_available:%d\x0A", cdma_wt2mcif_rd_req_atom_num_fifo_->num_available()));
             atom_num_left = cdma_wt2mcif_rd_req_atom_num_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, update atom_num_left from cdma_wt2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, update atom_num_left from cdma_wt2mcif_rd_req_atom_num_fifo_, atom_num_left is 0x%x\x0A", atom_num_left));
         }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, atom_num_left is 0x%x\x0A", atom_num_left));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, atom_num_left is 0x%x\x0A", atom_num_left));
 
         dma_rd_rsp_payload      = new nvdla_dma_rd_rsp_t;
         dma_payload_data_ptr    = reinterpret_cast <uint8_t *> (dma_rd_rsp_payload->pd.dma_read_data.data);
@@ -2074,10 +2074,10 @@ void NV_NVDLA_mcif::ReadResp_mcif2cdma_wt() {
 
         // 1st atom of the 64B
         // Aligen to 32B
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, num_available:%d\x0A", mcif2cdma_wt_rd_rsp_fifo_->num_available()));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, num_available:%d\x0A", mcif2cdma_wt_rd_rsp_fifo_->num_available()));
         axi_atom_ptr = mcif2cdma_wt_rd_rsp_fifo_->read();
         credit_mcif2cdma_wt_rd_rsp_fifo_ ++;
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, read 1st atom of the 64B from mcif2cdma_wt_rd_rsp_fifo_\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, read 1st atom of the 64B from mcif2cdma_wt_rd_rsp_fifo_\x0A"));
         atom_num_left--;
 
         dma_rd_rsp_payload->pd.dma_read_data.mask = 0x1;
@@ -2086,24 +2086,24 @@ void NV_NVDLA_mcif::ReadResp_mcif2cdma_wt() {
 
         if(atom_num_left>0) {
             // 2nd atom of the 64B
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, num_available:%d\x0A", mcif2cdma_wt_rd_rsp_fifo_->num_available()));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, num_available:%d\x0A", mcif2cdma_wt_rd_rsp_fifo_->num_available()));
             axi_atom_ptr = mcif2cdma_wt_rd_rsp_fifo_->read();
             credit_mcif2cdma_wt_rd_rsp_fifo_ ++;
-            cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, read 2nd atom of the 64B from mcif2cdma_wt_rd_rsp_fifo_\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, read 2nd atom of the 64B from mcif2cdma_wt_rd_rsp_fifo_\x0A"));
             atom_num_left--;
             dma_rd_rsp_payload->pd.dma_read_data.mask = (dma_rd_rsp_payload->pd.dma_read_data.mask << 0x1) + 0x1;
             memcpy (&dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], axi_atom_ptr, DMA_TRANSACTION_ATOM_SIZE);
             delete[] axi_atom_ptr;
         }
 
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
-        cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
-        for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
-            cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
-        }
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, before NV_NVDLA_mcif_base::mcif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, dma_rd_rsp_payload->pd.dma_read_data.mask is 0x%x\x0A", uint32_t(dma_rd_rsp_payload->pd.dma_read_data.mask)));
+        //cslDebug((70, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, dma_rd_rsp_payload->pd.dma_read_data.data are :\x0A"));
+        //for (idx = 0; idx < sizeof(dma_rd_rsp_payload->pd.dma_read_data.data)/sizeof(dma_rd_rsp_payload->pd.dma_read_data.data[0]); idx++) {
+            //cslDebug((70, "    0x%lx\x0A", uint64_t (dma_rd_rsp_payload->pd.dma_read_data.data[idx])));   // The size of data[idx] is 8bytes and its type is "unsigned long"
+        //}
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, before NV_NVDLA_mcif_base::mcif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         NV_NVDLA_mcif_base::mcif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, after NV_NVDLA_mcif_base::mcif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
+        //cslDebug((50, "NV_NVDLA_mcif::ReadResp_mcif2cdma_wt, after NV_NVDLA_mcif_base::mcif2cdma_wt_rd_rsp_b_transport(dma_rd_rsp_payload, dma_delay_)\x0A"));
         delete dma_rd_rsp_payload;
     }
 }
@@ -2133,7 +2133,7 @@ void NV_NVDLA_mcif::bdma2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* pay
         bdma_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         bdma_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         bdma_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "write to bdma2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", bdma_wr_req->addr, bdma_wr_req->size, bdma2mcif_wr_cmd_fifo_->num_free()));
+        //cslDebug((50, "write to bdma2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", bdma_wr_req->addr, bdma_wr_req->size, bdma2mcif_wr_cmd_fifo_->num_free()));
         bdma2mcif_wr_cmd_fifo_->write(bdma_wr_req);
         bdma_wr_req_got_size_ = 0;
         bdma_wr_req_size_ = bdma_wr_req->size;
@@ -2144,25 +2144,25 @@ void NV_NVDLA_mcif::bdma2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* pay
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "write to bdma2mcif_wr_data_fifo_, num_free:%d\x0A", bdma2mcif_wr_data_fifo_->num_free()));
+        //cslDebug((50, "write to bdma2mcif_wr_data_fifo_, num_free:%d\x0A", bdma2mcif_wr_data_fifo_->num_free()));
         bdma2mcif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
         bdma_wr_req_got_size_ += incoming_size;
-        cslDebug((50, "bdma2mcif_wr_data_fifo_ data:\x0A"));
-        for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
-        }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "bdma2mcif_wr_data_fifo_ data:\x0A"));
+        //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+            //cslDebug((50, "%x ", data_ptr[i]));
+        //}
+        //cslDebug((50, "\x0A"));
 
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to bdma2mcif_wr_data_fifo_, num_free:%d\x0A", bdma2mcif_wr_data_fifo_->num_free()));
+            //cslDebug((50, "write to bdma2mcif_wr_data_fifo_, num_free:%d\x0A", bdma2mcif_wr_data_fifo_->num_free()));
             bdma2mcif_wr_data_fifo_->write(data_ptr);
-            cslDebug((50, "bdma2mcif_wr_data_fifo_ data:\x0A"));
-            for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
-            }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "bdma2mcif_wr_data_fifo_ data:\x0A"));
+            //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+                //cslDebug((50, "%x ", data_ptr[i]));
+            //}
+            //cslDebug((50, "\x0A"));
         }
 
         if (bdma_wr_req_got_size_ == bdma_wr_req_size_) {
@@ -2202,7 +2202,7 @@ void NV_NVDLA_mcif::WriteRequest_bdma2mcif() {
         is_rear_64byte_align = ((payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE) == 0;
         total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
         last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_bdma2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+        //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_bdma2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
 
         base_addr = first_base_addr;
 
@@ -2216,7 +2216,7 @@ void NV_NVDLA_mcif::WriteRequest_bdma2mcif() {
         else
             user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
-        cslDebug((50, "NV_NVDLA_mcif::WriteRequest_bdma2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
+        //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_bdma2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
         while (base_addr <= last_base_addr) {
             size_in_byte = AXI_TRANSACTION_ATOM_SIZE;   //64B
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -2273,20 +2273,20 @@ void NV_NVDLA_mcif::WriteRequest_bdma2mcif() {
             }
 
             if ( (base_addr==last_base_addr) && (bdma_wr_req->require_ack != 0) ) {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_bdma2mcif, required ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_bdma2mcif, required ack.\x0A"));
                 bdma_wr_required_ack_fifo_->write(true);
             }
             else {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_bdma2mcif, did not require ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_bdma2mcif, did not require ack.\x0A"));
                 bdma_wr_required_ack_fifo_->write(false);
             }
 
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequest_bdma2mcif, sending write command to bdma_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_bdma2mcif, sending write command to bdma_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(BDMA_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -2330,7 +2330,7 @@ void NV_NVDLA_mcif::sdp2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         sdp_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         sdp_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         sdp_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "write to sdp2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", sdp_wr_req->addr, sdp_wr_req->size, sdp2mcif_wr_cmd_fifo_->num_free()));
+        //cslDebug((50, "write to sdp2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", sdp_wr_req->addr, sdp_wr_req->size, sdp2mcif_wr_cmd_fifo_->num_free()));
         sdp2mcif_wr_cmd_fifo_->write(sdp_wr_req);
         sdp_wr_req_got_size_ = 0;
         sdp_wr_req_size_ = sdp_wr_req->size;
@@ -2341,25 +2341,25 @@ void NV_NVDLA_mcif::sdp2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "write to sdp2mcif_wr_data_fifo_, num_free:%d\x0A", sdp2mcif_wr_data_fifo_->num_free()));
+        //cslDebug((50, "write to sdp2mcif_wr_data_fifo_, num_free:%d\x0A", sdp2mcif_wr_data_fifo_->num_free()));
         sdp2mcif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
         sdp_wr_req_got_size_ += incoming_size;
-        cslDebug((50, "sdp2mcif_wr_data_fifo_ data:\x0A"));
-        for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
-        }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "sdp2mcif_wr_data_fifo_ data:\x0A"));
+        //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+            //cslDebug((50, "%x ", data_ptr[i]));
+        //}
+        //cslDebug((50, "\x0A"));
 
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to sdp2mcif_wr_data_fifo_, num_free:%d\x0A", sdp2mcif_wr_data_fifo_->num_free()));
+            //cslDebug((50, "write to sdp2mcif_wr_data_fifo_, num_free:%d\x0A", sdp2mcif_wr_data_fifo_->num_free()));
             sdp2mcif_wr_data_fifo_->write(data_ptr);
-            cslDebug((50, "sdp2mcif_wr_data_fifo_ data:\x0A"));
-            for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
-            }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "sdp2mcif_wr_data_fifo_ data:\x0A"));
+            //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+                //cslDebug((50, "%x ", data_ptr[i]));
+            //}
+            //cslDebug((50, "\x0A"));
         }
 
         if (sdp_wr_req_got_size_ == sdp_wr_req_size_) {
@@ -2399,7 +2399,7 @@ void NV_NVDLA_mcif::WriteRequest_sdp2mcif() {
         is_rear_64byte_align = ((payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE) == 0;
         total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
         last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_sdp2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+        //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_sdp2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
 
         base_addr = first_base_addr;
 
@@ -2413,7 +2413,7 @@ void NV_NVDLA_mcif::WriteRequest_sdp2mcif() {
         else
             user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
-        cslDebug((50, "NV_NVDLA_mcif::WriteRequest_sdp2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
+        //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_sdp2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
         while (base_addr <= last_base_addr) {
             size_in_byte = AXI_TRANSACTION_ATOM_SIZE;   //64B
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -2470,20 +2470,20 @@ void NV_NVDLA_mcif::WriteRequest_sdp2mcif() {
             }
 
             if ( (base_addr==last_base_addr) && (sdp_wr_req->require_ack != 0) ) {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_sdp2mcif, required ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_sdp2mcif, required ack.\x0A"));
                 sdp_wr_required_ack_fifo_->write(true);
             }
             else {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_sdp2mcif, did not require ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_sdp2mcif, did not require ack.\x0A"));
                 sdp_wr_required_ack_fifo_->write(false);
             }
 
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequest_sdp2mcif, sending write command to sdp_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_sdp2mcif, sending write command to sdp_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(SDP_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -2527,7 +2527,7 @@ void NV_NVDLA_mcif::pdp2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         pdp_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         pdp_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         pdp_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "write to pdp2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", pdp_wr_req->addr, pdp_wr_req->size, pdp2mcif_wr_cmd_fifo_->num_free()));
+        //cslDebug((50, "write to pdp2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", pdp_wr_req->addr, pdp_wr_req->size, pdp2mcif_wr_cmd_fifo_->num_free()));
         pdp2mcif_wr_cmd_fifo_->write(pdp_wr_req);
         pdp_wr_req_got_size_ = 0;
         pdp_wr_req_size_ = pdp_wr_req->size;
@@ -2538,25 +2538,25 @@ void NV_NVDLA_mcif::pdp2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "write to pdp2mcif_wr_data_fifo_, num_free:%d\x0A", pdp2mcif_wr_data_fifo_->num_free()));
+        //cslDebug((50, "write to pdp2mcif_wr_data_fifo_, num_free:%d\x0A", pdp2mcif_wr_data_fifo_->num_free()));
         pdp2mcif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
         pdp_wr_req_got_size_ += incoming_size;
-        cslDebug((50, "pdp2mcif_wr_data_fifo_ data:\x0A"));
-        for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
-        }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "pdp2mcif_wr_data_fifo_ data:\x0A"));
+        //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+            //cslDebug((50, "%x ", data_ptr[i]));
+        //}
+        //cslDebug((50, "\x0A"));
 
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to pdp2mcif_wr_data_fifo_, num_free:%d\x0A", pdp2mcif_wr_data_fifo_->num_free()));
+            //cslDebug((50, "write to pdp2mcif_wr_data_fifo_, num_free:%d\x0A", pdp2mcif_wr_data_fifo_->num_free()));
             pdp2mcif_wr_data_fifo_->write(data_ptr);
-            cslDebug((50, "pdp2mcif_wr_data_fifo_ data:\x0A"));
-            for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
-            }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "pdp2mcif_wr_data_fifo_ data:\x0A"));
+            //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+                //cslDebug((50, "%x ", data_ptr[i]));
+            //}
+            //cslDebug((50, "\x0A"));
         }
 
         if (pdp_wr_req_got_size_ == pdp_wr_req_size_) {
@@ -2596,7 +2596,7 @@ void NV_NVDLA_mcif::WriteRequest_pdp2mcif() {
         is_rear_64byte_align = ((payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE) == 0;
         total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
         last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_pdp2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+        //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_pdp2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
 
         base_addr = first_base_addr;
 
@@ -2610,7 +2610,7 @@ void NV_NVDLA_mcif::WriteRequest_pdp2mcif() {
         else
             user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
-        cslDebug((50, "NV_NVDLA_mcif::WriteRequest_pdp2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
+        //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_pdp2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
         while (base_addr <= last_base_addr) {
             size_in_byte = AXI_TRANSACTION_ATOM_SIZE;   //64B
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -2667,20 +2667,20 @@ void NV_NVDLA_mcif::WriteRequest_pdp2mcif() {
             }
 
             if ( (base_addr==last_base_addr) && (pdp_wr_req->require_ack != 0) ) {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_pdp2mcif, required ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_pdp2mcif, required ack.\x0A"));
                 pdp_wr_required_ack_fifo_->write(true);
             }
             else {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_pdp2mcif, did not require ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_pdp2mcif, did not require ack.\x0A"));
                 pdp_wr_required_ack_fifo_->write(false);
             }
 
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequest_pdp2mcif, sending write command to pdp_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_pdp2mcif, sending write command to pdp_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(PDP_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -2724,7 +2724,7 @@ void NV_NVDLA_mcif::cdp2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         cdp_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         cdp_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         cdp_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "write to cdp2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", cdp_wr_req->addr, cdp_wr_req->size, cdp2mcif_wr_cmd_fifo_->num_free()));
+        //cslDebug((50, "write to cdp2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", cdp_wr_req->addr, cdp_wr_req->size, cdp2mcif_wr_cmd_fifo_->num_free()));
         cdp2mcif_wr_cmd_fifo_->write(cdp_wr_req);
         cdp_wr_req_got_size_ = 0;
         cdp_wr_req_size_ = cdp_wr_req->size;
@@ -2735,25 +2735,25 @@ void NV_NVDLA_mcif::cdp2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "write to cdp2mcif_wr_data_fifo_, num_free:%d\x0A", cdp2mcif_wr_data_fifo_->num_free()));
+        //cslDebug((50, "write to cdp2mcif_wr_data_fifo_, num_free:%d\x0A", cdp2mcif_wr_data_fifo_->num_free()));
         cdp2mcif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
         cdp_wr_req_got_size_ += incoming_size;
-        cslDebug((50, "cdp2mcif_wr_data_fifo_ data:\x0A"));
-        for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
-        }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "cdp2mcif_wr_data_fifo_ data:\x0A"));
+        //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+            //cslDebug((50, "%x ", data_ptr[i]));
+        //}
+        //cslDebug((50, "\x0A"));
 
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to cdp2mcif_wr_data_fifo_, num_free:%d\x0A", cdp2mcif_wr_data_fifo_->num_free()));
+            //cslDebug((50, "write to cdp2mcif_wr_data_fifo_, num_free:%d\x0A", cdp2mcif_wr_data_fifo_->num_free()));
             cdp2mcif_wr_data_fifo_->write(data_ptr);
-            cslDebug((50, "cdp2mcif_wr_data_fifo_ data:\x0A"));
-            for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
-            }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "cdp2mcif_wr_data_fifo_ data:\x0A"));
+            //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+                //cslDebug((50, "%x ", data_ptr[i]));
+            //}
+            //cslDebug((50, "\x0A"));
         }
 
         if (cdp_wr_req_got_size_ == cdp_wr_req_size_) {
@@ -2793,7 +2793,7 @@ void NV_NVDLA_mcif::WriteRequest_cdp2mcif() {
         is_rear_64byte_align = ((payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE) == 0;
         total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
         last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_cdp2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+        //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_cdp2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
 
         base_addr = first_base_addr;
 
@@ -2807,7 +2807,7 @@ void NV_NVDLA_mcif::WriteRequest_cdp2mcif() {
         else
             user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
-        cslDebug((50, "NV_NVDLA_mcif::WriteRequest_cdp2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
+        //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_cdp2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
         while (base_addr <= last_base_addr) {
             size_in_byte = AXI_TRANSACTION_ATOM_SIZE;   //64B
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -2864,20 +2864,20 @@ void NV_NVDLA_mcif::WriteRequest_cdp2mcif() {
             }
 
             if ( (base_addr==last_base_addr) && (cdp_wr_req->require_ack != 0) ) {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_cdp2mcif, required ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_cdp2mcif, required ack.\x0A"));
                 cdp_wr_required_ack_fifo_->write(true);
             }
             else {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_cdp2mcif, did not require ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_cdp2mcif, did not require ack.\x0A"));
                 cdp_wr_required_ack_fifo_->write(false);
             }
 
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequest_cdp2mcif, sending write command to cdp_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_cdp2mcif, sending write command to cdp_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(CDP_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -2921,7 +2921,7 @@ void NV_NVDLA_mcif::rbk2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         rbk_wr_req->addr  = payload->pd.dma_write_cmd.addr;
         rbk_wr_req->size  = (payload->pd.dma_write_cmd.size + 1) * DMA_TRANSACTION_ATOM_SIZE;    //In byte
         rbk_wr_req->require_ack = payload->pd.dma_write_cmd.require_ack;
-        cslDebug((50, "write to rbk2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", rbk_wr_req->addr, rbk_wr_req->size, rbk2mcif_wr_cmd_fifo_->num_free()));
+        //cslDebug((50, "write to rbk2mcif_wr_cmd_fifo_, addr:%lx, size:%d, num_free:%d\x0A", rbk_wr_req->addr, rbk_wr_req->size, rbk2mcif_wr_cmd_fifo_->num_free()));
         rbk2mcif_wr_cmd_fifo_->write(rbk_wr_req);
         rbk_wr_req_got_size_ = 0;
         rbk_wr_req_size_ = rbk_wr_req->size;
@@ -2932,25 +2932,25 @@ void NV_NVDLA_mcif::rbk2mcif_wr_req_b_transport(int ID, nvdla_dma_wr_req_t* payl
         incoming_size = min(rest_size, uint32_t (DMA_TRANSACTION_MAX_SIZE));
         data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
         memcpy(data_ptr, dma_payload_data_ptr, DMA_TRANSACTION_ATOM_SIZE);
-        cslDebug((50, "write to rbk2mcif_wr_data_fifo_, num_free:%d\x0A", rbk2mcif_wr_data_fifo_->num_free()));
+        //cslDebug((50, "write to rbk2mcif_wr_data_fifo_, num_free:%d\x0A", rbk2mcif_wr_data_fifo_->num_free()));
         rbk2mcif_wr_data_fifo_->write(data_ptr);   // Write to FIFO in 32Byte atom
         rbk_wr_req_got_size_ += incoming_size;
-        cslDebug((50, "rbk2mcif_wr_data_fifo_ data:\x0A"));
-        for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-            cslDebug((50, "%x ", data_ptr[i]));
-        }
-        cslDebug((50, "\x0A"));
+        //cslDebug((50, "rbk2mcif_wr_data_fifo_ data:\x0A"));
+        //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+            //cslDebug((50, "%x ", data_ptr[i]));
+        //}
+        //cslDebug((50, "\x0A"));
 
         if (incoming_size==DMA_TRANSACTION_MAX_SIZE) { // The payload is 64B
             data_ptr = new uint8_t[DMA_TRANSACTION_ATOM_SIZE];
             memcpy(data_ptr, &dma_payload_data_ptr[DMA_TRANSACTION_ATOM_SIZE], DMA_TRANSACTION_ATOM_SIZE);
-            cslDebug((50, "write to rbk2mcif_wr_data_fifo_, num_free:%d\x0A", rbk2mcif_wr_data_fifo_->num_free()));
+            //cslDebug((50, "write to rbk2mcif_wr_data_fifo_, num_free:%d\x0A", rbk2mcif_wr_data_fifo_->num_free()));
             rbk2mcif_wr_data_fifo_->write(data_ptr);
-            cslDebug((50, "rbk2mcif_wr_data_fifo_ data:\x0A"));
-            for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
-                cslDebug((50, "%x ", data_ptr[i]));
-            }
-            cslDebug((50, "\x0A"));
+            //cslDebug((50, "rbk2mcif_wr_data_fifo_ data:\x0A"));
+            //for(int i = 0; i < DMA_TRANSACTION_ATOM_SIZE; i++) {
+                //cslDebug((50, "%x ", data_ptr[i]));
+            //}
+            //cslDebug((50, "\x0A"));
         }
 
         if (rbk_wr_req_got_size_ == rbk_wr_req_size_) {
@@ -2990,7 +2990,7 @@ void NV_NVDLA_mcif::WriteRequest_rbk2mcif() {
         is_rear_64byte_align = ((payload_addr + payload_size) % AXI_TRANSACTION_ATOM_SIZE) == 0;
         total_axi_size = payload_size + (is_base_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE) + (is_rear_64byte_align? 0: DMA_TRANSACTION_ATOM_SIZE);
         last_base_addr  = first_base_addr + total_axi_size - AXI_TRANSACTION_ATOM_SIZE;
-        cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_rbk2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
+        //cslDebug((30, "XXXXXXX NV_NVDLA_mcif::WriteRequest_rbk2mcif, first_base_addr=0x%lx total_axi_size is 0x%x payload_addr=0x%lx payload_size=0x%x\x0A", first_base_addr, total_axi_size, payload_addr, payload_size));
 
         base_addr = first_base_addr;
 
@@ -3004,7 +3004,7 @@ void NV_NVDLA_mcif::WriteRequest_rbk2mcif() {
         else
             user_size_last = ((first_base_addr + total_axi_size) % MCIF_MAX_MEM_TRANSACTION_SIZE) / AXI_TRANSACTION_ATOM_SIZE - 1;
 
-        cslDebug((50, "NV_NVDLA_mcif::WriteRequest_rbk2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
+        //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_rbk2mcif, before spliting DMA transaction. user_size_first=0x%x user_size_first=0x%x\x0A", user_size_first, user_size_last));
         while (base_addr <= last_base_addr) {
             size_in_byte = AXI_TRANSACTION_ATOM_SIZE;   //64B
             bt_payload = new dla_b_transport_payload(size_in_byte, dla_b_transport_payload::DLA_B_TRANSPORT_PAYLOAD_TYPE_MC);
@@ -3061,20 +3061,20 @@ void NV_NVDLA_mcif::WriteRequest_rbk2mcif() {
             }
 
             if ( (base_addr==last_base_addr) && (rbk_wr_req->require_ack != 0) ) {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_rbk2mcif, required ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_rbk2mcif, required ack.\x0A"));
                 rbk_wr_required_ack_fifo_->write(true);
             }
             else {
-                cslDebug((30, "NV_NVDLA_mcif::WriteRequest_rbk2mcif, did not require ack.\x0A"));
+                //cslDebug((30, "NV_NVDLA_mcif::WriteRequest_rbk2mcif, did not require ack.\x0A"));
                 rbk_wr_required_ack_fifo_->write(false);
             }
 
             // Prepare write payload
             bt_payload->configure_gp(base_addr, size_in_byte, is_read);
             bt_payload->gp.get_extension(nvdla_dbb_ext);
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequest_rbk2mcif, sending write command to rbk_wr_req_fifo_.\x0A"));
-            cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
-            cslDebug((50, "    size: %d\x0A", size_in_byte));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequest_rbk2mcif, sending write command to rbk_wr_req_fifo_.\x0A"));
+            //cslDebug((50, "    addr: 0x%lx\x0A", base_addr));
+            //cslDebug((50, "    size: %d\x0A", size_in_byte));
             nvdla_dbb_ext->set_id(RBK_AXI_ID);
             nvdla_dbb_ext->set_size(64);
             nvdla_dbb_ext->set_length(size_in_byte/AXI_TRANSACTION_ATOM_SIZE);
@@ -3125,12 +3125,12 @@ void NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
     axi_byte_enable_ptr    =  tlm_gp.get_byte_enable_ptr();
     axi_byte_enable_length =  tlm_gp.get_byte_enable_length();
     axi_id                 =  nvdla_dbb_ext->get_id();
-    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport\x0A"));
-    cslDebug((50, "axi_id: 0x%x\x0A", axi_id));
-    cslDebug((50, "axi_data_ptr: 0x%p\x0A", (void *) axi_data_ptr));
-    cslDebug((50, "axi_length: %d\x0A", axi_length));
-    cslDebug((50, "axi_byte_enable_ptr: 0x%p\x0A", (void *) axi_byte_enable_ptr));
-    cslDebug((50, "axi_byte_enable_length: %d\x0A", axi_byte_enable_length));
+    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport\x0A"));
+    //cslDebug((50, "axi_id: 0x%x\x0A", axi_id));
+    //cslDebug((50, "axi_data_ptr: 0x%p\x0A", (void *) axi_data_ptr));
+    //cslDebug((50, "axi_length: %d\x0A", axi_length));
+    //cslDebug((50, "axi_byte_enable_ptr: 0x%p\x0A", (void *) axi_byte_enable_ptr));
+    //cslDebug((50, "axi_byte_enable_length: %d\x0A", axi_byte_enable_length));
 
     // Data from general payload
     //  # AXI transaction size shall not be greater than 256 bytes
@@ -3147,48 +3147,48 @@ void NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
     //  Parsing AXI payload and generating DMA response payloads
     dma_sent_size = 0;
     for (dma_sent_size = 0; dma_sent_size < axi_length; dma_sent_size += DMA_TRANSACTION_ATOM_SIZE) {
-        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, dma_sent_size: 0x%x\x0A", dma_sent_size));
+        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, dma_sent_size: 0x%x\x0A", dma_sent_size));
         switch (axi_id) {
 
            case BDMA_AXI_ID:
                     dma_payload_atom_mask = (true == bdma_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read bdma_rd_atom_enable_fifo_, bdma payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read bdma_rd_atom_enable_fifo_, bdma payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case SDP_AXI_ID:
                     dma_payload_atom_mask = (true == sdp_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read sdp_rd_atom_enable_fifo_, sdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read sdp_rd_atom_enable_fifo_, sdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case PDP_AXI_ID:
                     dma_payload_atom_mask = (true == pdp_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read pdp_rd_atom_enable_fifo_, pdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read pdp_rd_atom_enable_fifo_, pdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case CDP_AXI_ID:
                     dma_payload_atom_mask = (true == cdp_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read cdp_rd_atom_enable_fifo_, cdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read cdp_rd_atom_enable_fifo_, cdp payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case RBK_AXI_ID:
                     dma_payload_atom_mask = (true == rbk_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read rbk_rd_atom_enable_fifo_, rbk payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read rbk_rd_atom_enable_fifo_, rbk payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case SDP_B_AXI_ID:
                     dma_payload_atom_mask = (true == sdp_b_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read sdp_b_rd_atom_enable_fifo_, sdp_b payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read sdp_b_rd_atom_enable_fifo_, sdp_b payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case SDP_N_AXI_ID:
                     dma_payload_atom_mask = (true == sdp_n_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read sdp_n_rd_atom_enable_fifo_, sdp_n payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read sdp_n_rd_atom_enable_fifo_, sdp_n payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case SDP_E_AXI_ID:
                     dma_payload_atom_mask = (true == sdp_e_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read sdp_e_rd_atom_enable_fifo_, sdp_e payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read sdp_e_rd_atom_enable_fifo_, sdp_e payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case CDMA_DAT_AXI_ID:
                     dma_payload_atom_mask = (true == cdma_dat_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read cdma_dat_rd_atom_enable_fifo_, cdma_dat payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read cdma_dat_rd_atom_enable_fifo_, cdma_dat payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
            case CDMA_WT_AXI_ID:
                     dma_payload_atom_mask = (true == cdma_wt_rd_atom_enable_fifo_->read())?0x1:0;
-                    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read cdma_wt_rd_atom_enable_fifo_, cdma_wt payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+                    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, read cdma_wt_rd_atom_enable_fifo_, cdma_wt payload atom mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
                 break;
 
 #pragma CTC SKIP
@@ -3203,84 +3203,84 @@ void NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
             switch (axi_id) {
 
                  case BDMA_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2bdma_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2bdma_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2bdma_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, bdma payload atom mask is 0x1, write an atom to mcif2bdma_rd_rsp_fifo_, num_free:%d.\x0A", mcif2bdma_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, bdma payload atom mask is 0x1, write an atom to mcif2bdma_rd_rsp_fifo_, num_free:%d.\x0A", mcif2bdma_rd_rsp_fifo_->num_free()));
                     break;
                  case SDP_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2sdp_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2sdp_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2sdp_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, sdp payload atom mask is 0x1, write an atom to mcif2sdp_rd_rsp_fifo_, num_free:%d.\x0A", mcif2sdp_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, sdp payload atom mask is 0x1, write an atom to mcif2sdp_rd_rsp_fifo_, num_free:%d.\x0A", mcif2sdp_rd_rsp_fifo_->num_free()));
                     break;
                  case PDP_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2pdp_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2pdp_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2pdp_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, pdp payload atom mask is 0x1, write an atom to mcif2pdp_rd_rsp_fifo_, num_free:%d.\x0A", mcif2pdp_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, pdp payload atom mask is 0x1, write an atom to mcif2pdp_rd_rsp_fifo_, num_free:%d.\x0A", mcif2pdp_rd_rsp_fifo_->num_free()));
                     break;
                  case CDP_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2cdp_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2cdp_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2cdp_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, cdp payload atom mask is 0x1, write an atom to mcif2cdp_rd_rsp_fifo_, num_free:%d.\x0A", mcif2cdp_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, cdp payload atom mask is 0x1, write an atom to mcif2cdp_rd_rsp_fifo_, num_free:%d.\x0A", mcif2cdp_rd_rsp_fifo_->num_free()));
                     break;
                  case RBK_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2rbk_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2rbk_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2rbk_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, rbk payload atom mask is 0x1, write an atom to mcif2rbk_rd_rsp_fifo_, num_free:%d.\x0A", mcif2rbk_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, rbk payload atom mask is 0x1, write an atom to mcif2rbk_rd_rsp_fifo_, num_free:%d.\x0A", mcif2rbk_rd_rsp_fifo_->num_free()));
                     break;
                  case SDP_B_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2sdp_b_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2sdp_b_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2sdp_b_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, sdp_b payload atom mask is 0x1, write an atom to mcif2sdp_b_rd_rsp_fifo_, num_free:%d.\x0A", mcif2sdp_b_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, sdp_b payload atom mask is 0x1, write an atom to mcif2sdp_b_rd_rsp_fifo_, num_free:%d.\x0A", mcif2sdp_b_rd_rsp_fifo_->num_free()));
                     break;
                  case SDP_N_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2sdp_n_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2sdp_n_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2sdp_n_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, sdp_n payload atom mask is 0x1, write an atom to mcif2sdp_n_rd_rsp_fifo_, num_free:%d.\x0A", mcif2sdp_n_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, sdp_n payload atom mask is 0x1, write an atom to mcif2sdp_n_rd_rsp_fifo_, num_free:%d.\x0A", mcif2sdp_n_rd_rsp_fifo_->num_free()));
                     break;
                  case SDP_E_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2sdp_e_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2sdp_e_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2sdp_e_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, sdp_e payload atom mask is 0x1, write an atom to mcif2sdp_e_rd_rsp_fifo_, num_free:%d.\x0A", mcif2sdp_e_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, sdp_e payload atom mask is 0x1, write an atom to mcif2sdp_e_rd_rsp_fifo_, num_free:%d.\x0A", mcif2sdp_e_rd_rsp_fifo_->num_free()));
                     break;
                  case CDMA_DAT_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2cdma_dat_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2cdma_dat_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2cdma_dat_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, cdma_dat payload atom mask is 0x1, write an atom to mcif2cdma_dat_rd_rsp_fifo_, num_free:%d.\x0A", mcif2cdma_dat_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, cdma_dat payload atom mask is 0x1, write an atom to mcif2cdma_dat_rd_rsp_fifo_, num_free:%d.\x0A", mcif2cdma_dat_rd_rsp_fifo_->num_free()));
                     break;
                  case CDMA_WT_AXI_ID:
-                        cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2cdma_wt_rd_rsp_fifo_->num_free()));
-                        for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
-                            cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
-                        }
+                        //cslDebug((70, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, num_free:%d, axi_atom_ptr value:\x0A", mcif2cdma_wt_rd_rsp_fifo_->num_free()));
+                        //for (idx = 0; idx < DMA_TRANSACTION_ATOM_SIZE; idx ++) {
+                            //cslDebug((70, "    0x%lx\x0A", uint64_t (axi_atom_ptr[idx])));
+                        //}
                         mcif2cdma_wt_rd_rsp_fifo_->write(axi_atom_ptr);
-                        cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, cdma_wt payload atom mask is 0x1, write an atom to mcif2cdma_wt_rd_rsp_fifo_, num_free:%d.\x0A", mcif2cdma_wt_rd_rsp_fifo_->num_free()));
+                        //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, cdma_wt payload atom mask is 0x1, write an atom to mcif2cdma_wt_rd_rsp_fifo_, num_free:%d.\x0A", mcif2cdma_wt_rd_rsp_fifo_->num_free()));
                     break;
 
 #pragma CTC SKIP
@@ -3289,7 +3289,7 @@ void NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
 #pragma CTC ENDSKIP
             }
         } else {
-            cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, {client} payload atom mask is 0x0, ignore current atom, dma_payload_atom_mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
+            //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport, {client} payload atom mask is 0x0, ignore current atom, dma_payload_atom_mask is 0x%x\x0A", uint32_t(dma_payload_atom_mask)));
         }
     }
 
@@ -3299,7 +3299,7 @@ void NV_NVDLA_mcif::ext2mcif_rd_rsp_b_transport(int ID, tlm::tlm_generic_payload
 void NV_NVDLA_mcif::ext2mcif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload& tlm_gp, sc_time& delay) {
     uint8_t             axi_id;
     nvdla_dbb_extension *nvdla_dbb_ext = NULL;
-    cslDebug((50, "NV_NVDLA_mcif::ext2mcif_wr_rsp_b_transport.\x0A"));
+    //cslDebug((50, "NV_NVDLA_mcif::ext2mcif_wr_rsp_b_transport.\x0A"));
 
     // Get DBB extension
     tlm_gp.get_extension(nvdla_dbb_ext);
@@ -3315,9 +3315,9 @@ void NV_NVDLA_mcif::ext2mcif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             bdma_wr_rsp_count_ ++;
             // Read a new reques id from fifo
             bdma_wr_req_expected_ack = bdma_wr_required_ack_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ext2bdma_wr_rsp_b_transport, bdma_wr_req_expected_ack=0x%x\x0A", bdma_wr_req_expected_ack));
+            //cslDebug((50, "NV_NVDLA_mcif::ext2bdma_wr_rsp_b_transport, bdma_wr_req_expected_ack=0x%x\x0A", bdma_wr_req_expected_ack));
             if (true == bdma_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to bdma\x0A"));
+                //cslDebug((50, "send wr rsp to bdma\x0A"));
                 //FIXME(skip-t194): we can add assertion bdma_wr_rsp_count_ == bdma_wr_cmd_count_fifo_->read
                 NV_NVDLA_mcif_base::mcif2bdma_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -3331,9 +3331,9 @@ void NV_NVDLA_mcif::ext2mcif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             sdp_wr_rsp_count_ ++;
             // Read a new reques id from fifo
             sdp_wr_req_expected_ack = sdp_wr_required_ack_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ext2sdp_wr_rsp_b_transport, sdp_wr_req_expected_ack=0x%x\x0A", sdp_wr_req_expected_ack));
+            //cslDebug((50, "NV_NVDLA_mcif::ext2sdp_wr_rsp_b_transport, sdp_wr_req_expected_ack=0x%x\x0A", sdp_wr_req_expected_ack));
             if (true == sdp_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to sdp\x0A"));
+                //cslDebug((50, "send wr rsp to sdp\x0A"));
                 //FIXME(skip-t194): we can add assertion sdp_wr_rsp_count_ == sdp_wr_cmd_count_fifo_->read
                 NV_NVDLA_mcif_base::mcif2sdp_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -3347,9 +3347,9 @@ void NV_NVDLA_mcif::ext2mcif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             pdp_wr_rsp_count_ ++;
             // Read a new reques id from fifo
             pdp_wr_req_expected_ack = pdp_wr_required_ack_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ext2pdp_wr_rsp_b_transport, pdp_wr_req_expected_ack=0x%x\x0A", pdp_wr_req_expected_ack));
+            //cslDebug((50, "NV_NVDLA_mcif::ext2pdp_wr_rsp_b_transport, pdp_wr_req_expected_ack=0x%x\x0A", pdp_wr_req_expected_ack));
             if (true == pdp_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to pdp\x0A"));
+                //cslDebug((50, "send wr rsp to pdp\x0A"));
                 //FIXME(skip-t194): we can add assertion pdp_wr_rsp_count_ == pdp_wr_cmd_count_fifo_->read
                 NV_NVDLA_mcif_base::mcif2pdp_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -3363,9 +3363,9 @@ void NV_NVDLA_mcif::ext2mcif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             cdp_wr_rsp_count_ ++;
             // Read a new reques id from fifo
             cdp_wr_req_expected_ack = cdp_wr_required_ack_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ext2cdp_wr_rsp_b_transport, cdp_wr_req_expected_ack=0x%x\x0A", cdp_wr_req_expected_ack));
+            //cslDebug((50, "NV_NVDLA_mcif::ext2cdp_wr_rsp_b_transport, cdp_wr_req_expected_ack=0x%x\x0A", cdp_wr_req_expected_ack));
             if (true == cdp_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to cdp\x0A"));
+                //cslDebug((50, "send wr rsp to cdp\x0A"));
                 //FIXME(skip-t194): we can add assertion cdp_wr_rsp_count_ == cdp_wr_cmd_count_fifo_->read
                 NV_NVDLA_mcif_base::mcif2cdp_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -3379,9 +3379,9 @@ void NV_NVDLA_mcif::ext2mcif_wr_rsp_b_transport(int ID, tlm::tlm_generic_payload
             rbk_wr_rsp_count_ ++;
             // Read a new reques id from fifo
             rbk_wr_req_expected_ack = rbk_wr_required_ack_fifo_->read();
-            cslDebug((50, "NV_NVDLA_mcif::ext2rbk_wr_rsp_b_transport, rbk_wr_req_expected_ack=0x%x\x0A", rbk_wr_req_expected_ack));
+            //cslDebug((50, "NV_NVDLA_mcif::ext2rbk_wr_rsp_b_transport, rbk_wr_req_expected_ack=0x%x\x0A", rbk_wr_req_expected_ack));
             if (true == rbk_wr_req_expected_ack) {
-                cslDebug((50, "send wr rsp to rbk\x0A"));
+                //cslDebug((50, "send wr rsp to rbk\x0A"));
                 //FIXME(skip-t194): we can add assertion rbk_wr_rsp_count_ == rbk_wr_cmd_count_fifo_->read
                 NV_NVDLA_mcif_base::mcif2rbk_wr_rsp.write(true);
                 //FIXME(skip-t194): WAR to add wait here. Otherwise, the client will not receive the signal when two "true" are sent to client continuously.
@@ -3550,9 +3550,9 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
         
         if( !cdma_dat_ready && !cdma_wt_ready && !bdma_ready && !sdp_ready &&
         !pdp_ready && !cdp_ready && !rbk_ready && !sdp_b_ready && !sdp_n_ready && !sdp_e_ready) {{
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, no pending request, waiting.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, no pending request, waiting.\x0A"));
                 wait();
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, get new request, wake up.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, get new request, wake up.\x0A"));
             }}
 
         // Get a FIFO write event, query dma read request FIFOs
@@ -3563,13 +3563,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2bdma_rd_rsp_fifo_ >= atom_num) {   // Same as bdma_ready
                 credit_mcif2bdma_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from bdma, begin, atom:%d, num_free:%d credit_mcif2bdma_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2bdma_rd_rsp_fifo_->num_free(), credit_mcif2bdma_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from bdma, begin, atom:%d, num_free:%d credit_mcif2bdma_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2bdma_rd_rsp_fifo_->num_free(), credit_mcif2bdma_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(bdma_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, bdma_rd_req_payload_ from bdma, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, bdma_rd_req_payload_ from bdma, end.\x0A"));
                 delete bdma_rd_req_payload_;
                 bdma_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from bdma\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from bdma\x0A"));
             }
         }
         // For SDP
@@ -3578,13 +3578,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2sdp_rd_rsp_fifo_ >= atom_num) {   // Same as sdp_ready
                 credit_mcif2sdp_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from sdp, begin, atom:%d, num_free:%d credit_mcif2sdp_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2sdp_rd_rsp_fifo_->num_free(), credit_mcif2sdp_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from sdp, begin, atom:%d, num_free:%d credit_mcif2sdp_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2sdp_rd_rsp_fifo_->num_free(), credit_mcif2sdp_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(sdp_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, sdp_rd_req_payload_ from sdp, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, sdp_rd_req_payload_ from sdp, end.\x0A"));
                 delete sdp_rd_req_payload_;
                 sdp_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from sdp\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from sdp\x0A"));
             }
         }
         // For PDP
@@ -3593,13 +3593,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2pdp_rd_rsp_fifo_ >= atom_num) {   // Same as pdp_ready
                 credit_mcif2pdp_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from pdp, begin, atom:%d, num_free:%d credit_mcif2pdp_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2pdp_rd_rsp_fifo_->num_free(), credit_mcif2pdp_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from pdp, begin, atom:%d, num_free:%d credit_mcif2pdp_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2pdp_rd_rsp_fifo_->num_free(), credit_mcif2pdp_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(pdp_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, pdp_rd_req_payload_ from pdp, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, pdp_rd_req_payload_ from pdp, end.\x0A"));
                 delete pdp_rd_req_payload_;
                 pdp_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from pdp\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from pdp\x0A"));
             }
         }
         // For CDP
@@ -3608,13 +3608,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2cdp_rd_rsp_fifo_ >= atom_num) {   // Same as cdp_ready
                 credit_mcif2cdp_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from cdp, begin, atom:%d, num_free:%d credit_mcif2cdp_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2cdp_rd_rsp_fifo_->num_free(), credit_mcif2cdp_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from cdp, begin, atom:%d, num_free:%d credit_mcif2cdp_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2cdp_rd_rsp_fifo_->num_free(), credit_mcif2cdp_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(cdp_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, cdp_rd_req_payload_ from cdp, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, cdp_rd_req_payload_ from cdp, end.\x0A"));
                 delete cdp_rd_req_payload_;
                 cdp_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from cdp\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from cdp\x0A"));
             }
         }
         // For RBK
@@ -3623,13 +3623,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2rbk_rd_rsp_fifo_ >= atom_num) {   // Same as rbk_ready
                 credit_mcif2rbk_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from rbk, begin, atom:%d, num_free:%d credit_mcif2rbk_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2rbk_rd_rsp_fifo_->num_free(), credit_mcif2rbk_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from rbk, begin, atom:%d, num_free:%d credit_mcif2rbk_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2rbk_rd_rsp_fifo_->num_free(), credit_mcif2rbk_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(rbk_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, rbk_rd_req_payload_ from rbk, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, rbk_rd_req_payload_ from rbk, end.\x0A"));
                 delete rbk_rd_req_payload_;
                 rbk_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from rbk\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from rbk\x0A"));
             }
         }
         // For SDP_B
@@ -3638,13 +3638,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2sdp_b_rd_rsp_fifo_ >= atom_num) {   // Same as sdp_b_ready
                 credit_mcif2sdp_b_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from sdp_b, begin, atom:%d, num_free:%d credit_mcif2sdp_b_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2sdp_b_rd_rsp_fifo_->num_free(), credit_mcif2sdp_b_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from sdp_b, begin, atom:%d, num_free:%d credit_mcif2sdp_b_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2sdp_b_rd_rsp_fifo_->num_free(), credit_mcif2sdp_b_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(sdp_b_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, sdp_b_rd_req_payload_ from sdp_b, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, sdp_b_rd_req_payload_ from sdp_b, end.\x0A"));
                 delete sdp_b_rd_req_payload_;
                 sdp_b_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from sdp_b\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from sdp_b\x0A"));
             }
         }
         // For SDP_N
@@ -3653,13 +3653,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2sdp_n_rd_rsp_fifo_ >= atom_num) {   // Same as sdp_n_ready
                 credit_mcif2sdp_n_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from sdp_n, begin, atom:%d, num_free:%d credit_mcif2sdp_n_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2sdp_n_rd_rsp_fifo_->num_free(), credit_mcif2sdp_n_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from sdp_n, begin, atom:%d, num_free:%d credit_mcif2sdp_n_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2sdp_n_rd_rsp_fifo_->num_free(), credit_mcif2sdp_n_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(sdp_n_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, sdp_n_rd_req_payload_ from sdp_n, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, sdp_n_rd_req_payload_ from sdp_n, end.\x0A"));
                 delete sdp_n_rd_req_payload_;
                 sdp_n_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from sdp_n\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from sdp_n\x0A"));
             }
         }
         // For SDP_E
@@ -3668,13 +3668,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2sdp_e_rd_rsp_fifo_ >= atom_num) {   // Same as sdp_e_ready
                 credit_mcif2sdp_e_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from sdp_e, begin, atom:%d, num_free:%d credit_mcif2sdp_e_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2sdp_e_rd_rsp_fifo_->num_free(), credit_mcif2sdp_e_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from sdp_e, begin, atom:%d, num_free:%d credit_mcif2sdp_e_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2sdp_e_rd_rsp_fifo_->num_free(), credit_mcif2sdp_e_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(sdp_e_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, sdp_e_rd_req_payload_ from sdp_e, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, sdp_e_rd_req_payload_ from sdp_e, end.\x0A"));
                 delete sdp_e_rd_req_payload_;
                 sdp_e_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from sdp_e\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from sdp_e\x0A"));
             }
         }
         // For CDMA_DAT
@@ -3683,13 +3683,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2cdma_dat_rd_rsp_fifo_ >= atom_num) {   // Same as cdma_dat_ready
                 credit_mcif2cdma_dat_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from cdma_dat, begin, atom:%d, num_free:%d credit_mcif2cdma_dat_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2cdma_dat_rd_rsp_fifo_->num_free(), credit_mcif2cdma_dat_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from cdma_dat, begin, atom:%d, num_free:%d credit_mcif2cdma_dat_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2cdma_dat_rd_rsp_fifo_->num_free(), credit_mcif2cdma_dat_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(cdma_dat_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, cdma_dat_rd_req_payload_ from cdma_dat, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, cdma_dat_rd_req_payload_ from cdma_dat, end.\x0A"));
                 delete cdma_dat_rd_req_payload_;
                 cdma_dat_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from cdma_dat\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from cdma_dat\x0A"));
             }
         }
         // For CDMA_WT
@@ -3698,13 +3698,13 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
             int atom_num = (axi_byte_enable_ptr[0] == TLM_BYTE_ENABLED) + (axi_byte_enable_ptr[32] == TLM_BYTE_ENABLED);
             if (credit_mcif2cdma_wt_rd_rsp_fifo_ >= atom_num) {   // Same as cdma_wt_ready
                 credit_mcif2cdma_wt_rd_rsp_fifo_ -= atom_num;
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from cdma_wt, begin, atom:%d, num_free:%d credit_mcif2cdma_wt_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2cdma_wt_rd_rsp_fifo_->num_free(), credit_mcif2cdma_wt_rd_rsp_fifo_));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, payload from cdma_wt, begin, atom:%d, num_free:%d credit_mcif2cdma_wt_rd_rsp_fifo_=%d.\x0A", atom_num, mcif2cdma_wt_rd_rsp_fifo_->num_free(), credit_mcif2cdma_wt_rd_rsp_fifo_));
                 mcif2ext_rd_req->b_transport(cdma_wt_rd_req_payload_->gp, axi_delay_);
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, cdma_wt_rd_req_payload_ from cdma_wt, end.\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, send read request, cdma_wt_rd_req_payload_ from cdma_wt, end.\x0A"));
                 delete cdma_wt_rd_req_payload_;
                 cdma_wt_rd_req_payload_ = NULL;
             } else {
-                cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from cdma_wt\x0A"));
+                //cslDebug((50, "NV_NVDLA_mcif::ReadRequestArbiter, skip send read request from cdma_wt\x0A"));
             }
         }
 
@@ -3715,7 +3715,7 @@ void NV_NVDLA_mcif::ReadRequestArbiter() {
 void NV_NVDLA_mcif::WriteRequestArbiter() {
     dla_b_transport_payload *payload;
     while (true) {
-        cslDebug((50, "Calling WriteRequestArbiter\x0A"));
+        //cslDebug((50, "Calling WriteRequestArbiter\x0A"));
         if((bdma_wr_req_fifo_->num_available()==0) && (rbk_wr_req_fifo_->num_available()==0) && (sdp_wr_req_fifo_->num_available()==0) && (pdp_wr_req_fifo_->num_available()==0) && (cdp_wr_req_fifo_->num_available()==0))
             wait();
 
@@ -3723,31 +3723,31 @@ void NV_NVDLA_mcif::WriteRequestArbiter() {
 
         // For BDMA
         if (bdma_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from bdma.\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from bdma.\x0A"));
             mcif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
         // For SDP
         if (sdp_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from sdp.\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from sdp.\x0A"));
             mcif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
         // For PDP
         if (pdp_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from pdp.\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from pdp.\x0A"));
             mcif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
         // For CDP
         if (cdp_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from cdp.\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from cdp.\x0A"));
             mcif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
         // For RBK
         if (rbk_wr_req_fifo_->nb_read(payload)) {
-            cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from rbk.\x0A"));
+            //cslDebug((50, "NV_NVDLA_mcif::WriteRequestArbiter, send write request, payload from rbk.\x0A"));
             mcif2ext_wr_req->b_transport(payload->gp, axi_delay_);
             delete payload;
         }
diff --git a/cmod/nvdla_clibs/NvdlaDataFormatConvertor.cpp b/cmod/nvdla_clibs/NvdlaDataFormatConvertor.cpp
index f54c86c..d6f2307 100644
--- a/cmod/nvdla_clibs/NvdlaDataFormatConvertor.cpp
+++ b/cmod/nvdla_clibs/NvdlaDataFormatConvertor.cpp
@@ -18,7 +18,7 @@
 using namespace std;
 
 NvdlaDataFormatConvertor::NvdlaDataFormatConvertor(uint8_t    data_type, uint32_t   offset, uint32_t   scaling_factor, uint8_t    truncation_lsb, uint8_t    truncation_bit_width) {
-    cslDebug((70, "NvdlaDataFormatConvertor::NvdlaDataFormatConvertor: Enter constructor.\n"));
+    //cslDebug((70, "NvdlaDataFormatConvertor::NvdlaDataFormatConvertor: Enter constructor.\n"));
     set_data_type(data_type);
     set_offset(offset);
     set_scaling_factor(scaling_factor);
@@ -28,30 +28,30 @@ NvdlaDataFormatConvertor::NvdlaDataFormatConvertor(uint8_t    data_type, uint32_
 
 void NvdlaDataFormatConvertor::set_data_type        (uint8_t    data_type){
     data_type_ = data_type;
-    cslDebug((70, "NvdlaDataFormatConvertor::set_data_type: data type is %d\n", uint16_t(data_type_)));
+    //cslDebug((70, "NvdlaDataFormatConvertor::set_data_type: data type is %d\n", uint16_t(data_type_)));
 }
 
 void NvdlaDataFormatConvertor::set_offset           (uint32_t   &offset){
     offset_float_ = *reinterpret_cast <float*>    (&offset);
     offset_int_   = int64_t(*reinterpret_cast <int32_t*>  (&offset));
-    cslDebug((70, "NvdlaDataFormatConvertor::set_offset: offset float is %f\n", offset_float_));
-    cslDebug((70, "NvdlaDataFormatConvertor::set_offset: offset integer is %ld\n", offset_int_));
+    //cslDebug((70, "NvdlaDataFormatConvertor::set_offset: offset float is %f\n", offset_float_));
+    //cslDebug((70, "NvdlaDataFormatConvertor::set_offset: offset integer is %ld\n", offset_int_));
 }
 
 void NvdlaDataFormatConvertor::set_scaling_factor   (uint32_t   &scaling_factor){
     scaling_factor_float_ = *reinterpret_cast <float*>            (&scaling_factor);
     scaling_factor_int_   = int64_t(*reinterpret_cast <int32_t*>  (&scaling_factor));
-    cslDebug((70, "NvdlaDataFormatConvertor::set_scaling_factor: scalling float is %f\n", scaling_factor_float_));
-    cslDebug((70, "NvdlaDataFormatConvertor::set_scaling_factor: scalling integer is %ld\n", scaling_factor_int_));
+    //cslDebug((70, "NvdlaDataFormatConvertor::set_scaling_factor: scalling float is %f\n", scaling_factor_float_));
+    //cslDebug((70, "NvdlaDataFormatConvertor::set_scaling_factor: scalling integer is %ld\n", scaling_factor_int_));
 }
 
 void NvdlaDataFormatConvertor::set_truncation_lsb  (uint8_t    truncation_lsb){
     truncation_lsb_ = truncation_lsb;
-    cslDebug((70, "NvdlaDataFormatConvertor::set_truncation_lsb: truncation lsb is %d\n", uint16_t(truncation_lsb_)));
+    //cslDebug((70, "NvdlaDataFormatConvertor::set_truncation_lsb: truncation lsb is %d\n", uint16_t(truncation_lsb_)));
 }
 
 void NvdlaDataFormatConvertor::set_truncation_bit_width (uint8_t    truncation_bit_width){
     truncation_bit_width_ = truncation_bit_width;
-    cslDebug((70, "NvdlaDataFormatConvertor::set_truncation_bit_width: truncation bit width is %d\n", uint16_t(truncation_bit_width_)));
+    //cslDebug((70, "NvdlaDataFormatConvertor::set_truncation_bit_width: truncation bit width is %d\n", uint16_t(truncation_bit_width_)));
 }
 
diff --git a/cmod/nvdla_payload/dla_b_transport_payload.cpp b/cmod/nvdla_payload/dla_b_transport_payload.cpp
index 5e846d4..43ec95e 100644
--- a/cmod/nvdla_payload/dla_b_transport_payload.cpp
+++ b/cmod/nvdla_payload/dla_b_transport_payload.cpp
@@ -47,16 +47,16 @@ dla_b_transport_payload::~dla_b_transport_payload()
 void dla_b_transport_payload::set_tlm_extension_by_type(tlm_generic_payload &gp, dla_b_transport_payload_type _type){
     switch ( _type ) {
         case DLA_B_TRANSPORT_PAYLOAD_TYPE_EMPTY:
-            cslDebug((30, "DLA_B_TRANSPORT_PAYLOAD_TYPE_EMPTY"));
+            //cslDebug((30, "DLA_B_TRANSPORT_PAYLOAD_TYPE_EMPTY"));
             // No extension
             break;
         case DLA_B_TRANSPORT_PAYLOAD_TYPE_MC:
-            cslDebug((30, "DLA_B_TRANSPORT_PAYLOAD_TYPE_MC"));
+            //cslDebug((30, "DLA_B_TRANSPORT_PAYLOAD_TYPE_MC"));
             nv_dbb_ext = new nvdla_dbb_extension();
             gp.set_extension(nv_dbb_ext);
             break;
         default:
-            cslDebug((30,  "set_tlm_extension_by_type: dla_b_transport_payload_type(%u), is not supported.", _type ));
+            //cslDebug((30,  "set_tlm_extension_by_type: dla_b_transport_payload_type(%u), is not supported.", _type ));
             assert(0);
     }
 }
@@ -84,7 +84,7 @@ void dla_b_transport_payload::configure_gp(
         bool is_read )
 {
     if( set_len > len ) {
-        cslDebug((30, "Setting a set_len(%u), which is larger than max len(%u)", set_len, len ));
+        //cslDebug((30, "Setting a set_len(%u), which is larger than max len(%u)", set_len, len ));
         assert(0);
     }
 
diff --git a/cmod/nvdla_top/NvdlaAxiAdaptor.cpp b/cmod/nvdla_top/NvdlaAxiAdaptor.cpp
index 55f5ae9..e5502b6 100644
--- a/cmod/nvdla_top/NvdlaAxiAdaptor.cpp
+++ b/cmod/nvdla_top/NvdlaAxiAdaptor.cpp
@@ -47,7 +47,7 @@ void NvdlaAxiAdaptor::nb_resp_thread()
             sc_time delay = sc_time(1, SC_NS);
             standard_axi->nb_transport_fw( *gp, phase, delay);
             done_request( *gp, delay );
-            cslDebug(( 50, "%s send END_RESP, tran = %p\n", basename(), gp ));
+            //cslDebug(( 50, "%s send END_RESP, tran = %p\n", basename(), gp ));
         }
     }
 }
@@ -58,9 +58,9 @@ void NvdlaAxiAdaptor::axi_rd_wr_thread()
     sc_time delay = sc_core::SC_ZERO_TIME;
     while (true) {
         if((axi_rd_req_fifo_->num_available()==0) && (axi_wr_req_fifo_->num_available()==0)) {
-            cslDebug((50, "NvdlaAxiAdaptor::axi_rd_wr_thread, no pending request, waiting.\n"));
+            //cslDebug((50, "NvdlaAxiAdaptor::axi_rd_wr_thread, no pending request, waiting.\n"));
             wait();
-            cslDebug((50, "NvdlaAxiAdaptor::axi_rd_wr_thread, get new request, wake up.\n"));
+            //cslDebug((50, "NvdlaAxiAdaptor::axi_rd_wr_thread, get new request, wake up.\n"));
         }
 
         // Get a read/write event
@@ -72,14 +72,14 @@ void NvdlaAxiAdaptor::axi_rd_wr_thread()
             if( m_perf ) {
                 axi_nb_transport_fw( *tlm_gp, delay );
             } else {
-                cslDebug(( 50, "NvdlaAxiAdaptor::axi_rd_wr_thread, before standard_axi (read)\n" ));
+                //cslDebug(( 50, "NvdlaAxiAdaptor::axi_rd_wr_thread, before standard_axi (read)\n" ));
                 tlm_gp->set_mm( m_mm ); // CVNAS require
                 standard_axi->b_transport(*tlm_gp, delay);
                 customized_rd_rsp->b_transport(*tlm_gp, delay);
-                cslDebug(( 50, "NvdlaAxiAdaptor::axi_rd_wr_thread, after standard_axi (read)\n" ));
+                //cslDebug(( 50, "NvdlaAxiAdaptor::axi_rd_wr_thread, after standard_axi (read)\n" ));
             }
             delete tlm_gp;
-            cslDebug((50, "NvdlaAxiAdaptor::axi_rd_wr_thread, send read request done\n"));
+            //cslDebug((50, "NvdlaAxiAdaptor::axi_rd_wr_thread, send read request done\n"));
         }
         // For Write request
         if (axi_wr_req_fifo_->nb_read(tlm_gp)) {
@@ -88,14 +88,14 @@ void NvdlaAxiAdaptor::axi_rd_wr_thread()
             if( m_perf ) {
                 axi_nb_transport_fw( *tlm_gp, delay );
             } else {
-                cslDebug(( 50, "NvdlaAxiAdaptor::axi_rd_wr_thread, before standard_axi (write)\n" ));
+                //cslDebug(( 50, "NvdlaAxiAdaptor::axi_rd_wr_thread, before standard_axi (write)\n" ));
                 tlm_gp->set_mm( m_mm ); // CVNAS require
                 standard_axi->b_transport(*tlm_gp, delay);
                 customized_wr_rsp->b_transport(*tlm_gp, delay);
-                cslDebug(( 50, "NvdlaAxiAdaptor::axi_rd_wr_thread, after standard_axi (write)\n" ));
+                //cslDebug(( 50, "NvdlaAxiAdaptor::axi_rd_wr_thread, after standard_axi (write)\n" ));
             }
             delete tlm_gp;
-            cslDebug((50, "NvdlaAxiAdaptor::axi_rd_wr_thread, send write request done\n"));
+            //cslDebug((50, "NvdlaAxiAdaptor::axi_rd_wr_thread, send write request done\n"));
         }
     }
 }
@@ -105,10 +105,10 @@ tlm_sync_enum NvdlaAxiAdaptor::axi_nb_transport_bw_cb(int ID, tlm_generic_payloa
 {
     switch( phase ) {
         case tlm::END_REQ:
-            cslDebug(( 50, "%s receive END_REQ, tran = %p\n", basename(), &tlm_gp ));
+            //cslDebug(( 50, "%s receive END_REQ, tran = %p\n", basename(), &tlm_gp ));
             break;
         case tlm::BEGIN_RESP:
-            cslDebug(( 50, "%s receive BEGIN_RESP, tran = %p\n", basename(), &tlm_gp ));
+            //cslDebug(( 50, "%s receive BEGIN_RESP, tran = %p\n", basename(), &tlm_gp ));
             m_peq.notify( tlm_gp, delay );
             break;
         default: FAIL(( "Illegal TLM phase transition!" ));
@@ -159,13 +159,13 @@ void NvdlaAxiAdaptor::axi_nb_transport_fw(tlm_generic_payload& tran, sc_time& de
     tlm_gp->acquire();
 
 	tlm_sync_enum sync = standard_axi->nb_transport_fw(*tlm_gp, phase, delay);
-    cslDebug(( 50, "%s send BEGIN_REQ, tran = %p\n", basename(), tlm_gp ));
+    //cslDebug(( 50, "%s send BEGIN_REQ, tran = %p\n", basename(), tlm_gp ));
 
     switch( sync ) {
         case tlm::TLM_COMPLETED:
         {
             done_request( *tlm_gp, delay );
-            cslDebug(( 50, "%s got TLM_COMPLETED, tran = %p\n", basename(), tlm_gp ));
+            //cslDebug(( 50, "%s got TLM_COMPLETED, tran = %p\n", basename(), tlm_gp ));
             break;
         }
         case tlm::TLM_ACCEPTED:
@@ -180,11 +180,11 @@ void NvdlaAxiAdaptor::axi_nb_transport_fw(tlm_generic_payload& tran, sc_time& de
         {
             switch( phase ) {
                 case tlm::END_REQ:
-                    cslDebug(( 50, "%s receive END_REQ, tran = %p\n", basename(), tlm_gp ));
+                    //cslDebug(( 50, "%s receive END_REQ, tran = %p\n", basename(), tlm_gp ));
                     break;
                 case tlm::BEGIN_RESP:
                     m_peq.notify( *tlm_gp, delay );
-                    cslDebug(( 50, "%s receive BEGIN_RESP, tran = %p\n", basename(), tlm_gp ));
+                    //cslDebug(( 50, "%s receive BEGIN_RESP, tran = %p\n", basename(), tlm_gp ));
                     break;
                 default: FAIL(( "Illegal TLM phase transition!" ));
             }
@@ -212,9 +212,9 @@ void NvdlaAxiAdaptor::customized_wr_req_b_transport(tlm_generic_payload& tlm_gp,
     tlm_generic_payload * new_tlm_gp = new tlm_generic_payload();
     deep_copy_gp(*new_tlm_gp, tlm_gp);
     uint64_t address = tlm_gp.get_address();
-    cslDebug(( 50, "before NvdlaAxiAdaptor::customized_wr_req_b_transport address=0x%lx\n", address ));
+    //cslDebug(( 50, "before NvdlaAxiAdaptor::customized_wr_req_b_transport address=0x%lx\n", address ));
     axi_wr_req_fifo_->write(new_tlm_gp);
-    cslDebug(( 50, "after NvdlaAxiAdaptor::customized_wr_req_b_transport\n" ));
+    //cslDebug(( 50, "after NvdlaAxiAdaptor::customized_wr_req_b_transport\n" ));
 }
 
 void NvdlaAxiAdaptor::customized_rd_req_b_transport(tlm_generic_payload& tlm_gp, sc_time& delay)
@@ -222,9 +222,9 @@ void NvdlaAxiAdaptor::customized_rd_req_b_transport(tlm_generic_payload& tlm_gp,
     tlm_generic_payload * new_tlm_gp = new tlm_generic_payload();
     deep_copy_gp(*new_tlm_gp, tlm_gp);
     uint64_t address = tlm_gp.get_address();
-    cslDebug(( 50, "before NvdlaAxiAdaptor::customized_rd_req_b_transport address=0x%lx\n", address ));
+    //cslDebug(( 50, "before NvdlaAxiAdaptor::customized_rd_req_b_transport address=0x%lx\n", address ));
     axi_rd_req_fifo_->write(new_tlm_gp);
-    cslDebug(( 50, "after NvdlaAxiAdaptor::customized_rd_req_b_transport\n" ));
+    //cslDebug(( 50, "after NvdlaAxiAdaptor::customized_rd_req_b_transport\n" ));
 }
 
 SCSIM_NAMESPACE_END()
diff --git a/cmod/pdp/NV_NVDLA_pdp.cpp b/cmod/pdp/NV_NVDLA_pdp.cpp
index a23e090..7d1a4fd 100644
--- a/cmod/pdp/NV_NVDLA_pdp.cpp
+++ b/cmod/pdp/NV_NVDLA_pdp.cpp
@@ -235,9 +235,9 @@ void NV_NVDLA_pdp::PdpRdmaSequenceThread(){
             case SPLIT_WIDTH_DIS_COMMON:
                 src_base_addr = uint64_t(pdp_rdma_src_base_addr_high_) << 32 | uint64_t(pdp_rdma_src_base_addr_low_) << 5;
                 cube_in_width = pdp_rdma_cube_in_width_ + 1;
-                cslDebug((30, "PdpRdmaSequenceThread, split disabled. before RdmaSequenceCommon. src_base_addr=0x%lx cube_in_width=0x%x\n", src_base_addr, cube_in_width));
+                //cslDebug((30, "PdpRdmaSequenceThread, split disabled. before RdmaSequenceCommon. src_base_addr=0x%lx cube_in_width=0x%x\n", src_base_addr, cube_in_width));
                 RdmaSequenceCommon(src_base_addr, cube_in_width);
-                cslDebug((30, "PdpRdmaSequenceThread, split disabled. after RdmaSequenceCommon\n"));
+                //cslDebug((30, "PdpRdmaSequenceThread, split disabled. after RdmaSequenceCommon\n"));
                 break;
 #pragma CTC SKIP
             case SPLIT_WIDTH_EN_16B_TO_8B:
@@ -265,9 +265,9 @@ void NV_NVDLA_pdp::PdpRdmaSequenceThread(){
                         src_base_addr += (int64_t)split_offset;
                         cube_in_width = partial_width_in_mid + (kernel_width - kernel_stride_width);
                     }
-                    cslDebug((30, "PdpRdmaSequenceThread, split iter %d. before RdmaSequenceCommon. src_base_addr=0x%lx cube_in_width=0x%x\n", split_iter, src_base_addr, cube_in_width));
+                    //cslDebug((30, "PdpRdmaSequenceThread, split iter %d. before RdmaSequenceCommon. src_base_addr=0x%lx cube_in_width=0x%x\n", split_iter, src_base_addr, cube_in_width));
                     RdmaSequenceCommon(src_base_addr, cube_in_width);
-                    cslDebug((30, "PdpRdmaSequenceThread, split enabled. after RdmaSequenceCommon\n"));
+                    //cslDebug((30, "PdpRdmaSequenceThread, split enabled. after RdmaSequenceCommon\n"));
                 }
                 break;
 #pragma CTC SKIP
@@ -534,7 +534,7 @@ void NV_NVDLA_pdp::PoolingStage0SequenceCommon(uint32_t cube_in_width, uint32_t
             for (width_iter=0; width_iter<cube_in_width; width_iter++) {    // Loop on each element in current line
                 // Fetch data (32B) from upstream
                 // FetchInputData ( reinterpret_cast <uint8_t *> (atomic_cube) );
-                cslDebug((50, "NV_NVDLA_pdp::PoolingStage0SequenceCommon, fetch input data s=%d of %d, h=%d of %d, w=%d of %d\n", surface_iter, surface_num, height_iter, cube_in_height, width_iter, cube_in_width));
+                //cslDebug((50, "NV_NVDLA_pdp::PoolingStage0SequenceCommon, fetch input data s=%d of %d, h=%d of %d, w=%d of %d\n", surface_iter, surface_num, height_iter, cube_in_height, width_iter, cube_in_width));
                 atomic_cube = FetchInputData ();
                 atomic_cube_ptr_int8  = reinterpret_cast <int8_t *> (atomic_cube);
                 atomic_cube_ptr_int16 = reinterpret_cast <int16_t *> (atomic_cube);
@@ -565,22 +565,22 @@ void NV_NVDLA_pdp::PoolingStage0SequenceCommon(uint32_t cube_in_width, uint32_t
                             idx_atom_height_out = (pad_top + height_iter - kernel_height_iter)/kernel_stride_height;
                             if(valid_height_iter)
                             {
-                                cslDebug((50, "Input s=%d w=%d h=%d maps to output w=%d h=%d, data: ", surface_iter, width_iter, height_iter, idx_atom_width_out, idx_atom_height_out));
-                                for(int i=0; i<ATOM_CUBE_SIZE; i++) cslDebug((50, "%02x ", atomic_cube[i]));
-                                cslDebug((50, "\n"));
+                                //cslDebug((50, "Input s=%d w=%d h=%d maps to output w=%d h=%d, data: ", surface_iter, width_iter, height_iter, idx_atom_width_out, idx_atom_height_out));
+                                //for(int i=0; i<ATOM_CUBE_SIZE; i++) cslDebug((50, "%02x ", atomic_cube[i]));
+                                //cslDebug((50, "\n"));
                             }
                         }
 #endif
 						uint32_t lob_idx = idx_atom_width_out%overlapped_kernel_max_num_width;
                         // Do line opertion
-                        cslDebug((50, "kernel_width_iter:0x%02x, idx_atom_width_out:0x%02x lob_idx:%d\n", kernel_width_iter, idx_atom_width_out, lob_idx));
+                        //cslDebug((50, "kernel_width_iter:0x%02x, idx_atom_width_out:0x%02x lob_idx:%d\n", kernel_width_iter, idx_atom_width_out, lob_idx));
                         switch (precision) {
                             case DATA_FORMAT_INT8:
-                                cslDebug((50, "Line_operation_buffer_atom_address:0x%04x, Line_operation_buffer_address:0x%08x\n", lob_idx, lob_idx*ELEMENT_PER_ATOM_INT8));
+                                //cslDebug((50, "Line_operation_buffer_atom_address:0x%04x, Line_operation_buffer_address:0x%08x\n", lob_idx, lob_idx*ELEMENT_PER_ATOM_INT8));
                                 LineOperation (atomic_cube_ptr_int8, &line_operation_buffer_ptr_int8[lob_idx*ELEMENT_PER_ATOM_INT8], kernel_width_iter, kernel_width, width_iter, cube_in_width, padding_value_array_ptr_int8, ELEMENT_PER_ATOM_INT8, pad_left);
                                 break;
                             case DATA_FORMAT_INT16:
-                                cslDebug((50, "Line_operation_buffer_atom_address:0x%04x, Line_operation_buffer_address:0x%08x\n", lob_idx, lob_idx*ELEMENT_PER_ATOM_INT16));
+                                //cslDebug((50, "Line_operation_buffer_atom_address:0x%04x, Line_operation_buffer_address:0x%08x\n", lob_idx, lob_idx*ELEMENT_PER_ATOM_INT16));
                                 LineOperation (atomic_cube_ptr_int16, &line_operation_buffer_ptr_int16[lob_idx*ELEMENT_PER_ATOM_INT16], kernel_width_iter, kernel_width, width_iter, cube_in_width, padding_value_array_ptr_int16, ELEMENT_PER_ATOM_INT16, pad_left);
                                 break;
                             case DATA_FORMAT_FP16:
@@ -599,7 +599,7 @@ void NV_NVDLA_pdp::PoolingStage0SequenceCommon(uint32_t cube_in_width, uint32_t
                                                     ((pad_top + height_iter + (kernel_height - kernel_height_iter) <= pad_top + pad_bottom + cube_in_height)) &&  //Bottom boundary
                                                     ((pad_top + height_iter - kernel_height_iter)%kernel_stride_height == 0);
                                 idx_atom_height_out = (pad_top + height_iter - kernel_height_iter)/kernel_stride_height;
-                                cslDebug((50, "kernel_height_iter:0x%02x, idx_atom_height_out:0x%02x\n", kernel_height_iter, idx_atom_height_out));
+                                //cslDebug((50, "kernel_height_iter:0x%02x, idx_atom_height_out:0x%02x\n", kernel_height_iter, idx_atom_height_out));
                                 if (valid_height_iter) {
                                     uint32_t atomic_stride   = uint32_t(ATOM_CUBE_SIZE) * 2;     //In size of Byte. INT8 uses 2bytes, INT16 and FP16 uses 4bytes
                                     uint32_t line_stride     = cube_out_width * atomic_stride;
@@ -610,13 +610,13 @@ void NV_NVDLA_pdp::PoolingStage0SequenceCommon(uint32_t cube_in_width, uint32_t
                                     uint32_t linebuf_entry_idx = linebuf_start_idx * output_size / atomic_stride;
                                     // The first input (left most and up most) element which contributes to the same output element
                                     is_first_element = IsContributeToANewLine(height_iter, kernel_height_iter);
-                                    cslDebug((50, "is_first_element=%d surface_iter=0x%x height_iter=0x%x width_iter=0x%x kernel_width_iter=0x%x kernel_height_iter=0x%x\n", is_first_element, surface_iter, height_iter, width_iter, kernel_width_iter, kernel_height_iter));
+                                    //cslDebug((50, "is_first_element=%d surface_iter=0x%x height_iter=0x%x width_iter=0x%x kernel_width_iter=0x%x kernel_height_iter=0x%x\n", is_first_element, surface_iter, height_iter, width_iter, kernel_width_iter, kernel_height_iter));
 
                                     if (is_first_element) 
                                     {
-                                        cslDebug((50, "attempt writing to line_buffer_usage_free_[%d]\n", linebuf_entry_idx));
+                                        //cslDebug((50, "attempt writing to line_buffer_usage_free_[%d]\n", linebuf_entry_idx));
                                         line_buffer_usage_free_[linebuf_entry_idx]->write(1);  //hold space of one atom in line buffer. the space will be released in stage1
-                                        cslDebug((50, "wrote to line_buffer_usage_free_[%d]\n", linebuf_entry_idx));
+                                        //cslDebug((50, "wrote to line_buffer_usage_free_[%d]\n", linebuf_entry_idx));
                                     }
 
                                     switch (precision) {
@@ -636,10 +636,10 @@ void NV_NVDLA_pdp::PoolingStage0SequenceCommon(uint32_t cube_in_width, uint32_t
                                     }
                                     // If it is the last (right most and down most) element, incr incr_line_buffer_available_atom_
                                     is_last_element = IsLastElement(cube_in_width, pad_left, width_iter, height_iter, kernel_width_iter, kernel_height_iter);
-                                    cslDebug((50, "is_last_element=%d surface_iter=0x%x height_iter=0x%x width_iter=0x%x kernel_width_iter=0x%x kernel_height_iter=0x%x\n", is_last_element, surface_iter, height_iter, width_iter, kernel_width_iter, kernel_height_iter));
+                                    //cslDebug((50, "is_last_element=%d surface_iter=0x%x height_iter=0x%x width_iter=0x%x kernel_width_iter=0x%x kernel_height_iter=0x%x\n", is_last_element, surface_iter, height_iter, width_iter, kernel_width_iter, kernel_height_iter));
                                     if (is_last_element)
                                     {
-                                        cslDebug((50, "write to line_buffer_ready_[%d], out h=%d, out w=%d\n", linebuf_entry_idx, idx_atom_height_out, idx_atom_width_out));
+                                        //cslDebug((50, "write to line_buffer_ready_[%d], out h=%d, out w=%d\n", linebuf_entry_idx, idx_atom_height_out, idx_atom_width_out));
                                         //cslDebug((50, "write to line_buffer_usage_available_\n"));
                                         //line_buffer_usage_available_->write(1); //tell stage1 that there is available in line buffer.
                                         line_buffer_ready_[linebuf_entry_idx]->write(1);
@@ -787,10 +787,10 @@ void NV_NVDLA_pdp::PoolingStage1SequenceCommon(uint32_t cube_out_width, uint32_t
                     }
                 }
 
-                cslDebug((70, "NV_NVDLA_pdp::PoolingStage1SequenceCommon, write to wdma_buffer: "));
-                for(int i=0;i<32;i++)
-                    cslDebug((70, "0x%02x ", atomic_cube[i]));
-                cslDebug((70, "\n"));
+                //cslDebug((70, "NV_NVDLA_pdp::PoolingStage1SequenceCommon, write to wdma_buffer: "));
+                //for(int i=0;i<32;i++)
+                    //cslDebug((70, "0x%02x ", atomic_cube[i]));
+                //cslDebug((70, "\n"));
             }
         }
     }
@@ -950,9 +950,9 @@ void NV_NVDLA_pdp::WdmaSequenceCommon(uint64_t dst_base_addr, uint32_t cube_out_
                 if ( split_last && (surface_iter+1 == surface_num) && (output_height_iter+1 == cube_out_height) ) {
                     is_required_ack = true;
                 }
-                cslDebug((50, "NV_NVDLA_pdp::WdmaSequenceCommon, SendDmaWriteRequest h=%d of %d\n", output_height_iter, cube_out_height));
+                //cslDebug((50, "NV_NVDLA_pdp::WdmaSequenceCommon, SendDmaWriteRequest h=%d of %d\n", output_height_iter, cube_out_height));
                 SendDmaWriteRequest(payload_addr, payload_size, payload_atom_num, is_required_ack);
-                cslDebug((50, "NV_NVDLA_pdp::WdmaSequenceCommon, SendDmaWriteRequest done\n"));
+                //cslDebug((50, "NV_NVDLA_pdp::WdmaSequenceCommon, SendDmaWriteRequest done\n"));
             }
         }
     }
@@ -1184,13 +1184,13 @@ void NV_NVDLA_pdp::WaitUntilWdmaBufferAvailableSizeGreaterThan(uint32_t num) {
 // Send DMA read request
 void NV_NVDLA_pdp::SendDmaReadRequest(nvdla_dma_rd_req_t* payload, sc_time& delay) {
     if (NVDLA_PDP_RDMA_D_SRC_RAM_CFG_0_SRC_RAM_TYPE_MC== pdp_rdma_src_ram_type_) {
-        cslDebug((50, "NV_NVDLA_pdp::SendDmaReadRequest to MC, payload_addr=0x%lx payload_atom_num=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size+1));
+        //cslDebug((50, "NV_NVDLA_pdp::SendDmaReadRequest to MC, payload_addr=0x%lx payload_atom_num=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size+1));
         NV_NVDLA_pdp_base::pdp2mcif_rd_req_b_transport(payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_pdp::SendDmaReadRequest to MC, done\n"));
+        //cslDebug((50, "NV_NVDLA_pdp::SendDmaReadRequest to MC, done\n"));
     } else {
-        cslDebug((50, "NV_NVDLA_pdp::SendDmaReadRequest to CV  payload_addr=0x%lx payload_atom_num=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size+1));
+        //cslDebug((50, "NV_NVDLA_pdp::SendDmaReadRequest to CV  payload_addr=0x%lx payload_atom_num=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size+1));
         NV_NVDLA_pdp_base::pdp2cvif_rd_req_b_transport(payload, dma_delay_);
-        cslDebug((50, "NV_NVDLA_pdp::SendDmaReadRequest to CV, done\n"));
+        //cslDebug((50, "NV_NVDLA_pdp::SendDmaReadRequest to CV, done\n"));
     }
 }
 
@@ -1203,7 +1203,7 @@ void NV_NVDLA_pdp::ExtractDmaPayload(nvdla_dma_rd_rsp_t* payload){
     mask = payload->pd.dma_read_data.mask;
     payload_data_ptr    = reinterpret_cast <uint8_t *> (payload->pd.dma_read_data.data);
 
-    cslDebug((50, "NV_NVDLA_pdp::ExtractDmaPayload\n"));
+    //cslDebug((50, "NV_NVDLA_pdp::ExtractDmaPayload\n"));
 
     // Handling lower 32 bytes
     if (0 != (mask & 0x1)) {
@@ -1229,17 +1229,17 @@ void NV_NVDLA_pdp::ExtractDmaPayload(nvdla_dma_rd_rsp_t* payload){
                     else
                     {
                         nan_input_num++;
-                        cslDebug((70, "got NaN:%x i=%d\n", ptr[i], i));
+                        //cslDebug((70, "got NaN:%x i=%d\n", ptr[i], i));
                     }
                 }
             }
         }
 
 #ifdef NVDLA_CMOD_DEBUG
-        cslDebug((70, "write to rdma_buffer. mask A\n"));
-        for(int i=0;i<32;i++)
-            cslDebug((70, "0x%02x \n", rdma_atom_cube_ptr[i]);
-        cslDebug((70, "\n"));
+        //cslDebug((70, "write to rdma_buffer. mask A\n"));
+        //for(int i=0;i<32;i++)
+            //cslDebug((70, "0x%02x \n", rdma_atom_cube_ptr[i]);
+        //cslDebug((70, "\n"));
 #endif
     }
 
@@ -1267,21 +1267,21 @@ void NV_NVDLA_pdp::ExtractDmaPayload(nvdla_dma_rd_rsp_t* payload){
                     else
                     {
                         nan_input_num++;
-                        cslDebug((70, "got NaN:%x i=%d\n", ptr[i], i));
+                        //cslDebug((70, "got NaN:%x i=%d\n", ptr[i], i));
                     }
                 }
             }
         }
 
 #ifdef NVDLA_CMOD_DEBUG
-        cslDebug((70, "write to rdma_buffer. mask B\n"));
-        for(int i=0;i<32;i++)
-            cslDebug((70, "0x%02x \n", rdma_atom_cube_ptr[i]));
-        cslDebug((70, "\n"));
+        //cslDebug((70, "write to rdma_buffer. mask B\n"));
+        //for(int i=0;i<32;i++)
+            //cslDebug((70, "0x%02x \n", rdma_atom_cube_ptr[i]));
+        //cslDebug((70, "\n"));
 #endif
     }
 
-    cslDebug((50, "NV_NVDLA_pdp::ExtractDmaPayload done\n"));
+    //cslDebug((50, "NV_NVDLA_pdp::ExtractDmaPayload done\n"));
 }
 
 void NV_NVDLA_pdp::mcif2pdp_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* payload, sc_core::sc_time& delay){
@@ -1303,15 +1303,15 @@ void NV_NVDLA_pdp::SendDmaWriteRequest(uint64_t payload_addr, uint32_t payload_s
     payload_data_ptr = reinterpret_cast <uint8_t  *>  (dma_wr_req_data_payload_->pd.dma_write_data.data);
     //WaitUntilWdmaBufferAvailableSizeGreaterThan(payload_atom_num);
     // Send write command
-    cslDebug((50, "NV_NVDLA_pdp::SendDmaWriteRequest cmd, payload_addr=0x%lx payload_atom_num=0x%x\n", payload_addr, payload_atom_num));
+    //cslDebug((50, "NV_NVDLA_pdp::SendDmaWriteRequest cmd, payload_addr=0x%lx payload_atom_num=0x%x\n", payload_addr, payload_atom_num));
     SendDmaWriteRequest(dma_wr_req_cmd_payload_, dma_delay_, ack_required);
-    cslDebug((50, "NV_NVDLA_pdp::SendDmaWriteRequest cmd done\n"));
+    //cslDebug((50, "NV_NVDLA_pdp::SendDmaWriteRequest cmd done\n"));
     for (atom_iter = 0; atom_iter < payload_atom_num; atom_iter++) {
         dma_write_data_ptr = wdma_buffer_->read();
-        cslDebug((50, "NV_NVDLA_pdp::SendDmaWriteRequest data w=%d of %d, read from wdma_buffer_: ", atom_iter, payload_atom_num));
-        for(int i=0;i<32;i++)
-            cslDebug((70, "0x%02x ", dma_write_data_ptr[i]));
-        cslDebug((70, "\n"));
+        //cslDebug((50, "NV_NVDLA_pdp::SendDmaWriteRequest data w=%d of %d, read from wdma_buffer_: ", atom_iter, payload_atom_num));
+        //for(int i=0;i<32;i++)
+            //cslDebug((70, "0x%02x ", dma_write_data_ptr[i]));
+        //cslDebug((70, "\n"));
         memcpy (&payload_data_ptr[ATOM_CUBE_SIZE*(atom_iter%2)], dma_write_data_ptr, ATOM_CUBE_SIZE);
         delete[] dma_write_data_ptr;
         // Send write data
@@ -1389,11 +1389,11 @@ uint8_t * NV_NVDLA_pdp::FetchInputData () {
             // Int8, 16 bits per container, only use lower 8 bits
             for (round_iter = 0; round_iter < 2; round_iter ++) {
                 sdp2pdp_payload_data = spd2pdp_fifo_->read();
-                cslDebug((50, "Before copy data from sdp2pdp_payload_data to data\n"));
+                //cslDebug((50, "Before copy data from sdp2pdp_payload_data to data\n"));
                 for (spd2pdp_element_iter = 0; spd2pdp_element_iter < SDP2PDP_PAYLOAD_ELEMENT_NUM; spd2pdp_element_iter ++) {
                     data[round_iter*SDP2PDP_PAYLOAD_ELEMENT_NUM+spd2pdp_element_iter] =  sdp2pdp_payload_data[spd2pdp_element_iter*2];
                 }
-                cslDebug((50, "After copy data from sdp2pdp_payload_data to data\n"));
+                //cslDebug((50, "After copy data from sdp2pdp_payload_data to data\n"));
 #pragma CTC SKIP
                 if (sdp2pdp_payload_data) delete [] sdp2pdp_payload_data;
 #pragma CTC ENDSKIP
@@ -1409,11 +1409,11 @@ uint8_t * NV_NVDLA_pdp::FetchInputData () {
     } else if (POOLING_FLYING_MODE_OFF_FLYING == pdp_flying_mode_) {
         // atomic_cube = rdma_buffer_->read();
         data = rdma_buffer_->read();
-        cslDebug((50, "FetchInputData: read rdma_buffer, data is.\n"));
+        //cslDebug((50, "FetchInputData: read rdma_buffer, data is.\n"));
         for(int i=0;i<32;i++) {
-            cslDebug((50, "0x%02x ", data[i]));
+            //cslDebug((50, "0x%02x ", data[i]));
         }
-        cslDebug((50, "\n"));
+        //cslDebug((50, "\n"));
     } else {
 #pragma CTC SKIP
         FAIL(("NV_NVDLA_pdp::FetchInputData, invalid flying mode."));
@@ -1425,22 +1425,22 @@ uint8_t * NV_NVDLA_pdp::FetchInputData () {
 template <typename T_IN, typename T_OUT, typename T_PAD>
 void NV_NVDLA_pdp::LineOperation (T_IN * atomic_data_in, T_OUT * line_buffer_ptr, uint32_t kernel_width_iter, uint32_t kernel_width, uint32_t cube_in_width_iter, uint32_t cube_in_width, T_PAD * padding_value_ptr, uint8_t element_num, uint32_t pad_left) {
     uint32_t element_idx;
-    cslDebug((50, "NV_NVDLA_pdp::LineOperation: kernel_width_iter:0x%04x, kernel_width:0x%04x, cube_in_width_iter:0x%04x, cube_in_width:0x%04x\n", kernel_width_iter, kernel_width, cube_in_width_iter, cube_in_width));
-    cslDebug((50, "NV_NVDLA_pdp::LineOperation, padding_value_ptr:\n"));
+    //cslDebug((50, "NV_NVDLA_pdp::LineOperation: kernel_width_iter:0x%04x, kernel_width:0x%04x, cube_in_width_iter:0x%04x, cube_in_width:0x%04x\n", kernel_width_iter, kernel_width, cube_in_width_iter, cube_in_width));
+    //cslDebug((50, "NV_NVDLA_pdp::LineOperation, padding_value_ptr:\n"));
     for (element_idx=0; element_idx<PDP_MAX_PADDING_SIZE; element_idx++) {
-        cslDebug((50, "0x%08x ", (uint32_t)padding_value_ptr[element_idx] & 0xffffffff));
+        //cslDebug((50, "0x%08x ", (uint32_t)padding_value_ptr[element_idx] & 0xffffffff));
     }
-    cslDebug((50, "\n"));
-    cslDebug((50, "LineOperation, operand: atom data:\n"));
+    //cslDebug((50, "\n"));
+    //cslDebug((50, "LineOperation, operand: atom data:\n"));
     for (element_idx=0; element_idx<element_num; element_idx++) {
-        cslDebug((50, "0x%04x ", (uint16_t)atomic_data_in[element_idx] & 0xffff));
+        //cslDebug((50, "0x%04x ", (uint16_t)atomic_data_in[element_idx] & 0xffff));
     }
-    cslDebug((50, "\n"));
-    cslDebug((50, "LineOperation, operand: line buffer data:\n"));
+    //cslDebug((50, "\n"));
+    //cslDebug((50, "LineOperation, operand: line buffer data:\n"));
     for (element_idx=0; element_idx<element_num; element_idx++) {
-        cslDebug((50, "0x%08x ", (uint32_t)line_buffer_ptr[element_idx] & 0xffffffff));
+        //cslDebug((50, "0x%08x ", (uint32_t)line_buffer_ptr[element_idx] & 0xffffffff));
     }
-    cslDebug((50, "\n"));
+    //cslDebug((50, "\n"));
 
     bool is_first_element = (0 == cube_in_width_iter) || (0 == kernel_width_iter);
     bool add_left_padding = (cube_in_width_iter + 1 < kernel_width) && ((kernel_width_iter+1 == kernel_width) || ((cube_in_width_iter + 1 == cube_in_width) && (cube_in_width_iter < kernel_width_iter) && pad_left));
@@ -1453,13 +1453,13 @@ void NV_NVDLA_pdp::LineOperation (T_IN * atomic_data_in, T_OUT * line_buffer_ptr
     {
         uint32_t num = kernel_width - (cube_in_width_iter + 1);
         padding_value_left = padding_value_ptr[num-1];
-        cslDebug((50, "pad left %d\n", num));
+        //cslDebug((50, "pad left %d\n", num));
     }
     else if(add_right_padding)
     {
         uint32_t num = kernel_width - (kernel_width_iter + 1);
         padding_value_right = padding_value_ptr[num-1];
-        cslDebug((50, "pad right %d\n", num));
+        //cslDebug((50, "pad right %d\n", num));
     }
 
     for (element_idx=0; element_idx<element_num; element_idx++) {
@@ -1509,11 +1509,11 @@ void NV_NVDLA_pdp::LineOperation (T_IN * atomic_data_in, T_OUT * line_buffer_ptr
 #pragma CTC ENDSKIP
         }
     }
-    cslDebug((50, "LineOperation, result: line buffer data\n"));
+    //cslDebug((50, "LineOperation, result: line buffer data\n"));
     for (element_idx=0; element_idx<element_num; element_idx++) {
-        cslDebug((50, "0x%08x ", (uint32_t)line_buffer_ptr[element_idx] & 0xffffffff));
+        //cslDebug((50, "0x%08x ", (uint32_t)line_buffer_ptr[element_idx] & 0xffffffff));
     }
-    cslDebug((50, "\n"));
+    //cslDebug((50, "\n"));
 }
 
 // User shall make sure T_IN and T_OUT type is match
@@ -1538,21 +1538,21 @@ void NV_NVDLA_pdp::PoolingStage0Calc (T_IN * atomic_data_in, T_OUT * line_buffer
     linebuf_start_idx = ((acc_subcube_start + surface*surf_stride + cube_out_height_idx*line_stride + cube_out_width_idx * atomic_stride)%sizeof(line_buffer_))/sizeof(T_OUT);
     kernel_width    = pdp_kernel_width_+1;
 
-    cslDebug((50, "PoolingStage0Calc::padding_value_ptr:\n"));
+    //cslDebug((50, "PoolingStage0Calc::padding_value_ptr:\n"));
     for (element_idx=0; element_idx<PDP_MAX_PADDING_SIZE; element_idx++) {
-        cslDebug((50, "0x%08x ", (uint32_t)padding_value_ptr[element_idx] & 0xffffffff));
+        //cslDebug((50, "0x%08x ", (uint32_t)padding_value_ptr[element_idx] & 0xffffffff));
     }
-    cslDebug((50, "\n"));
-    cslDebug((50, "PoolingStage0Calc::operand: atom data:\n"));
+    //cslDebug((50, "\n"));
+    //cslDebug((50, "PoolingStage0Calc::operand: atom data:\n"));
     for (element_idx=0; element_idx<element_num; element_idx++) {
-        cslDebug((50, "0x%08x ", (uint32_t)atomic_data_in[element_idx] & 0xffffffff));
+        //cslDebug((50, "0x%08x ", (uint32_t)atomic_data_in[element_idx] & 0xffffffff));
     }
-    cslDebug((50, "\n"));
-    cslDebug((50, "PoolingStage0Calc::operand: linebuf_start_idx=0x%x data:\n", linebuf_start_idx));
+    //cslDebug((50, "\n"));
+    //cslDebug((50, "PoolingStage0Calc::operand: linebuf_start_idx=0x%x data:\n", linebuf_start_idx));
     for (element_idx=0; element_idx<element_num; element_idx++) {
-        cslDebug((50, "0x%08x ", (uint32_t)line_buffer_ptr[linebuf_start_idx  + element_idx] & 0xffffffff));
+        //cslDebug((50, "0x%08x ", (uint32_t)line_buffer_ptr[linebuf_start_idx  + element_idx] & 0xffffffff));
     }
-    cslDebug((50, "\n"));
+    //cslDebug((50, "\n"));
 
     bool is_first_element = (0 == cube_in_height_iter) || (0 == kernel_height_iter);
     bool add_top_padding = (cube_in_height_iter + 1 < kernel_height) && ((kernel_height_iter+1 == kernel_height) || ((cube_in_height_iter + 1 == cube_in_height) && (cube_in_height_iter < kernel_height_iter)));
@@ -1565,13 +1565,13 @@ void NV_NVDLA_pdp::PoolingStage0Calc (T_IN * atomic_data_in, T_OUT * line_buffer
     {
         uint32_t num = kernel_height - (cube_in_height_iter + 1);
         padding_value_top = padding_value_ptr[num-1];
-        cslDebug((50, "pad top %d\n", num));
+        //cslDebug((50, "pad top %d\n", num));
     }
     else if(add_bottom_padding)
     {
         uint32_t num = kernel_height - (kernel_height_iter + 1);
         padding_value_bottom = padding_value_ptr[num-1];
-        cslDebug((50, "pad bottom %d\n", num));
+        //cslDebug((50, "pad bottom %d\n", num));
     }
   
     if(pdp_input_data_ != DATA_FORMAT_FP16)
@@ -1628,11 +1628,11 @@ void NV_NVDLA_pdp::PoolingStage0Calc (T_IN * atomic_data_in, T_OUT * line_buffer
         }
         //}
     }
-    cslDebug((50, "PoolingStage0Calc::result w=%d h=%d, line buffer data\n", cube_out_width_idx, cube_out_height_idx));
+    //cslDebug((50, "PoolingStage0Calc::result w=%d h=%d, line buffer data\n", cube_out_width_idx, cube_out_height_idx));
     for (element_idx=0; element_idx<element_num; element_idx++) {
-        cslDebug((50, "0x%08x ", (uint32_t)line_buffer_ptr[linebuf_start_idx  + element_idx] & 0xffffffff));
+        //cslDebug((50, "0x%08x ", (uint32_t)line_buffer_ptr[linebuf_start_idx  + element_idx] & 0xffffffff));
     }
-    cslDebug((50, "\n"));
+    //cslDebug((50, "\n"));
 }
 
 // This function is useful only for AVERAGE pooling method
@@ -1699,17 +1699,17 @@ void NV_NVDLA_pdp::PoolingStage1Calc (T_OUT * atomic_data_out, T_IN * line_buffe
     //     uint32_t upper_mask = (1 << upper_bits) - 1;
     //     pad_value_1x |= upper_mask << output_bits;
     // }
-    cslDebug((50, "NV_NVDLA_pdp::PoolingStage1Calc\n"));
+    //cslDebug((50, "NV_NVDLA_pdp::PoolingStage1Calc\n"));
 
     linebuf_entry_idx = linebuf_start_idx*sizeof(T_IN)/atomic_stride;
 
-    cslDebug((50, "attempt read line_buffer_ready_[%d], h=%d, w=%d\n", linebuf_entry_idx, height, width));
+    //cslDebug((50, "attempt read line_buffer_ready_[%d], h=%d, w=%d\n", linebuf_entry_idx, height, width));
     line_buffer_ready_[linebuf_entry_idx]->read();
-    cslDebug((50, "read line_buffer_ready_[%d]\n", linebuf_entry_idx));
+    //cslDebug((50, "read line_buffer_ready_[%d]\n", linebuf_entry_idx));
 
-    cslDebug((50, "attempt read line_buffer_usage_free_[%d], h=%d, w=%d\n", linebuf_entry_idx, height, width));
+    //cslDebug((50, "attempt read line_buffer_usage_free_[%d], h=%d, w=%d\n", linebuf_entry_idx, height, width));
     line_buffer_usage_free_[linebuf_entry_idx]->read();
-    cslDebug((50, "read line_buffer_usage_free_[%d]\n", linebuf_entry_idx));
+    //cslDebug((50, "read line_buffer_usage_free_[%d]\n", linebuf_entry_idx));
 
     for (element_idx=0; element_idx<element_num; element_idx++) {
         if(pdp_input_data_ == DATA_FORMAT_FP16)
@@ -1734,7 +1734,7 @@ void NV_NVDLA_pdp::PoolingStage1Calc (T_OUT * atomic_data_out, T_IN * line_buffe
                     tmp_int = (tmp_out > 0)? (tmp_out + 0.5) : (tmp_out - 0.5);
 
                     atomic_data_out[element_idx] = static_cast<T_OUT>(tmp_int);
-                    cslDebug((50, "PoolingStage1Calc linebuf_start_idx=0x%x element_idx=0x%x sum=0x%x tmp_sum=0x%x atomic_data_out=0x%x\n", linebuf_start_idx, (uint32_t)element_idx, line_buffer_ptr[linebuf_start_idx + element_idx], tmp_sum, atomic_data_out[element_idx]));
+                    //cslDebug((50, "PoolingStage1Calc linebuf_start_idx=0x%x element_idx=0x%x sum=0x%x tmp_sum=0x%x atomic_data_out=0x%x\n", linebuf_start_idx, (uint32_t)element_idx, line_buffer_ptr[linebuf_start_idx + element_idx], tmp_sum, atomic_data_out[element_idx]));
                     break;
                 }
 #pragma CTC SKIP
@@ -1748,7 +1748,7 @@ void NV_NVDLA_pdp::PoolingStage1Calc (T_OUT * atomic_data_out, T_IN * line_buffe
 }
 
 void NV_NVDLA_pdp::WriteResponseThreadMc() {
-    cslDebug((50, "NV_NVDLA_pdp::WriteResponseThreadMc is called\n"));
+    //cslDebug((50, "NV_NVDLA_pdp::WriteResponseThreadMc is called\n"));
     if ( true == mcif2pdp_wr_rsp.read() ) {
 #if 0
         if (NVDLA_PDP_D_DST_RAM_CFG_0_DST_RAM_TYPE_MC != pdp_dst_ram_type_) {
@@ -1877,9 +1877,9 @@ void NV_NVDLA_pdp::reset_stats_regs() {
 }
 
 void NV_NVDLA_pdp::update_stats_regs() {
-    cslInfo(("NV_NVDLA_pdp, nan_input_num:%d\n", nan_input_num));
-    cslInfo(("NV_NVDLA_pdp, inf_input_num:%d\n", inf_input_num));
-    cslInfo(("NV_NVDLA_pdp, nan_output_num:%d\n", nan_output_num));
+    //cslInfo(("NV_NVDLA_pdp, nan_input_num:%d\n", nan_input_num));
+    //cslInfo(("NV_NVDLA_pdp, inf_input_num:%d\n", inf_input_num));
+    //cslInfo(("NV_NVDLA_pdp, nan_output_num:%d\n", nan_output_num));
     pdp_reg_model::PdpUpdateStatusRegister((uint32_t)NVDLA_PDP_D_NAN_INPUT_NUM_0,  pdp_consumer_, (uint32_t)nan_input_num);
     pdp_reg_model::PdpUpdateStatusRegister((uint32_t)NVDLA_PDP_D_INF_INPUT_NUM_0,  pdp_consumer_, (uint32_t)inf_input_num);
     pdp_reg_model::PdpUpdateStatusRegister((uint32_t)NVDLA_PDP_D_NAN_OUTPUT_NUM_0, pdp_consumer_, (uint32_t)nan_output_num);
diff --git a/cmod/pdp/gen/pdp_rdma_reg_model.cpp b/cmod/pdp/gen/pdp_rdma_reg_model.cpp
index 06bdfed..7557c58 100644
--- a/cmod/pdp/gen/pdp_rdma_reg_model.cpp
+++ b/cmod/pdp/gen/pdp_rdma_reg_model.cpp
@@ -85,7 +85,7 @@ bool pdp_rdma_reg_model::PdpRdmaAccessRegister(uint32_t reg_addr, uint32_t & dat
                 pdp_rdma_register_group_0->SetWritable(offset, data);
                 if (pdp_rdma_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_pdp_rdma_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "pdp_rdma_reg_model::PdpRdmaAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "pdp_rdma_reg_model::PdpRdmaAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -97,7 +97,7 @@ bool pdp_rdma_reg_model::PdpRdmaAccessRegister(uint32_t reg_addr, uint32_t & dat
                 pdp_rdma_register_group_1->SetWritable(offset, data);
                 if (pdp_rdma_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_pdp_rdma_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "pdp_rdma_reg_model::PdpRdmaAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "pdp_rdma_reg_model::PdpRdmaAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/pdp/gen/pdp_reg_model.cpp b/cmod/pdp/gen/pdp_reg_model.cpp
index 451282a..70d3770 100644
--- a/cmod/pdp/gen/pdp_reg_model.cpp
+++ b/cmod/pdp/gen/pdp_reg_model.cpp
@@ -85,7 +85,7 @@ bool pdp_reg_model::PdpAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 pdp_register_group_0->SetWritable(offset, data);
                 if (pdp_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_pdp_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "pdp_reg_model::PdpAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "pdp_reg_model::PdpAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -97,7 +97,7 @@ bool pdp_reg_model::PdpAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 pdp_register_group_1->SetWritable(offset, data);
                 if (pdp_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_pdp_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "pdp_reg_model::PdpAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "pdp_reg_model::PdpAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/rubik/NV_NVDLA_rbk.cpp b/cmod/rubik/NV_NVDLA_rbk.cpp
index eab6fb5..e809576 100644
--- a/cmod/rubik/NV_NVDLA_rbk.cpp
+++ b/cmod/rubik/NV_NVDLA_rbk.cpp
@@ -95,11 +95,11 @@ void NV_NVDLA_rbk::ExtractDmaPayload(sc_fifo <uint8_t *> *dma_fifo, nvdla_dma_rd
         rdma_atom_cube_ptr = new uint8_t[RUBIK_ATOM_CUBE_SIZE]; 
         memcpy(rdma_atom_cube_ptr, payload_data_ptr, RUBIK_ATOM_CUBE_SIZE);
         dma_fifo->write(rdma_atom_cube_ptr);
-        cslDebug((70, "NV_NVDLA_rbk::ExtractDmaPayload, write to dma_fifo. mask A, num_free:%d, num_avail:%d\n",
-                    dma_fifo->num_free(), dma_fifo->num_available()));
-        for(int i=0;i<32;i++)
-            cslDebug((70, "0x%02x \n", rdma_atom_cube_ptr[i]));
-        cslDebug((70, "\n"));
+        //cslDebug((70, "NV_NVDLA_rbk::ExtractDmaPayload, write to dma_fifo. mask A, num_free:%d, num_avail:%d\n",
+                    //dma_fifo->num_free(), dma_fifo->num_available()));
+        //for(int i=0;i<32;i++)
+            //cslDebug((70, "0x%02x \n", rdma_atom_cube_ptr[i]));
+        //cslDebug((70, "\n"));
     }
 
     // Handling upper 32 bytes
@@ -107,16 +107,16 @@ void NV_NVDLA_rbk::ExtractDmaPayload(sc_fifo <uint8_t *> *dma_fifo, nvdla_dma_rd
         rdma_atom_cube_ptr = new uint8_t[RUBIK_ATOM_CUBE_SIZE]; 
         memcpy(rdma_atom_cube_ptr, payload_data_ptr + RUBIK_ATOM_CUBE_SIZE, RUBIK_ATOM_CUBE_SIZE);
         dma_fifo->write(rdma_atom_cube_ptr);
-        cslDebug((70, "NV_NVDLA_rbk::ExtractDmaPayload, write to dma_fifo. mask B, num_free:%d, num_avail:%d\n",
-                    dma_fifo->num_free(), dma_fifo->num_available()));
-        for(int i=0;i<32;i++)
-            cslDebug((70, "0x%02x \n", rdma_atom_cube_ptr[i]));
-        cslDebug((70, "\n"));
+        //cslDebug((70, "NV_NVDLA_rbk::ExtractDmaPayload, write to dma_fifo. mask B, num_free:%d, num_avail:%d\n",
+                    //dma_fifo->num_free(), dma_fifo->num_available()));
+        //for(int i=0;i<32;i++)
+            //cslDebug((70, "0x%02x \n", rdma_atom_cube_ptr[i]));
+        //cslDebug((70, "\n"));
     }
 }
 
 void NV_NVDLA_rbk::mcif2rbk_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* payload, sc_core::sc_time& delay){
-    cslDebug((70, "NV_NVDLA_rbk::mcif2rbk_rd_rsp_b_transport, begin\n"));
+    //cslDebug((70, "NV_NVDLA_rbk::mcif2rbk_rd_rsp_b_transport, begin\n"));
     uint32_t rubik_mode;
 #pragma CTC SKIP
     if(rubik_config_wdma_ == NULL)  // In case of rd_rsp_b_transport is called before RubikWdmaSequenceThread is scheduled 
@@ -144,11 +144,11 @@ void NV_NVDLA_rbk::mcif2rbk_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* paylo
             break;
 #pragma CTC ENDSKIP
     }
-    cslDebug((70, "NV_NVDLA_rbk::mcif2rbk_rd_rsp_b_transport, end\n"));
+    //cslDebug((70, "NV_NVDLA_rbk::mcif2rbk_rd_rsp_b_transport, end\n"));
 }
 
 void NV_NVDLA_rbk::cvif2rbk_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* payload, sc_core::sc_time& delay){
-    cslDebug((70, "NV_NVDLA_rbk::cvif2rbk_rd_rsp_b_transport, begin\n"));
+    //cslDebug((70, "NV_NVDLA_rbk::cvif2rbk_rd_rsp_b_transport, begin\n"));
     uint32_t rubik_mode;
 #pragma CTC SKIP
     if(rubik_config_wdma_ == NULL)  // In case of rd_rsp_b_transport is called before RubikWdmaSequenceThread is scheduled 
@@ -176,7 +176,7 @@ void NV_NVDLA_rbk::cvif2rbk_rd_rsp_b_transport(int ID, nvdla_dma_rd_rsp_t* paylo
             break;
 #pragma CTC ENDSKIP
     }
-    cslDebug((70, "NV_NVDLA_rbk::cvif2rbk_rd_rsp_b_transport, end\n"));
+    //cslDebug((70, "NV_NVDLA_rbk::cvif2rbk_rd_rsp_b_transport, end\n"));
 }
 
 void NV_NVDLA_rbk::RbkIntrThread() {
@@ -188,14 +188,14 @@ void NV_NVDLA_rbk::RbkIntrThread() {
 
         if (ack->is_mc) {
             if (!is_mc_ack_done_) {
-                cslDebug((30, "%s: wait for mc_ack on group:%d\n", __FUNCTION__, ack->group_id));
+                //cslDebug((30, "%s: wait for mc_ack on group:%d\n", __FUNCTION__, ack->group_id));
                 wait(rbk_mc_ack_);
             }
 
             is_mc_ack_done_ = false;
         } else {
             if (!is_cv_ack_done_) {
-                cslDebug((30, "%s: wait for cv_ack on group:%d\n", __FUNCTION__, ack->group_id));
+                //cslDebug((30, "%s: wait for cv_ack on group:%d\n", __FUNCTION__, ack->group_id));
                 wait(rbk_cv_ack_);
             }
 
@@ -229,23 +229,23 @@ void NV_NVDLA_rbk::RubikConsumerThread() {
         while(RbkGetOpeartionEnable(rbk_register_group_0) != NVDLA_RBK_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_rbk_reg_group_0_operation_enable);
         }
-        cslDebug((50, "NV_NVDLA_rbk::RubikConsumerThread, group 0 opeartion start\n"));
+        //cslDebug((50, "NV_NVDLA_rbk::RubikConsumerThread, group 0 opeartion start\n"));
         rbk_reg_model::RbkUpdateWorkingStatus(0,1);
         RubikConfigEvaluation(rbk_register_group_0);
         RubikHardwareLayerExecutionTrigger();
         rbk_reg_model::RbkUpdateWorkingStatus(0,0);
-        cslDebug((50, "NV_NVDLA_rbk::RubikConsumerThread, group 0 opeartion done\n"));
+        //cslDebug((50, "NV_NVDLA_rbk::RubikConsumerThread, group 0 opeartion done\n"));
         rbk_reg_model::RbkClearOpeartionEnable(rbk_register_group_0);
 
         while(RbkGetOpeartionEnable(rbk_register_group_1) != NVDLA_RBK_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_rbk_reg_group_1_operation_enable);
         }
-        cslDebug((50, "NV_NVDLA_rbk::RubikConsumerThread, group 1 opeartion start\n"));
+        //cslDebug((50, "NV_NVDLA_rbk::RubikConsumerThread, group 1 opeartion start\n"));
         rbk_reg_model::RbkUpdateWorkingStatus(1,1);
         RubikConfigEvaluation(rbk_register_group_1);
         RubikHardwareLayerExecutionTrigger();
         rbk_reg_model::RbkUpdateWorkingStatus(1,0);
-        cslDebug((50, "NV_NVDLA_rbk::RubikConsumerThread, group 1 opeartion done\n"));
+        //cslDebug((50, "NV_NVDLA_rbk::RubikConsumerThread, group 1 opeartion done\n"));
         rbk_reg_model::RbkClearOpeartionEnable(rbk_register_group_1);
     }
 }
@@ -278,8 +278,8 @@ void NV_NVDLA_rbk::RubikRdmaSequenceThread() {
         rubik_config->rbk_deconv_x_stride_ = rbk_deconv_x_stride_;
         rubik_config->rbk_deconv_y_stride_ = rbk_deconv_y_stride_;
         rubik_config_fifo_r2d_->write(rubik_config);
-        cslDebug((30, "WxHxC=%dx%dx%d, precision:%d\n",
-                    rbk_datain_width_+1, rbk_datain_height_+1, rbk_datain_channel_+1, rbk_in_precision_));
+        //cslDebug((30, "WxHxC=%dx%dx%d, precision:%d\n",
+        //            rbk_datain_width_+1, rbk_datain_height_+1, rbk_datain_channel_+1, rbk_in_precision_));
         switch (rbk_rubik_mode_) {
             case NVDLA_RBK_D_MISC_CFG_0_RUBIK_MODE_CONTRACT:
                 RubikRdmaSequenceContract();
@@ -350,29 +350,29 @@ void NV_NVDLA_rbk::RubikRdmaSequenceContract() {
     surface_out_num = (cube_out_channel + element_per_atom - 1)/element_per_atom;
     // Output surface iteration
     for (surface_out_iter = 0; surface_out_iter < surface_out_num; surface_out_iter ++) {
-        cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, surface_out_iter:0x%x, surface_out_num:0x%x\n", surface_out_iter, surface_out_num));
+        //cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, surface_out_iter:0x%x, surface_out_num:0x%x\n", surface_out_iter, surface_out_num));
         // Input height iteration
         for (height_in_iter = 0; height_in_iter < cube_in_height; height_in_iter ++) {
-            cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, height_in_iter:0x%x, cube_in_height:0x%x\n", height_in_iter, cube_in_height));
+            //cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, height_in_iter:0x%x, cube_in_height:0x%x\n", height_in_iter, cube_in_height));
             // Stride Y iteration
             for (stride_y_iter = 0; stride_y_iter < stride_y; stride_y_iter ++) {
-                cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, stride_y_iter:0x%x, stride_y:0x%x\n", stride_y_iter, stride_y));
+                //cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, stride_y_iter:0x%x, stride_y:0x%x\n", stride_y_iter, stride_y));
                 // Input width iteration
                 width_in_iter = 0;
                 while (width_in_iter < cube_in_width) {
                     payload_atom_num= min ((cube_in_width - width_in_iter), uint32_t(8));
-                    cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, width_in_iter:0x%x, cube_in_width:0x%x, width_in_step:0x%x\n", width_in_iter, cube_in_width, payload_atom_num));
+                    //cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, width_in_iter:0x%x, cube_in_width:0x%x, width_in_step:0x%x\n", width_in_iter, cube_in_width, payload_atom_num));
                     // Stride X iteration
                     stride_x_iter = 0;
                     while (stride_x_iter < stride_x) {
                         stride_x_step = min ((stride_x - stride_x_iter), uint32_t(8));
-                        cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, stride_x_iter:0x%x, stride_x:0x%x, stride_x_step:0x%x\n", stride_x_iter, stride_x, stride_x_step));
+                        //cslDebug((70, "NV_NVDLA_rbk::RubikRdmaSequenceContract, stride_x_iter:0x%x, stride_x:0x%x, stride_x_step:0x%x\n", stride_x_iter, stride_x, stride_x_step));
                         for (surface_in_iter = 0; surface_in_iter < stride_x_step; surface_in_iter++) {
                             payload_addr    = src_base_addr + ( (stride_y_iter * stride_x + stride_x_iter + surface_in_iter) * surface_out_num + surface_out_iter) * src_surface_stride + height_in_iter * src_line_stride + width_in_iter*RUBIK_ATOM_CUBE_SIZE;
                             // Prepare payload
                             dma_rd_req_payload_->pd.dma_read_cmd.addr = payload_addr;
                             dma_rd_req_payload_->pd.dma_read_cmd.size = payload_atom_num-1;
-                            cslDebug((50, "%s wait for feature_cube_in_fifo_ > %d\n", __FUNCTION__, payload_atom_num));
+                            //cslDebug((50, "%s wait for feature_cube_in_fifo_ > %d\n", __FUNCTION__, payload_atom_num));
                             //WaitUntilFifoFreeSizeGreaterThan(feature_cube_in_fifo_, payload_atom_num);
                             // Send read request to RDMA
                             SendDmaReadRequest(dma_rd_req_payload_, dma_delay_);
@@ -407,8 +407,8 @@ void NV_NVDLA_rbk::RubikRdmaSequenceSplit(){
     src_base_addr       = uint64_t (rbk_dain_addr_high_) << 32 | uint64_t (rbk_dain_addr_low_) << 5;
     src_line_stride     = rbk_dain_line_stride_ << 5;
     src_surface_stride  = rbk_dain_surf_stride_ << 5;
-    cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceSplit: cube_width=0x%x cube_height=0x%x cube_channel=0x%x\n", cube_width, cube_height, cube_channel));
-    cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceSplit: src_line_stride=0x%x src_surface_stride=0x%x\n", src_line_stride, src_surface_stride));
+    //cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceSplit: cube_width=0x%x cube_height=0x%x cube_channel=0x%x\n", cube_width, cube_height, cube_channel));
+    //cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceSplit: src_line_stride=0x%x src_surface_stride=0x%x\n", src_line_stride, src_surface_stride));
     switch (precision) {
         case RUBIK_DATA_FORMAT_INT8:
             element_per_atom = RUBIK_ELEMENT_PER_ATOM_INT8;
@@ -429,22 +429,22 @@ void NV_NVDLA_rbk::RubikRdmaSequenceSplit(){
 #pragma CTC ENDSKIP
     }
     trans_size = (RUBIK_INTERNAL_BUF_SIZE)/(32);
-    cslDebug((50, "NV_NVDLA_rbk::RubikRdmaSequenceSplit, start\n"));
+    //cslDebug((50, "NV_NVDLA_rbk::RubikRdmaSequenceSplit, start\n"));
     surface_num = (cube_channel + element_per_atom - 1)/element_per_atom;
     for (surface_iter = 0; surface_iter < surface_num; surface_iter ++) {
         for (height_iter = 0; height_iter < cube_height; height_iter ++) {
             width_iter = 0;
             while (width_iter < cube_width) {
-                cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceSplit: width_iter=0x%x height_iter=0x%x surface_iter=0x%x\n", width_iter, height_iter, surface_iter));
+                //cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceSplit: width_iter=0x%x height_iter=0x%x surface_iter=0x%x\n", width_iter, height_iter, surface_iter));
                 payload_addr = src_base_addr + surface_iter * src_surface_stride + height_iter * src_line_stride + width_iter * RUBIK_ATOM_CUBE_SIZE;
                 payload_atom_num    = min (cube_width - width_iter, uint32_t(trans_size));
                 // payload_atom_num    = cube_width - width_iter;
                 // Prepare payload
                 dma_rd_req_payload_->pd.dma_read_cmd.addr = payload_addr;
                 dma_rd_req_payload_->pd.dma_read_cmd.size = payload_atom_num-1;
-                cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceSplit: payload_addr=0x%lx payload_atom_num=0x%x\n", payload_addr, payload_atom_num));
+                //cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceSplit: payload_addr=0x%lx payload_atom_num=0x%x\n", payload_addr, payload_atom_num));
                 // Check are there sufficient entries in feature_cube_in_fifo_ 
-                cslDebug((50, "%s wait for feature_cube_in_fifo_ > %d\n", __FUNCTION__, payload_atom_num));
+                //cslDebug((50, "%s wait for feature_cube_in_fifo_ > %d\n", __FUNCTION__, payload_atom_num));
                 //WaitUntilFifoFreeSizeGreaterThan(feature_cube_in_fifo_, payload_atom_num);
                 // Send read request to RDMA
                 SendDmaReadRequest(dma_rd_req_payload_, dma_delay_);
@@ -452,7 +452,7 @@ void NV_NVDLA_rbk::RubikRdmaSequenceSplit(){
             }
         }
     }
-    cslDebug((50, "NV_NVDLA_rbk::RubikRdmaSequenceSplit, end\n"));
+    //cslDebug((50, "NV_NVDLA_rbk::RubikRdmaSequenceSplit, end\n"));
 }
 
 void NV_NVDLA_rbk::RubikRdmaSequenceMerge() {
@@ -509,8 +509,8 @@ void NV_NVDLA_rbk::RubikRdmaSequenceMerge() {
             while (width_iter < cube_width) {
                 width_step      = min ((cube_width - width_iter), trans_size);
                 payload_size    = max (uint32_t(RUBIK_ATOM_CUBE_SIZE), width_step * element_byte_size);
-                cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceMerge: width_iter=0x%x height_iter=0x%x surface_iter=0x%x, width_step=0x%x\n",
-                            width_iter, height_iter, surface_iter, width_step));
+                //cslDebug((80, "NV_NVDLA_rbk::RubikRdmaSequenceMerge: width_iter=0x%x height_iter=0x%x surface_iter=0x%x, width_step=0x%x\n",
+                //            width_iter, height_iter, surface_iter, width_step));
                 payload_atom_num= (payload_size + RUBIK_ATOM_CUBE_SIZE-1)/RUBIK_ATOM_CUBE_SIZE;
                 for (channel_iter = 0; channel_iter < planar_num; channel_iter ++) {
                     payload_addr = src_base_addr + height_iter * src_line_stride +
@@ -519,9 +519,9 @@ void NV_NVDLA_rbk::RubikRdmaSequenceMerge() {
                     dma_rd_req_payload_->pd.dma_read_cmd.addr = payload_addr;
                     dma_rd_req_payload_->pd.dma_read_cmd.size = payload_atom_num-1;
                     // Check are there sufficient entries in feature_cube_in_fifo_ 
-                    cslDebug((50, "%s wait for feature_cube_in_fifo_ free slots > %d E\n", __FUNCTION__, payload_atom_num));
+                    //cslDebug((50, "%s wait for feature_cube_in_fifo_ free slots > %d E\n", __FUNCTION__, payload_atom_num));
                     //WaitUntilFifoFreeSizeGreaterThan(feature_cube_in_fifo_, payload_atom_num);
-                    cslDebug((50, "%s wait for feature_cube_in_fifo_ free slots > %d X\n", __FUNCTION__, payload_atom_num));
+                    //cslDebug((50, "%s wait for feature_cube_in_fifo_ free slots > %d X\n", __FUNCTION__, payload_atom_num));
                     // Send read request to RDMA
                     SendDmaReadRequest(dma_rd_req_payload_, dma_delay_);
                 }
@@ -602,41 +602,41 @@ void NV_NVDLA_rbk::RubikDataPathSequenceContract(){
     surface_out_num = (cube_out_channel + element_per_atom - 1)/element_per_atom;
     // Output surface iteration
     for (surface_out_iter = 0; surface_out_iter < surface_out_num; surface_out_iter ++) {
-        cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, surface_out_iter:0x%x, surface_out_num:0x%x\n", surface_out_iter, surface_out_num));
+        //cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, surface_out_iter:0x%x, surface_out_num:0x%x\n", surface_out_iter, surface_out_num));
         // Input height iteration
         for (height_in_iter = 0; height_in_iter < cube_in_height; height_in_iter ++) {
-            cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, height_in_iter:0x%x, cube_in_height:0x%x\n", height_in_iter, cube_in_height));
+            //cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, height_in_iter:0x%x, cube_in_height:0x%x\n", height_in_iter, cube_in_height));
             // Stride Y iteration
             for (stride_y_iter = 0; stride_y_iter < stride_y; stride_y_iter ++) {
-                cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, stride_y_iter:0x%x, stride_y:0x%x\n", stride_y_iter, stride_y));
+                //cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, stride_y_iter:0x%x, stride_y:0x%x\n", stride_y_iter, stride_y));
                 // Input lines from different cube shall be in the same line of output cube
                 // Input width iteration
                 width_in_iter = 0;
                 while (width_in_iter < cube_in_width) {
                     width_in_step   = min ((cube_in_width - width_in_iter), uint32_t(8));
-                    cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, width_in_iter:0x%x, cube_in_width:0x%x, width_in_step:0x%x\n", width_in_iter, cube_in_width, width_in_step));
+                    //cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, width_in_iter:0x%x, cube_in_width:0x%x, width_in_step:0x%x\n", width_in_iter, cube_in_width, width_in_step));
                     // Stride X iteration
                     stride_x_iter = 0;
                     while (stride_x_iter < stride_x) {
                         stride_x_step = min ((stride_x - stride_x_iter), uint32_t(8));
-                        cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, stride_x_iter:0x%x, stride_x:0x%x, stride_x_step:0x%x\n", stride_x_iter, stride_x, stride_x_step));
+                        //cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, stride_x_iter:0x%x, stride_x:0x%x, stride_x_step:0x%x\n", stride_x_iter, stride_x, stride_x_step));
                         for (surface_in_iter = 0; surface_in_iter < stride_x_step; surface_in_iter++) {
                             for (atom_iter=0; atom_iter<width_in_step; atom_iter++) {
                                 atom_ptr = feature_cube_in_fifo_->read();
-                                cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, data from feature_cube_in_fifo_ "));
-                                for(int i=0;i<RUBIK_ATOM_CUBE_SIZE;i++)
-                                    cslDebug((70, "0x%02x ", atom_ptr[i]));
-                                cslDebug((70, "\n"));
+                                //cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, data from feature_cube_in_fifo_ "));
+                                //for(int i=0;i<RUBIK_ATOM_CUBE_SIZE;i++)
+                                    //cslDebug((70, "0x%02x ", atom_ptr[i]));
+                                //cslDebug((70, "\n"));
                                 planar_fifo_[surface_in_iter].write(atom_ptr);
                             }
                         }
                         for (atom_iter=0; atom_iter<width_in_step; atom_iter++) {
                             for (surface_in_iter = 0; surface_in_iter < stride_x_step; surface_in_iter++) {
                                 atom_ptr = planar_fifo_[surface_in_iter].read();
-                                cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, data from planar_fifo_[0x%x] ", surface_in_iter));
-                                for(int i=0;i<RUBIK_ATOM_CUBE_SIZE;i++)
-                                    cslDebug((70, "0x%02x ", atom_ptr[i]));
-                                cslDebug((70, "\n"));
+                                //cslDebug((70, "NV_NVDLA_rbk::RubikDataPathSequenceContract, data from planar_fifo_[0x%x] ", surface_in_iter));
+                                //for(int i=0;i<RUBIK_ATOM_CUBE_SIZE;i++)
+                                    //cslDebug((70, "0x%02x ", atom_ptr[i]));
+                                //cslDebug((70, "\n"));
                                 feature_cube_out_fifo_->write(atom_ptr);
                             }
                         }
@@ -674,7 +674,7 @@ void NV_NVDLA_rbk::RubikWdmaSequenceThread() {
                 break;
 #pragma CTC ENDSKIP
         }
-        cslDebug((30, "Delete rubik_config_wdma\n"));
+        //cslDebug((30, "Delete rubik_config_wdma\n"));
         delete rubik_config_wdma_;
         rubik_config_wdma_ = NULL;
     }
@@ -737,30 +737,30 @@ void NV_NVDLA_rbk::RubikWdmaSequenceContract(){
     surface_out_num = (cube_out_channel + element_per_atom - 1)/element_per_atom;
     // Output surface iteration
     for (surface_out_iter = 0; surface_out_iter < surface_out_num; surface_out_iter ++) {
-        cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, surface_out_iter:0x%x, surface_out_num:0x%x\n", surface_out_iter, surface_out_num));
+        //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, surface_out_iter:0x%x, surface_out_num:0x%x\n", surface_out_iter, surface_out_num));
         // Input height iteration
         for (height_in_iter = 0; height_in_iter < cube_in_height; height_in_iter ++) {
-            cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, height_in_iter:0x%x, cube_in_height:0x%x\n", height_in_iter, cube_in_height));
+            //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, height_in_iter:0x%x, cube_in_height:0x%x\n", height_in_iter, cube_in_height));
             // Stride Y iteration
             for (stride_y_iter = 0; stride_y_iter < stride_y; stride_y_iter ++) {
-                cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, stride_y_iter:0x%x, stride_y:0x%x\n", stride_y_iter, stride_y));
+                //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, stride_y_iter:0x%x, stride_y:0x%x\n", stride_y_iter, stride_y));
                 if (stride_x > 8) {
                     // Stride_x is greater than 8, payload_atom_num shall be stride_x_partial * width_partial
                     // Input width iteration
                     width_in_iter = 0;
                     while (width_in_iter < cube_in_width) {
                         width_in_step   =   min ((cube_in_width - width_in_iter), uint32_t(8));
-                        cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, width_in_iter:0x%x, cube_in_width:0x%x, width_in_step:0x%x\n", width_in_iter, cube_in_width, width_in_step));
+                        //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, width_in_iter:0x%x, cube_in_width:0x%x, width_in_step:0x%x\n", width_in_iter, cube_in_width, width_in_step));
                         // Stride X iteration
                         stride_x_iter = 0;
                         while (stride_x_iter < stride_x) {
                             stride_x_step = min ((stride_x - stride_x_iter), uint32_t(8));
-                            cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, stride_x_iter:0x%x, stride_x:0x%x, stride_x_step:0x%x\n", stride_x_iter, stride_x, stride_x_step));
+                            //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, stride_x_iter:0x%x, stride_x:0x%x, stride_x_step:0x%x\n", stride_x_iter, stride_x, stride_x_step));
                             for (width_in_step_iter=0;width_in_step_iter<width_in_step;width_in_step_iter++) {
                                 payload_atom_num=   stride_x_step;
                                 payload_size    =   payload_atom_num*RUBIK_ATOM_CUBE_SIZE;
                                 payload_addr    =   dst_base_addr + stride_y_iter * dst_line_stride + height_in_iter * dst_super_line_stride + surface_out_iter * dst_surface_stride + (width_in_iter*stride_x + width_in_step_iter * stride_x + stride_x_iter)*RUBIK_ATOM_CUBE_SIZE;
-                                cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, payload_addr:0x%lx, payload_atom_num:0x%x\n", payload_addr, payload_atom_num));
+                                //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, payload_addr:0x%lx, payload_atom_num:0x%x\n", payload_addr, payload_atom_num));
                                 if ( (surface_out_iter+1 == surface_out_num) && (height_in_iter+1 == cube_in_height) && (stride_y_iter + 1 == stride_y) && (stride_x_iter + stride_x_step == stride_x) && (width_in_iter + width_in_step  == cube_in_width && width_in_step_iter + 1 == width_in_step) ) {
                                     is_required_ack = true;
                                 }
@@ -776,7 +776,7 @@ void NV_NVDLA_rbk::RubikWdmaSequenceContract(){
                     payload_size    = payload_atom_num*RUBIK_ATOM_CUBE_SIZE;
                     payload_addr    = dst_base_addr + height_in_iter * dst_super_line_stride + stride_y_iter * dst_line_stride + surface_out_iter * dst_surface_stride;
                     // Prepare Payload
-                    cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, payload_addr:0x%lx, payload_atom_num:0x%x\n", payload_addr, payload_atom_num));
+                    //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceContract, payload_addr:0x%lx, payload_atom_num:0x%x\n", payload_addr, payload_atom_num));
                     if ( (surface_out_iter+1 == surface_out_num) && (height_in_iter+1 == cube_in_height) && (stride_y_iter + 1 == stride_y) ) {
                         is_required_ack = true;
                     }
@@ -849,29 +849,29 @@ void NV_NVDLA_rbk::RubikWdmaSequenceSplit(){
             break;
 #pragma CTC ENDSKIP
     }
-    cslDebug((50, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, start\n"));
+    //cslDebug((50, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, start\n"));
     surface_num = (cube_channel + element_per_atom - 1)/element_per_atom;
     trans_size = (RUBIK_INTERNAL_BUF_SIZE)/(32);
     channel_stride_in_reorder_array = element_byte_size * trans_size;
     for (surface_iter = 0; surface_iter < surface_num; surface_iter ++) {
         planar_num = cube_channel - surface_iter*element_per_atom;
         planar_num = min(planar_num, element_per_atom);
-        cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, surface_iter:0x%x, surface_num:0x%x, planar_num:0x%x\n", surface_iter, surface_num, planar_num));
+        //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, surface_iter:0x%x, surface_num:0x%x, planar_num:0x%x\n", surface_iter, surface_num, planar_num));
         for (height_iter = 0; height_iter < cube_height; height_iter ++) {
-            cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, height_iter:0x%x, cube_height:0x%x\n", height_iter, cube_height));
+            //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, height_iter:0x%x, cube_height:0x%x\n", height_iter, cube_height));
             width_iter = 0;
             while (width_iter < cube_width) {
                 width_step      = min ((cube_width - width_iter), trans_size);
-                cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, width_iter:0x%x, cube_width:0x%x, width_step:0x%x\n", width_iter, cube_width, width_step));
+                //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, width_iter:0x%x, cube_width:0x%x, width_step:0x%x\n", width_iter, cube_width, width_step));
                 payload_size    = max (uint32_t(RUBIK_ATOM_CUBE_SIZE), width_step * element_byte_size);
                 payload_atom_num= (payload_size + RUBIK_ATOM_CUBE_SIZE-1)/RUBIK_ATOM_CUBE_SIZE;
                 memset(reorder_array_, 0, RUBIK_INTERNAL_BUF_SIZE);
                 for (reorder_iter=0; reorder_iter < width_step; reorder_iter++) {
                     feature_cube_atom_ptr = feature_cube_in_fifo_->read();
-                    cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, data from feature_cube_in_fifo_:"));
-                    for(int i=0;i<32;i++)
-                        cslDebug((70, "0x%02x ", feature_cube_atom_ptr[i]));
-                    cslDebug((70, "\n"));
+                    //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, data from feature_cube_in_fifo_:"));
+                    //for(int i=0;i<32;i++)
+                        //cslDebug((70, "0x%02x ", feature_cube_atom_ptr[i]));
+                    //cslDebug((70, "\n"));
                     for (channel_iter = 0; channel_iter < planar_num; channel_iter ++) {
                         // int index = channel_iter * payload_size + reorder_iter*element_byte_size;
                         int index = channel_iter * channel_stride_in_reorder_array + reorder_iter*element_byte_size;
@@ -882,13 +882,13 @@ void NV_NVDLA_rbk::RubikWdmaSequenceSplit(){
                     }
                     delete [] feature_cube_atom_ptr;
                 }
-                cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, data in reorder_array_:"));
-                for(int i=0;i<RUBIK_ATOM_CUBE_SIZE*RUBIK_ELEMENT_PER_ATOM_INT8;i++)
-                    cslDebug((70, "0x%02x ", reorder_array_[i]));
-                cslDebug((70, "\n"));
+                //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, data in reorder_array_:"));
+                //for(int i=0;i<RUBIK_ATOM_CUBE_SIZE*RUBIK_ELEMENT_PER_ATOM_INT8;i++)
+                    //cslDebug((70, "0x%02x ", reorder_array_[i]));
+                //cslDebug((70, "\n"));
                 // Send out write transactions plane by plane
                 for (channel_iter = 0; channel_iter < planar_num; channel_iter ++) {
-                    cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, channel_iter:0x%x, planar_num:0x%x\n", channel_iter, planar_num));
+                    //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, channel_iter:0x%x, planar_num:0x%x\n", channel_iter, planar_num));
                     // Copy data from reorder_array to planar fifos
                     for (payload_atom_iter=0; payload_atom_iter<payload_atom_num;payload_atom_iter++) {
                         // int index = channel_iter*payload_size + payload_atom_iter*RUBIK_ATOM_CUBE_SIZE;
@@ -906,14 +906,14 @@ void NV_NVDLA_rbk::RubikWdmaSequenceSplit(){
                         is_required_ack = true;
                     }
                     // Send data to planar_fifo_
-                    cslDebug((80, "NV_NVDLA_rbk::RubikWdmaSequenceSplit: payload_addr=0x%lx payload_atom_num=0x%x is_required_ack=0x%x\n", payload_addr, payload_atom_num, is_required_ack));
+                    //cslDebug((80, "NV_NVDLA_rbk::RubikWdmaSequenceSplit: payload_addr=0x%lx payload_atom_num=0x%x is_required_ack=0x%x\n", payload_addr, payload_atom_num, is_required_ack));
                     SendDmaWriteRequest(&planar_fifo_[channel_iter], payload_addr, payload_size, payload_atom_num, is_required_ack);
                 }
                 width_iter += width_step;
             }
         }
     }
-    cslDebug((50, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, end\n"));
+    //cslDebug((50, "NV_NVDLA_rbk::RubikWdmaSequenceSplit, end\n"));
 }
 
 void NV_NVDLA_rbk::RubikWdmaSequenceMerge(){
@@ -946,7 +946,7 @@ void NV_NVDLA_rbk::RubikWdmaSequenceMerge(){
     dst_base_addr       = ((uint64_t)rubik_config_wdma_->rbk_daout_addr_high_) << 32 | uint64_t (rubik_config_wdma_->rbk_daout_addr_low_) << 5;
     dst_line_stride     = rubik_config_wdma_->rbk_daout_line_stride_ << 5;
     dst_surf_stride     = rubik_config_wdma_->rbk_daout_surf_stride_ << 5;
-    cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceMerge, dst_line_stride:0x%x, dst_surf_stride:0x%x\n", dst_line_stride, dst_surf_stride));
+    //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceMerge, dst_line_stride:0x%x, dst_surf_stride:0x%x\n", dst_line_stride, dst_surf_stride));
     switch (precision) {
         case RUBIK_DATA_FORMAT_INT8:
             element_per_atom = RUBIK_ELEMENT_PER_ATOM_INT8;
@@ -971,20 +971,20 @@ void NV_NVDLA_rbk::RubikWdmaSequenceMerge(){
     for (surface_iter = 0; surface_iter < surface_num; surface_iter ++) {
         planar_num = cube_channel - surface_iter*element_per_atom;
         planar_num = planar_num > element_per_atom ? element_per_atom : planar_num;
-        cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceMerge, surface_iter:0x%x, surface_num:0x%x\n", surface_iter, surface_num));
+        //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceMerge, surface_iter:0x%x, surface_num:0x%x\n", surface_iter, surface_num));
         for (height_iter = 0; height_iter < cube_height; height_iter ++) {
-            cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceMerge, height_iter:0x%x, cube_height:0x%x\n", height_iter, cube_height));
+            //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceMerge, height_iter:0x%x, cube_height:0x%x\n", height_iter, cube_height));
             width_iter = 0;
             while (width_iter < cube_width) {
                 width_step      = min ((cube_width - width_iter), trans_size);
                 memset(reorder_array_, 0, RUBIK_INTERNAL_BUF_SIZE);
-                cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceMerge, width_iter:0x%x, cube_width:0x%x, width_step:0x%x\n", width_iter, cube_width, width_step));
+                //cslDebug((70, "NV_NVDLA_rbk::RubikWdmaSequenceMerge, width_iter:0x%x, cube_width:0x%x, width_step:0x%x\n", width_iter, cube_width, width_step));
                 for (channel_iter = 0; channel_iter < planar_num; channel_iter ++) {
                     // Read a planar atom from rdma buffer
                     for(atom_num_iter = 0; atom_num_iter < (width_step*element_byte_size + RUBIK_ATOM_CUBE_SIZE -1 )/RUBIK_ATOM_CUBE_SIZE; atom_num_iter++) {
-                        cslDebug((50, "%s read from feature_cube_in_fifo_ E\n", __FUNCTION__));
+                        //cslDebug((50, "%s read from feature_cube_in_fifo_ E\n", __FUNCTION__));
                         planar_atom_ptr = feature_cube_in_fifo_->read();
-                        cslDebug((50, "%s read from feature_cube_in_fifo_ X\n", __FUNCTION__));
+                        //cslDebug((50, "%s read from feature_cube_in_fifo_ X\n", __FUNCTION__));
                         for (atom_iter=0; atom_iter < RUBIK_ATOM_CUBE_SIZE/element_byte_size; atom_iter++) {
                             int index = (atom_iter + atom_num_iter*element_per_atom) * RUBIK_ATOM_CUBE_SIZE + channel_iter * element_byte_size;
 #pragma CTC SKIP
@@ -995,7 +995,7 @@ void NV_NVDLA_rbk::RubikWdmaSequenceMerge(){
                         delete [] planar_atom_ptr;
                     }
                 }
-                cslDebug((50, "%s reorder done\n", __FUNCTION__));
+                //cslDebug((50, "%s reorder done\n", __FUNCTION__));
                 // Send out write transactions atom by atom
                 // payload_atom_num= min ((cube_width - width_iter), uint32_t(RUBIK_ATOM_CUBE_SIZE/element_byte_size));
                 payload_atom_num= width_step;
@@ -1004,17 +1004,17 @@ void NV_NVDLA_rbk::RubikWdmaSequenceMerge(){
                 for (atom_iter=0; atom_iter < width_step; atom_iter++) {
                     feature_cube_atom_ptr = new uint8_t[RUBIK_ATOM_CUBE_SIZE];
                     memcpy(feature_cube_atom_ptr, &reorder_array_[atom_iter * RUBIK_ATOM_CUBE_SIZE], RUBIK_ATOM_CUBE_SIZE);
-                    cslDebug((50, "%s write to feature_cube_out_fifo_ E\n", __FUNCTION__));
+                    //cslDebug((50, "%s write to feature_cube_out_fifo_ E\n", __FUNCTION__));
                     // Send out write transactions atom by atom
                     feature_cube_out_fifo_->write(feature_cube_atom_ptr);
-                    cslDebug((50, "%s write to feature_cube_out_fifo_ X\n", __FUNCTION__));
+                    //cslDebug((50, "%s write to feature_cube_out_fifo_ X\n", __FUNCTION__));
                 }
                 payload_addr     = dst_base_addr + height_iter * dst_line_stride + surface_iter * dst_surf_stride + width_iter * RUBIK_ATOM_CUBE_SIZE;
                 // Prepare Payload
                 if ( ((surface_iter+1) == surface_num) && ((height_iter+1) == cube_height) && ((width_iter+payload_atom_num) == cube_width) ) {
                     is_required_ack = true;
                 }
-                cslDebug((80, "NV_NVDLA_rbk::RubikWdmaSequenceMerge: payload_addr=0x%lx payload_atom_num=0x%x is_required_ack=0x%x\n", payload_addr, payload_atom_num, is_required_ack));
+                //cslDebug((80, "NV_NVDLA_rbk::RubikWdmaSequenceMerge: payload_addr=0x%lx payload_atom_num=0x%x is_required_ack=0x%x\n", payload_addr, payload_atom_num, is_required_ack));
                 SendDmaWriteRequest(feature_cube_out_fifo_, payload_addr, payload_size, payload_atom_num, is_required_ack);
                 width_iter += width_step;
             }
@@ -1038,7 +1038,7 @@ void NV_NVDLA_rbk::WaitUntilFifoAvailableSizeGreaterThan(sc_fifo <uint8_t *> *da
 
 // Send DMA read request
 void NV_NVDLA_rbk::SendDmaReadRequest(nvdla_dma_rd_req_t* payload, sc_time& delay) {
-    cslDebug((50, "NV_NVDLA_rbk::SendDmaReadRequest: payload_addr=0x%lx payload_atom_num=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size+1));
+    //cslDebug((50, "NV_NVDLA_rbk::SendDmaReadRequest: payload_addr=0x%lx payload_atom_num=0x%x\n", payload->pd.dma_read_cmd.addr, payload->pd.dma_read_cmd.size+1));
     if (NVDLA_RBK_D_DAIN_RAM_TYPE_0_DATAIN_RAM_TYPE_MCIF == rbk_datain_ram_type_) {
         rbk2mcif_rd_req_b_transport(payload, dma_delay_);
     } else {
@@ -1060,12 +1060,12 @@ void NV_NVDLA_rbk::SendDmaWriteRequest(sc_fifo <uint8_t *> *wdma_fifo, uint64_t
     // cslDebug((50, "%s wait for fifo > %d X\n", __FUNCTION__, payload_atom_num));
     // Send write command
     SendDmaWriteRequest(dma_wr_req_cmd_payload_, dma_delay_, ack_required);
-    cslDebug((50, "NV_NVDLA_rbk::SendDmaWriteRequest: payload_addr=0x%lx payload_atom_num=0x%x, begin\n", payload_addr, payload_atom_num));
+    //cslDebug((50, "NV_NVDLA_rbk::SendDmaWriteRequest: payload_addr=0x%lx payload_atom_num=0x%x, begin\n", payload_addr, payload_atom_num));
     for (atom_iter = 0; atom_iter < payload_atom_num; atom_iter++) {
         dma_write_data_ptr = wdma_fifo->read();
-        cslDebug((70, "NV_NVDLA_rbk::SendDmaWriteRequest, read from wdma_fifo\n"));
-        for(int i=0;i<32;i++)
-            cslDebug((70, "0x%02x ", dma_write_data_ptr[i]));
+        //cslDebug((70, "NV_NVDLA_rbk::SendDmaWriteRequest, read from wdma_fifo\n"));
+        //for(int i=0;i<32;i++)
+            //cslDebug((70, "0x%02x ", dma_write_data_ptr[i]));
         cslDebug((70, "\n"));
         memcpy (&payload_data_ptr[RUBIK_ATOM_CUBE_SIZE*(atom_iter%2)], dma_write_data_ptr, RUBIK_ATOM_CUBE_SIZE);
         delete[] dma_write_data_ptr;
@@ -1083,7 +1083,7 @@ void NV_NVDLA_rbk::SendDmaWriteRequest(sc_fifo <uint8_t *> *wdma_fifo, uint64_t
     
     if (ack_required) rbk_done_.notify();
 
-    cslDebug((50, "NV_NVDLA_rbk::SendDmaWriteRequest: payload_addr=0x%lx payload_atom_num=0x%x, end\n", payload_addr, payload_atom_num));
+    //cslDebug((50, "NV_NVDLA_rbk::SendDmaWriteRequest: payload_addr=0x%lx payload_atom_num=0x%x, end\n", payload_addr, payload_atom_num));
 }
 
 void NV_NVDLA_rbk::SendDmaWriteRequest(nvdla_dma_wr_req_t* payload, sc_time& delay, bool ack_required) {
@@ -1111,35 +1111,35 @@ void NV_NVDLA_rbk::SendDmaWriteRequest(nvdla_dma_wr_req_t* payload, sc_time& del
         rbk_ack_info *ack = new rbk_ack_info;
         ack->is_mc = rubik_config_wdma_->rbk_dataout_ram_type_ == NVDLA_RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_MCIF;
         ack->group_id = rbk_consumer_;
-        cslDebug((30, "%s: DMA transaction with ack is fired, is_mc:%d, group_id:%d\n", __FUNCTION__, ack->is_mc, ack->group_id));
+        //cslDebug((30, "%s: DMA transaction with ack is fired, is_mc:%d, group_id:%d\n", __FUNCTION__, ack->is_mc, ack->group_id));
         rbk_ack_fifo_->write(ack);
         //rbk_done_.notify();
     }
 }
 
 void NV_NVDLA_rbk::WriteResponseThreadMc() {
-    cslDebug((50, "NV_NVDLA_rbk::WriteResponseThreadMc is called\n"));
+    //cslDebug((50, "NV_NVDLA_rbk::WriteResponseThreadMc is called\n"));
     if ( true == mcif2rbk_wr_rsp.read() ) {
 #if 0
         if (NVDLA_RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_MCIF != rbk_dataout_ram_type_) {
             FAIL(("NV_NVDLA_rbk::WriteResponseThreadMc, dst config is not MC"));
         }
 #endif
-        cslDebug((50, "mcif2rbk_wr_rsp.read returns true\n"));
+        //cslDebug((50, "mcif2rbk_wr_rsp.read returns true\n"));
         is_mc_ack_done_ = true;
         rbk_mc_ack_.notify();
     }
 }
 
 void NV_NVDLA_rbk::WriteResponseThreadCv() {
-    cslDebug((50, "NV_NVDLA_rbk::WriteResponseThreadCv is called\n"));
+    //cslDebug((50, "NV_NVDLA_rbk::WriteResponseThreadCv is called\n"));
     if ( true == cvif2rbk_wr_rsp.read() ) {
 #if 0
         if (NVDLA_RBK_D_DAOUT_RAM_TYPE_0_DATAOUT_RAM_TYPE_CVIF != rbk_dataout_ram_type_) {
             FAIL(("NV_NVDLA_rbk::WriteResponseThreadCv, dst config is not CV"));
         }
 #endif
-        cslDebug((50, "cvif2rbk_wr_rsp.read returns true\n"));
+        //cslDebug((50, "cvif2rbk_wr_rsp.read returns true\n"));
         is_cv_ack_done_ = true;
         rbk_cv_ack_.notify();
     }
diff --git a/cmod/rubik/gen/rbk_reg_model.cpp b/cmod/rubik/gen/rbk_reg_model.cpp
index 12bd3d3..1578af6 100644
--- a/cmod/rubik/gen/rbk_reg_model.cpp
+++ b/cmod/rubik/gen/rbk_reg_model.cpp
@@ -85,7 +85,7 @@ bool rbk_reg_model::RbkAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 rbk_register_group_0->SetWritable(offset, data);
                 if (rbk_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_rbk_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "rbk_reg_model::RbkAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "rbk_reg_model::RbkAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -97,7 +97,7 @@ bool rbk_reg_model::RbkAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 rbk_register_group_1->SetWritable(offset, data);
                 if (rbk_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_rbk_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "rbk_reg_model::RbkAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "rbk_reg_model::RbkAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/sdp/NV_NVDLA_sdp.cpp b/cmod/sdp/NV_NVDLA_sdp.cpp
index 23de4db..3ef6ca2 100644
--- a/cmod/sdp/NV_NVDLA_sdp.cpp
+++ b/cmod/sdp/NV_NVDLA_sdp.cpp
@@ -158,34 +158,34 @@ void NV_NVDLA_sdp::SdpRdmaConsumerThread() {
         while(SdpRdmaGetOpeartionEnable(sdp_rdma_register_group_0) != NVDLA_SDP_RDMA_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_sdp_rdma_reg_group_0_operation_enable);
         }
-        cslInfo(( "NV_NVDLA_sdp::SdpRdmaConsumerThread, group 0 opeartion start\n"));
+        //cslInfo(( "NV_NVDLA_sdp::SdpRdmaConsumerThread, group 0 opeartion start\n"));
         sdp_rdma_reg_model::SdpRdmaUpdateWorkingStatus(0,1);
         sdp_rdma_reg_model::SdpRdmaUpdateVariables(sdp_rdma_register_group_0);
 #pragma CTC SKIP
-        cslInfo(( "group0: %s: WxHxC=%dx%dx%d, M:%d, B:%d, N:%d, E:%d\n",
-                    __FUNCTION__, sdp_width_+1, sdp_height_+1, sdp_channel_+1,
-                    !sdp_rdma_flying_mode_, !sdp_rdma_brdma_disable_, !sdp_rdma_nrdma_disable_, !sdp_rdma_erdma_disable_));
+        //cslInfo(( "group0: %s: WxHxC=%dx%dx%d, M:%d, B:%d, N:%d, E:%d\n",
+        //            __FUNCTION__, sdp_width_+1, sdp_height_+1, sdp_channel_+1,
+        //            !sdp_rdma_flying_mode_, !sdp_rdma_brdma_disable_, !sdp_rdma_nrdma_disable_, !sdp_rdma_erdma_disable_));
 #pragma CTC ENDSKIP
         SdpRdmaHardwareLayerExecutionTrigger();
         sdp_rdma_reg_model::SdpRdmaUpdateWorkingStatus(0,0);
         sdp_rdma_reg_model::SdpRdmaClearOpeartionEnable(sdp_rdma_register_group_0);
-        cslInfo(("NV_NVDLA_sdp::SdpRdmaConsumerThread, group 0 opeartion done\n"));
+        //cslInfo(("NV_NVDLA_sdp::SdpRdmaConsumerThread, group 0 opeartion done\n"));
 
         while(SdpRdmaGetOpeartionEnable(sdp_rdma_register_group_1) != NVDLA_SDP_RDMA_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_sdp_rdma_reg_group_1_operation_enable);
         }
-        cslInfo(( "NV_NVDLA_sdp::SdpRdmaConsumerThread, group 1 opeartion start\n"));
+        //cslInfo(( "NV_NVDLA_sdp::SdpRdmaConsumerThread, group 1 opeartion start\n"));
         sdp_rdma_reg_model::SdpRdmaUpdateWorkingStatus(1,1);
         sdp_rdma_reg_model::SdpRdmaUpdateVariables(sdp_rdma_register_group_1);
 #pragma CTC SKIP
-        cslInfo(( "group1: %s: WxHxC=%dx%dx%d, M:%d, B:%d, N:%d, E:%d\n",
-                    __FUNCTION__, sdp_width_+1, sdp_height_+1, sdp_channel_+1,
-                    !sdp_rdma_flying_mode_, !sdp_rdma_brdma_disable_, !sdp_rdma_nrdma_disable_, !sdp_rdma_erdma_disable_));
+        //cslInfo(( "group1: %s: WxHxC=%dx%dx%d, M:%d, B:%d, N:%d, E:%d\n",
+        //            __FUNCTION__, sdp_width_+1, sdp_height_+1, sdp_channel_+1,
+        //            !sdp_rdma_flying_mode_, !sdp_rdma_brdma_disable_, !sdp_rdma_nrdma_disable_, !sdp_rdma_erdma_disable_));
 #pragma CTC ENDSKIP
         SdpRdmaHardwareLayerExecutionTrigger();
         sdp_rdma_reg_model::SdpRdmaUpdateWorkingStatus(1,0);
         sdp_rdma_reg_model::SdpRdmaClearOpeartionEnable(sdp_rdma_register_group_1);
-        cslInfo(( "NV_NVDLA_sdp::SdpRdmaConsumerThread, group 1 opeartion done\n"));
+        //cslInfo(( "NV_NVDLA_sdp::SdpRdmaConsumerThread, group 1 opeartion done\n"));
     }
 #pragma CTC SKIP
 }
@@ -196,24 +196,24 @@ void NV_NVDLA_sdp::SdpConsumerThread() {
         while(SdpGetOpeartionEnable(sdp_register_group_0) != NVDLA_SDP_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_sdp_reg_group_0_operation_enable);
         }
-        cslInfo(( "NV_NVDLA_sdp::SdpConsumerThread, group 0 opeartion start\n"));
+        //cslInfo(( "NV_NVDLA_sdp::SdpConsumerThread, group 0 opeartion start\n"));
         sdp_reg_model::SdpUpdateWorkingStatus(0,1);
         sdp_reg_model::SdpUpdateVariables(sdp_register_group_0);
         SdpHardwareLayerExecutionTrigger();
         sdp_reg_model::SdpUpdateWorkingStatus(0,0);
         sdp_reg_model::SdpClearOpeartionEnable(sdp_register_group_0);
-        cslInfo(( "NV_NVDLA_sdp::SdpConsumerThread, group 0 opeartion done\n"));
+        //cslInfo(( "NV_NVDLA_sdp::SdpConsumerThread, group 0 opeartion done\n"));
 
         while(SdpGetOpeartionEnable(sdp_register_group_1) != NVDLA_SDP_D_OP_ENABLE_0_OP_EN_ENABLE) {
             wait(event_sdp_reg_group_1_operation_enable);
         }
-        cslInfo(( "NV_NVDLA_sdp::SdpConsumerThread, group 1 opeartion start\n"));
+        //cslInfo(( "NV_NVDLA_sdp::SdpConsumerThread, group 1 opeartion start\n"));
         sdp_reg_model::SdpUpdateWorkingStatus(1,1);
         sdp_reg_model::SdpUpdateVariables(sdp_register_group_1);
         SdpHardwareLayerExecutionTrigger();
         sdp_reg_model::SdpUpdateWorkingStatus(1,0);
         sdp_reg_model::SdpClearOpeartionEnable(sdp_register_group_1);
-        cslInfo(( "NV_NVDLA_sdp::SdpConsumerThread, group 1 opeartion done\n"));
+        //cslInfo(( "NV_NVDLA_sdp::SdpConsumerThread, group 1 opeartion done\n"));
     }
 #pragma CTC SKIP
 }
@@ -243,7 +243,7 @@ void NV_NVDLA_sdp::SdpIntrThread() {
         }
 
         wait(1, SC_NS);
-        cslInfo(( "%s: trigger interrupt on %d group\n", __FUNCTION__, (uint32_t)ack->group_id));
+        //cslInfo(( "%s: trigger interrupt on %d group\n", __FUNCTION__, (uint32_t)ack->group_id));
         sdp2glb_done_intr[ack->group_id].write(true);
 
         delete ack;
@@ -257,7 +257,7 @@ void NV_NVDLA_sdp::SdpRdmaHardwareLayerExecutionTrigger () {
     SdpConfig *cfg;
     sdp_rdma_kickoff_.notify();
 
-    cslInfo(( "%s invoked\n", __FUNCTION__));
+    //cslInfo(( "%s invoked\n", __FUNCTION__));
     cfg = new SdpConfig;
     cfg->sdp_rdma_brdma_data_mode_ = sdp_rdma_brdma_data_mode_;
     cfg->sdp_rdma_nrdma_data_mode_ = sdp_rdma_nrdma_data_mode_;
@@ -266,14 +266,14 @@ void NV_NVDLA_sdp::SdpRdmaHardwareLayerExecutionTrigger () {
 
 
     wait(sdp_rdma_done_ & sdp_b_rdma_done_ & sdp_n_rdma_done_ & sdp_e_rdma_done_);
-    cslInfo(( "sdp rdma HWL done\n"));
+    //cslInfo(( "sdp rdma HWL done\n"));
 }
 
 void NV_NVDLA_sdp::SdpHardwareLayerExecutionTrigger () {
     sdp_kickoff_.notify();
-    cslInfo(( "sdp before wait sdp_done_\n"));
+    //cslInfo(( "sdp before wait sdp_done_\n"));
     wait(sdp_done_);
-    cslInfo(( "sdp after wait sdp_done_\n"));
+    //cslInfo(( "sdp after wait sdp_done_\n"));
 }
 
 void NV_NVDLA_sdp::SdpRdmaCore( te_rdma_type eRdDma ) {
@@ -383,8 +383,8 @@ void NV_NVDLA_sdp::SdpRdmaCore( te_rdma_type eRdDma ) {
     }
     bytes_per_element = component_per_element * bytes_per_component;
 #pragma CTC SKIP
-    cslDebug((30, "rdma:%d, enabled:%d, addr:%lx, line_stride:%d, surf_stride:%d, data_mode:%d\n",
-                eRdDma, enabled, src_base_addr, line_stride, surf_stride, data_mode));
+    //cslDebug((30, "rdma:%d, enabled:%d, addr:%lx, line_stride:%d, surf_stride:%d, data_mode:%d\n",
+    //            eRdDma, enabled, src_base_addr, line_stride, surf_stride, data_mode));
 #pragma CTC ENDSKIP
 
     if (enabled) {
@@ -422,7 +422,7 @@ void NV_NVDLA_sdp::SdpRdmaCore( te_rdma_type eRdDma ) {
         // argument check end;
         if (is_int16_to_int8 == true) {
             surf_num = ((surf_num+1)/2) * 2;
-            cslDebug((30, "int16->int8, adjust surf_num as:%d\n", surf_num));
+            //cslDebug((30, "int16->int8, adjust surf_num as:%d\n", surf_num));
         }
         rdma_atom_recieved_[eRdDma] = 0;
         if (data_mode == NVDLA_SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PER_KERNEL) {
@@ -438,14 +438,14 @@ void NV_NVDLA_sdp::SdpRdmaCore( te_rdma_type eRdDma ) {
         }
         cslAssert(payload_size%32 == 0);
         rdma_atom_total_[eRdDma] = payload_size/32;
-        cslDebug((30, "rdma:%d, total payload:%d\n", eRdDma, rdma_atom_total_[eRdDma]));
+        //cslDebug((30, "rdma:%d, total payload:%d\n", eRdDma, rdma_atom_total_[eRdDma]));
 
 
-        cslDebug((30, "%s: DMA:%d port enabled, WxHxC=%dx%dx%d\n", __FUNCTION__, eRdDma, cube_width, cube_height, cube_channel));
-        cslDebug((30, "\t: line_stride=%d, surfac_stride:%d\n", line_stride, surf_stride));
-        cslDebug((30, "\t: surf_num         =%d\n", surf_num));
-        cslDebug((30, "\t: batch_num        =%d\n", batch_num));
-        cslDebug((30, "\t: bytes_per_element=%d\n", bytes_per_element));
+        //cslDebug((30, "%s: DMA:%d port enabled, WxHxC=%dx%dx%d\n", __FUNCTION__, eRdDma, cube_width, cube_height, cube_channel));
+        //cslDebug((30, "\t: line_stride=%d, surfac_stride:%d\n", line_stride, surf_stride));
+        //cslDebug((30, "\t: surf_num         =%d\n", surf_num));
+        //cslDebug((30, "\t: batch_num        =%d\n", batch_num));
+        //cslDebug((30, "\t: bytes_per_element=%d\n", bytes_per_element));
 
         if (data_mode == NVDLA_SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PER_KERNEL) {
             int batch_count;
@@ -468,7 +468,7 @@ void NV_NVDLA_sdp::SdpRdmaCore( te_rdma_type eRdDma ) {
 
                 // Send DMA Read request for entire channel wise cube
                 payload_addr     = src_base_addr;
-                cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest for per channel payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
+                //cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest for per channel payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
                 payload->pd.dma_read_cmd.addr = payload_addr;
                 payload->pd.dma_read_cmd.size = payload_atom_num - 1;
                 // WaitUntilRdmaFifoFreeSizeGreaterThan(payload_atom_num);
@@ -490,7 +490,7 @@ void NV_NVDLA_sdp::SdpRdmaCore( te_rdma_type eRdDma ) {
                                 payload_addr     = src_base_addr + surf_iter * surf_stride +
                                     (line_iter + trans_iter) * line_stride +
                                     col_iter * bytes_per_element * element_per_group_src;
-                                cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
+                                //cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
                                 payload->pd.dma_read_cmd.addr = payload_addr;
                                 payload->pd.dma_read_cmd.size = payload_atom_num - 1;
                                 // WaitUntilRdmaFifoFreeSizeGreaterThan(payload_atom_num);
@@ -522,7 +522,7 @@ void NV_NVDLA_sdp::SdpRdmaCore( te_rdma_type eRdDma ) {
 
                             // Send DMA Read request for each line
                             payload_addr     = src_base_addr + surf_iter * surf_stride + line_iter * line_stride;
-                            cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
+                            //cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
                             payload->pd.dma_read_cmd.addr = payload_addr;
                             payload->pd.dma_read_cmd.size = payload_atom_num - 1;
                             // WaitUntilRdmaFifoFreeSizeGreaterThan(payload_atom_num);
@@ -548,7 +548,7 @@ void NV_NVDLA_sdp::SdpRdmaCore( te_rdma_type eRdDma ) {
                                     (surf_iter + surf_internal_iter) * surf_stride +
                                     line_iter * line_stride +
                                     width_iter * element_per_group_src * bytes_per_element;
-                                cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
+                                //cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
                                 payload->pd.dma_read_cmd.addr = payload_addr;
                                 payload->pd.dma_read_cmd.size = payload_atom_num - 1;
                                 // WaitUntilRdmaFifoFreeSizeGreaterThan(payload_atom_num);
@@ -566,7 +566,7 @@ void NV_NVDLA_sdp::SdpRdmaCore( te_rdma_type eRdDma ) {
 
                         // Send DMA Read request for each line
                         payload_addr     = src_base_addr + surf_iter * surf_stride + line_iter * line_stride;
-                        cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
+                        //cslDebug((50, "SdpRdmaSequence_%d SendDmaReadRequest payload_addr=0x%lx payload_atom_num=0x%x\n", eRdDma, payload_addr, payload_atom_num));
                         payload->pd.dma_read_cmd.addr = payload_addr;
                         payload->pd.dma_read_cmd.size = payload_atom_num - 1;
                         // WaitUntilRdmaFifoFreeSizeGreaterThan(payload_atom_num);
@@ -602,7 +602,7 @@ void NV_NVDLA_sdp::SdpBRdmaThread () {
     while (true) {
         wait(sdp_rdma_kickoff_);
         SdpRdmaCore(SDP_RDMA_X1_INPUT);
-        cslDebug((30, "BRDMA done\n"));
+        //cslDebug((30, "BRDMA done\n"));
     }
 #pragma CTC SKIP
 }
@@ -614,7 +614,7 @@ void NV_NVDLA_sdp::SdpNRdmaThread () {
     while (true) {
         wait(sdp_rdma_kickoff_);
         SdpRdmaCore(SDP_RDMA_X2_INPUT);
-        cslDebug((30, "NRDMA done\n"));
+        //cslDebug((30, "NRDMA done\n"));
     }
 #pragma CTC SKIP
 }
@@ -626,7 +626,7 @@ void NV_NVDLA_sdp::SdpERdmaThread () {
     while (true) {
         wait(sdp_rdma_kickoff_);
         SdpRdmaCore(SDP_RDMA_Y_INPUT);
-        cslDebug((30, "ERDMA done\n"));
+        //cslDebug((30, "ERDMA done\n"));
     }
 #pragma CTC SKIP
 }
@@ -637,7 +637,7 @@ void NV_NVDLA_sdp::SdpRdmaThread () {
         wait(sdp_rdma_kickoff_);
         // Send out done
         SdpRdmaCore(SDP_RDMA_INPUT);
-        cslDebug((30, "MRDMA done\n"));
+        //cslDebug((30, "MRDMA done\n"));
     }
 #pragma CTC SKIP
 }
@@ -727,9 +727,9 @@ void NV_NVDLA_sdp::SdpLoadPerChannelData(uint32_t proc_num) {
             sdp_bs_alu_src_ == NVDLA_SDP_D_DP_BS_ALU_CFG_BS_ALU_SRC_MEM &&
             sdp_cfg_.sdp_rdma_brdma_data_mode_ == NVDLA_SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_PER_KERNEL ) {
         for( i = 0; i < proc_num; i++) {
-            cslDebug((50, "Wait for rdma_b_alu_fifo for per-channel data\n"));
+            //cslDebug((50, "Wait for rdma_b_alu_fifo for per-channel data\n"));
             int16_t *src_ptr = reinterpret_cast<int16_t*>(rdma_b_alu_fifo_->read());
-            cslDebug((50, "After Wait for rdma_b_alu_fifo for per-channel data\n"));
+            //cslDebug((50, "After Wait for rdma_b_alu_fifo for per-channel data\n"));
             memcpy(hls_x1_alu_op_[0][i], src_ptr, 16*sizeof(int16_t));
 
             delete [] src_ptr;
@@ -740,9 +740,9 @@ void NV_NVDLA_sdp::SdpLoadPerChannelData(uint32_t proc_num) {
             sdp_bs_mul_src_ == NVDLA_SDP_D_DP_BS_MUL_CFG_BS_MUL_SRC_MEM &&
             sdp_cfg_.sdp_rdma_brdma_data_mode_ == NVDLA_SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_PER_KERNEL ) {
         for( i = 0; i < proc_num; i ++) {
-            cslDebug((50, "Wait for rdma_b_mul_fifo for per-channel data\n"));
+            //cslDebug((50, "Wait for rdma_b_mul_fifo for per-channel data\n"));
             int16_t *src_ptr = reinterpret_cast<int16_t*>(rdma_b_mul_fifo_->read());
-            cslDebug((50, "After Wait for rdma_b_mul_fifo for per-channel data\n"));
+            //cslDebug((50, "After Wait for rdma_b_mul_fifo for per-channel data\n"));
             memcpy(hls_x1_mul_op_[0][i], src_ptr, 16*sizeof(int16_t));
 
             delete [] src_ptr;
@@ -753,9 +753,9 @@ void NV_NVDLA_sdp::SdpLoadPerChannelData(uint32_t proc_num) {
             sdp_bn_alu_src_ == NVDLA_SDP_D_DP_BN_ALU_CFG_BN_ALU_SRC_MEM &&
             sdp_cfg_.sdp_rdma_nrdma_data_mode_ == NVDLA_SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_PER_KERNEL ) {
         for( i = 0; i < proc_num; i++) {
-            cslDebug((50, "Wait for rdma_n_alu_fifo for per-channel data\n"));
+            //cslDebug((50, "Wait for rdma_n_alu_fifo for per-channel data\n"));
             int16_t *src_ptr = reinterpret_cast<int16_t*>(rdma_n_alu_fifo_->read());
-            cslDebug((50, "after Wait for rdma_n_alu_fifo for per-channel data\n"));
+            //cslDebug((50, "after Wait for rdma_n_alu_fifo for per-channel data\n"));
             memcpy(hls_x2_alu_op_[0][i], src_ptr, 16*sizeof(int16_t));
 
             delete [] src_ptr;
@@ -766,9 +766,9 @@ void NV_NVDLA_sdp::SdpLoadPerChannelData(uint32_t proc_num) {
             sdp_bn_mul_src_ == NVDLA_SDP_D_DP_BN_MUL_CFG_BN_MUL_SRC_MEM &&
             sdp_cfg_.sdp_rdma_nrdma_data_mode_ == NVDLA_SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_PER_KERNEL ) {
         for( i = 0; i < proc_num; i++) {
-            cslDebug((50, "Wait for rdma_n_mul_fifo for per-channel data\n"));
+            //cslDebug((50, "Wait for rdma_n_mul_fifo for per-channel data\n"));
             int16_t *src_ptr = reinterpret_cast<int16_t*>(rdma_n_mul_fifo_->read());
-            cslDebug((50, "After Wait for rdma_n_mul_fifo for per-channel data\n"));
+            //cslDebug((50, "After Wait for rdma_n_mul_fifo for per-channel data\n"));
             memcpy(hls_x2_mul_op_[0][i], src_ptr, 16*sizeof(int16_t));
 
             delete [] src_ptr;
@@ -779,9 +779,9 @@ void NV_NVDLA_sdp::SdpLoadPerChannelData(uint32_t proc_num) {
             sdp_ew_alu_src_ == NVDLA_SDP_D_DP_EW_ALU_CFG_EW_ALU_SRC_MEM &&
             sdp_cfg_.sdp_rdma_erdma_data_mode_ == NVDLA_SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PER_KERNEL ) {
         for( i = 0; i < proc_num; i++) {
-            cslDebug((50, "Wait for rdma_e_alu_fifo for per-channel data\n"));
+            //cslDebug((50, "Wait for rdma_e_alu_fifo for per-channel data\n"));
             int16_t *src_ptr = reinterpret_cast<int16_t*>(rdma_e_alu_fifo_->read());
-            cslDebug((50, "After Wait for rdma_e_alu_fifo for per-channel data\n"));
+            //cslDebug((50, "After Wait for rdma_e_alu_fifo for per-channel data\n"));
             memcpy(hls_y_alu_op_[0][i], src_ptr, 16*sizeof(int16_t));
 
             delete [] src_ptr;
@@ -792,9 +792,9 @@ void NV_NVDLA_sdp::SdpLoadPerChannelData(uint32_t proc_num) {
             sdp_ew_mul_src_ == NVDLA_SDP_D_DP_EW_MUL_CFG_EW_MUL_SRC_MEM &&
             sdp_cfg_.sdp_rdma_erdma_data_mode_ == NVDLA_SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PER_KERNEL ) {
         for( i = 0; i < proc_num; i++) {
-            cslDebug((50, "Wait for rdma_e_mul_fifo for per-channel data\n"));
+            //cslDebug((50, "Wait for rdma_e_mul_fifo for per-channel data\n"));
             int16_t *src_ptr = reinterpret_cast<int16_t*>(rdma_e_mul_fifo_->read());
-            cslDebug((50, "Aftger Wait for rdma_e_mul_fifo for per-channel data\n"));
+            //cslDebug((50, "Aftger Wait for rdma_e_mul_fifo for per-channel data\n"));
             memcpy(hls_y_mul_op_[0][i], src_ptr, 16*sizeof(int16_t));
 
             delete [] src_ptr;
@@ -810,9 +810,9 @@ void NV_NVDLA_sdp::SdpLoadPerElementData(uint32_t round, uint32_t proc) {
         if (sdp_bs_alu_bypass_ != NVDLA_SDP_D_DP_BS_CFG_0_BS_ALU_BYPASS_YES) {
             if (sdp_bs_alu_src_ == NVDLA_SDP_D_DP_BS_ALU_CFG_0_BS_ALU_SRC_MEM &&
                 sdp_cfg_.sdp_rdma_brdma_data_mode_ != NVDLA_SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_PER_KERNEL) {
-                cslDebug((50, "Wait for rdma_b_alu_fifo for per-element data\n"));
+                //cslDebug((50, "Wait for rdma_b_alu_fifo for per-element data\n"));
                 int16_t *ptr = rdma_b_alu_fifo_->read();
-                cslDebug((50, "After Wait for rdma_b_alu_fifo for per-element data\n"));
+                //cslDebug((50, "After Wait for rdma_b_alu_fifo for per-element data\n"));
                 memcpy(hls_x1_alu_op_[round][proc], ptr, sizeof(hls_x1_alu_op_[0][0]));
 
                 delete [] ptr;
@@ -824,9 +824,9 @@ void NV_NVDLA_sdp::SdpLoadPerElementData(uint32_t round, uint32_t proc) {
         if (sdp_bs_mul_bypass_ != NVDLA_SDP_D_DP_BS_CFG_0_BS_MUL_BYPASS_YES) {
             if (sdp_bs_mul_src_ == NVDLA_SDP_D_DP_BS_MUL_CFG_0_BS_MUL_SRC_MEM &&
                 sdp_cfg_.sdp_rdma_brdma_data_mode_ != NVDLA_SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_MODE_PER_KERNEL) {
-                cslDebug((50, "Wait for rdma_b_mul_fifo for per-element data\n"));
+                //cslDebug((50, "Wait for rdma_b_mul_fifo for per-element data\n"));
                 int16_t *ptr = rdma_b_mul_fifo_->read();
-                cslDebug((50, "After Wait for rdma_b_mul_fifo for per-element data\n"));
+                //cslDebug((50, "After Wait for rdma_b_mul_fifo for per-element data\n"));
                 memcpy(hls_x1_mul_op_[round][proc], ptr, sizeof(hls_x1_mul_op_[0][0]));
 
                 delete [] ptr;
@@ -839,9 +839,9 @@ void NV_NVDLA_sdp::SdpLoadPerElementData(uint32_t round, uint32_t proc) {
         if (sdp_bn_alu_bypass_ != NVDLA_SDP_D_DP_BN_CFG_0_BN_ALU_BYPASS_YES) {
             if (sdp_bn_alu_src_ == NVDLA_SDP_D_DP_BN_ALU_CFG_0_BN_ALU_SRC_MEM &&
                 sdp_cfg_.sdp_rdma_nrdma_data_mode_ != NVDLA_SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_PER_KERNEL) {
-                cslDebug((50, "Wait for rdma_n_alu_fifo for per-element data\n"));
+                //cslDebug((50, "Wait for rdma_n_alu_fifo for per-element data\n"));
                 int16_t *ptr = rdma_n_alu_fifo_->read();
-                cslDebug((50, "After Wait for rdma_n_alu_fifo for per-element data\n"));
+                //cslDebug((50, "After Wait for rdma_n_alu_fifo for per-element data\n"));
                 memcpy(hls_x2_alu_op_[round][proc], ptr, sizeof(hls_x2_alu_op_[0][0]));
 
                 delete [] ptr;
@@ -853,9 +853,9 @@ void NV_NVDLA_sdp::SdpLoadPerElementData(uint32_t round, uint32_t proc) {
         if (sdp_bn_mul_bypass_ != NVDLA_SDP_D_DP_BN_CFG_0_BN_MUL_BYPASS_YES) {
             if (sdp_bn_mul_src_ == NVDLA_SDP_D_DP_BN_MUL_CFG_0_BN_MUL_SRC_MEM &&
                 sdp_cfg_.sdp_rdma_nrdma_data_mode_ != NVDLA_SDP_RDMA_D_NRDMA_CFG_0_NRDMA_DATA_MODE_PER_KERNEL) {
-                cslDebug((50, "Wait for rdma_n_mul_fifo for per-element data\n"));
+                //cslDebug((50, "Wait for rdma_n_mul_fifo for per-element data\n"));
                 int16_t *ptr = rdma_n_mul_fifo_->read();
-                cslDebug((50, "After Wait for rdma_n_mul_fifo for per-element data\n"));
+                //cslDebug((50, "After Wait for rdma_n_mul_fifo for per-element data\n"));
                 memcpy(hls_x2_mul_op_[round][proc], ptr, sizeof(hls_x2_mul_op_[0][0]));
                 delete [] ptr;
             }
@@ -867,9 +867,9 @@ void NV_NVDLA_sdp::SdpLoadPerElementData(uint32_t round, uint32_t proc) {
         if (sdp_ew_alu_bypass_ != NVDLA_SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_YES) {
             if (sdp_ew_alu_src_ == NVDLA_SDP_D_DP_EW_ALU_CFG_0_EW_ALU_SRC_MEM &&
                 sdp_cfg_.sdp_rdma_erdma_data_mode_ != NVDLA_SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PER_KERNEL) {
-                cslDebug((50, "Wait for rdma_e_alu_fifo for per-element data\n"));
+                //cslDebug((50, "Wait for rdma_e_alu_fifo for per-element data\n"));
                 int16_t *ptr = reinterpret_cast<int16_t*>(rdma_e_alu_fifo_->read());
-                cslDebug((50, "After Wait for rdma_e_alu_fifo for per-element data\n"));
+                //cslDebug((50, "After Wait for rdma_e_alu_fifo for per-element data\n"));
                 memcpy(hls_y_alu_op_[round][proc], ptr, sizeof(hls_y_alu_op_[0][0]));
                 delete [] ptr;
             }
@@ -880,9 +880,9 @@ void NV_NVDLA_sdp::SdpLoadPerElementData(uint32_t round, uint32_t proc) {
         if (sdp_ew_mul_bypass_ != NVDLA_SDP_D_DP_EW_CFG_0_EW_MUL_BYPASS_YES) {
             if (sdp_ew_mul_src_ == NVDLA_SDP_D_DP_EW_MUL_CFG_0_EW_MUL_SRC_MEM &&
                 sdp_cfg_.sdp_rdma_erdma_data_mode_ != NVDLA_SDP_RDMA_D_ERDMA_CFG_0_ERDMA_DATA_MODE_PER_KERNEL) {
-                cslDebug((50, "Wait for rdma_e_mul_fifo for per-element data\n"));
+                //cslDebug((50, "Wait for rdma_e_mul_fifo for per-element data\n"));
                 int16_t *ptr = rdma_e_mul_fifo_->read();
-                cslDebug((50, "After Wait for rdma_e_mul_fifo for per-element data\n"));
+                //cslDebug((50, "After Wait for rdma_e_mul_fifo for per-element data\n"));
                 memcpy(hls_y_mul_op_[round][proc], ptr, sizeof(hls_y_mul_op_[0][0]));
                 delete [] ptr;
             }
@@ -916,8 +916,8 @@ void NV_NVDLA_sdp::SdpDataOperationDC() {
     channel    = sdp_channel_+1;
 
     surf_num        = (channel + element_per_atom - 1)/element_per_atom;
-    cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationDC started\n"));
-    cslDebug((30, "WxHxC=%dx%dx%d, surf_num=%d\n", width, height, channel, surf_num));
+    //cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationDC started\n"));
+    //cslDebug((30, "WxHxC=%dx%dx%d, surf_num=%d\n", width, height, channel, surf_num));
 
     for( surf_iter = 0; surf_iter < surf_num; surf_iter++ ) {
         // load the alu/mul data for per channel mode
@@ -927,15 +927,15 @@ void NV_NVDLA_sdp::SdpDataOperationDC() {
                 for( proc_iter = 0; proc_iter < proc_num_per_atom; proc_iter++ ) {
                     if (NVDLA_SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_OFF == sdp_flying_mode_) {
                         // input data
-                        cslDebug((30, "%s: before wait rdma_fifo_, valid:%d\n", __FUNCTION__, rdma_fifo_->num_available()));
+                        //cslDebug((30, "%s: before wait rdma_fifo_, valid:%d\n", __FUNCTION__, rdma_fifo_->num_available()));
                         rdma_data_ptr = reinterpret_cast<int16_t*>(rdma_fifo_->read());
-                        cslDebug((30, "%s: after wait rdma_fifo_, valid:%d\n", __FUNCTION__, rdma_fifo_->num_available()));
+                        //cslDebug((30, "%s: after wait rdma_fifo_, valid:%d\n", __FUNCTION__, rdma_fifo_->num_available()));
                         if (sdp_proc_precision_ == NVDLA_SDP_D_DATA_FORMAT_0_PROC_PRECISION_FP16 ) {
-                            cslDebug((30, "%s: SDP_DP, input data before FP16->32\n", __FUNCTION__));
+                            //cslDebug((30, "%s: SDP_DP, input data before FP16->32\n", __FUNCTION__));
                             for(int i = 0; i < 16; i++) {
-                                cslDebug((30, "%08x, ", rdma_data_ptr[i]));
+                                //cslDebug((30, "%08x, ", rdma_data_ptr[i]));
                             }
-                            cslDebug((30, "\n" ));
+                            //cslDebug((30, "\n" ));
                             if (sdp_hls_wrapper_.sdp_cfg_perf_nan_inf_cnt_en) {
                                 for(int i = 0; i < 16; i++) {
                                     if (((rdma_data_ptr[i]&0x3FF) == 0) && (((rdma_data_ptr[i]>>10)&0x1F) == 0x1F)) {
@@ -953,11 +953,11 @@ void NV_NVDLA_sdp::SdpDataOperationDC() {
                                 hls_data_in_[i] = Fp16ToFp32((ACINTT(16))rdma_data_ptr[i]);
                             }
                             
-                            cslDebug((30, "%s: SDP_DP, input data after FP16->32\n", __FUNCTION__));
+                            //cslDebug((30, "%s: SDP_DP, input data after FP16->32\n", __FUNCTION__));
                             for(int i = 0; i < 16; i++) {
-                                cslDebug((30, "%08x, ", hls_data_in_[i]));
+                                //cslDebug((30, "%08x, ", hls_data_in_[i]));
                             }
-                            cslDebug((30, "\n" ));
+                            //cslDebug((30, "\n" ));
 
                         } else {
                             for(int i = 0; i < 16; i++) {
@@ -967,37 +967,37 @@ void NV_NVDLA_sdp::SdpDataOperationDC() {
                         delete [] rdma_data_ptr;
                     } else {
                         // On-flyingg model, receive data from CACC
-                        cslDebug((50, "NV_NVDLA_sdp::SdpDataOperationThread, before read cc2pp_fifo_\n"));
+                        //cslDebug((50, "NV_NVDLA_sdp::SdpDataOperationThread, before read cc2pp_fifo_\n"));
                         cacc2sdp_data_ptr = (uint32_t*)(cc2pp_fifo_->read()); // Read an atom (32B)
-                        cslDebug((50, "NV_NVDLA_sdp::SdpDataOperationThread, after read cc2pp_fifo_\n"));
+                        //cslDebug((50, "NV_NVDLA_sdp::SdpDataOperationThread, after read cc2pp_fifo_\n"));
                         memcpy(hls_data_in_, cacc2sdp_data_ptr, sizeof(uint32_t)*CC2PP_PAYLOAD_SIZE);
-                        cslDebug((30, "%s: SDP_DP, input data from cacc\n", __FUNCTION__));
+                        //cslDebug((30, "%s: SDP_DP, input data from cacc\n", __FUNCTION__));
                         for(int i = 0; i < 16; i++) {
-                            cslDebug((30, "%08x, ", hls_data_in_[i]));
+                            //cslDebug((30, "%08x, ", hls_data_in_[i]));
                         }
-                        cslDebug((30, "\n" ));
+                        //cslDebug((30, "\n" ));
 
                         delete [] cacc2sdp_data_ptr;
                     }
 
-                    cslDebug((30, "%s: before load per-element BS/BN/EW data\n", __FUNCTION__));
+                    //cslDebug((30, "%s: before load per-element BS/BN/EW data\n", __FUNCTION__));
                     SdpLoadPerElementData(0, proc_iter);
 
-                    cslDebug((70, "NV_NVDLA_sdp::%s, RDMA->DP\n", __FUNCTION__));
+                    //cslDebug((70, "NV_NVDLA_sdp::%s, RDMA->DP\n", __FUNCTION__));
                     for(int i=0;i<SDP_PARALLEL_PROC_NUM;i++) {
-                        cslDebug((70, "0x%x ", (unsigned int)hls_data_in_[i]));
+                        //cslDebug((70, "0x%x ", (unsigned int)hls_data_in_[i]));
                     }
-                    cslDebug((70, "\n" ));
-                    cslDebug((70, "NV_NVDLA_sdp::%s, RDMA->DP, X1_ALU\n", __FUNCTION__));
+                    //cslDebug((70, "\n" ));
+                    //cslDebug((70, "NV_NVDLA_sdp::%s, RDMA->DP, X1_ALU\n", __FUNCTION__));
                     for(int i=0;i<SDP_PARALLEL_PROC_NUM;i++) {
-                        cslDebug((70, "0x%x ", (unsigned int)hls_x1_alu_op_[0][proc_iter][i]));
+                        //cslDebug((70, "0x%x ", (unsigned int)hls_x1_alu_op_[0][proc_iter][i]));
                     }
-                    cslDebug((70, "\n" ));
-                    cslDebug((70, "NV_NVDLA_sdp::%s, RDMA->DP, X1_MUL\n", __FUNCTION__));
+                    //cslDebug((70, "\n" ));
+                    //cslDebug((70, "NV_NVDLA_sdp::%s, RDMA->DP, X1_MUL\n", __FUNCTION__));
                     for(int i=0;i<SDP_PARALLEL_PROC_NUM;i++) {
-                        cslDebug((70, "0x%x ", (unsigned int)hls_x1_mul_op_[0][proc_iter][i]));
+                        //cslDebug((70, "0x%x ", (unsigned int)hls_x1_mul_op_[0][proc_iter][i]));
                     }
-                    cslDebug((70, "\n" ));
+                    //cslDebug((70, "\n" ));
 
                     // Call HLS code
                     sdp_hls_wrapper_.sdp(hls_data_in_,
@@ -1020,30 +1020,30 @@ void NV_NVDLA_sdp::SdpDataOperationDC() {
                             cslAssert((temp_ptr != NULL));
                             memcpy(temp_ptr, sdp_hls_wrapper_.sdp_data_out, ATOM_CUBE_SIZE);
                             // Output destination is memory
-                            cslDebug((70, "NV_NVDLA_sdp::%s, DP->WDMA\n", __FUNCTION__));
+                            //cslDebug((70, "NV_NVDLA_sdp::%s, DP->WDMA\n", __FUNCTION__));
                             for(int i=0;i<SDP_PARALLEL_PROC_NUM;i++) {
-                                cslDebug((70, "0x%x ", (unsigned int)sdp_hls_wrapper_.sdp_data_out[i]));
+                                //cslDebug((70, "0x%x ", (unsigned int)sdp_hls_wrapper_.sdp_data_out[i]));
                             }
-                            cslDebug((70, "\n" ));
+                            //cslDebug((70, "\n" ));
                             wdma_fifo_->write(temp_ptr);    //32B
 
 #pragma CTC SKIP
-                            cslDebug((50, " write wdma_fifo_, height[%d], width[%d], proc[%d], total_num:%d\n",
-                                        height_iter, width_iter, proc_iter,
-                                        height_iter*width + width_iter*proc_num_per_atom + proc_iter+1));
+                            //cslDebug((50, " write wdma_fifo_, height[%d], width[%d], proc[%d], total_num:%d\n",
+                            //            height_iter, width_iter, proc_iter,
+                            //            height_iter*width + width_iter*proc_num_per_atom + proc_iter+1));
 #pragma CTC ENDSKIP
                         } else {
                             // Output destination is PDP
                             nvdla_sdp2pdp_t* payload = new nvdla_sdp2pdp_t;
-                            cslDebug((70, "%s, DP->PDP\n", __FUNCTION__));
+                            //cslDebug((70, "%s, DP->PDP\n", __FUNCTION__));
                             for(int i=0;i<SDP_PARALLEL_PROC_NUM;i++) {
-                                cslDebug((70, "0x%x ", (unsigned int)sdp_hls_wrapper_.sdp_data_out[i]));
+                                //cslDebug((70, "0x%x ", (unsigned int)sdp_hls_wrapper_.sdp_data_out[i]));
                             }
-                            cslDebug((70, "\n" ));
+                            //cslDebug((70, "\n" ));
                             memcpy((void *)payload->pd.sdp2pdp.data, sdp_hls_wrapper_.sdp_data_out, ATOM_CUBE_SIZE);
                             sdp2pdp_b_transport(payload, b_transport_delay_);
                             delete payload;
-                            cslDebug((70, "%s: send payload to PDP done\n", __FUNCTION__));
+                            //cslDebug((70, "%s: send payload to PDP done\n", __FUNCTION__));
                         }
                     }
                 }
@@ -1077,7 +1077,7 @@ void NV_NVDLA_sdp::SdpDataOperationBatch() {
     proc_num_per_atom = element_per_atom/SDP_PARALLEL_PROC_NUM;
 
 
-    cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationBatch started\n"));
+    //cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationBatch started\n"));
     width      = sdp_width_+1;
     height     = sdp_height_+1;
     channel    = sdp_channel_+1;
@@ -1105,13 +1105,13 @@ void NV_NVDLA_sdp::SdpDataOperationBatch() {
                             // On-flyingg model, receive data from CACC
                             if (NVDLA_SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_OFF == sdp_flying_mode_) {
                                 // input data
-                                cslDebug((50, "%s, before read data from rdma\n", __FUNCTION__));
+                                //cslDebug((50, "%s, before read data from rdma\n", __FUNCTION__));
                                 rdma_data_ptr = reinterpret_cast<int16_t*>(rdma_fifo_->read());
-                                cslDebug((30, "%s: SDP_DP, input data before FP16->32\n", __FUNCTION__));
+                                //cslDebug((30, "%s: SDP_DP, input data before FP16->32\n", __FUNCTION__));
                                 for(int i = 0; i < 16; i++) {
-                                    cslDebug((30, "%08x, ", rdma_data_ptr[i]));
+                                    //cslDebug((30, "%08x, ", rdma_data_ptr[i]));
                                 }
-                                cslDebug((30, "\n" ));
+                                //cslDebug((30, "\n" ));
 
                                 if (sdp_proc_precision_ == NVDLA_SDP_D_DATA_FORMAT_0_PROC_PRECISION_FP16 ) {
 #pragma CTC SKIP
@@ -1132,9 +1132,9 @@ void NV_NVDLA_sdp::SdpDataOperationBatch() {
                                         hls_data_in_[i] = Fp16ToFp32((ACINTT(16))rdma_data_ptr[i]);
                                     }
 
-                                    cslDebug((30, "%s: SDP_DP, input data after FP16->32\n", __FUNCTION__));
+                                    //cslDebug((30, "%s: SDP_DP, input data after FP16->32\n", __FUNCTION__));
                                     for(int i = 0; i < 16; i++) {
-                                        cslDebug((30, "%08x, ", hls_data_in_[i]));
+                                        //cslDebug((30, "%08x, ", hls_data_in_[i]));
                                     }
                                     cslDebug((30, "\n" ));
 
@@ -1146,12 +1146,12 @@ void NV_NVDLA_sdp::SdpDataOperationBatch() {
                                 delete [] rdma_data_ptr;
                             } else {
                                 // On-flyingg model, receive data from CACC
-                                cslDebug((50, "%s, before read data from cacc\n", __FUNCTION__));
+                                //cslDebug((50, "%s, before read data from cacc\n", __FUNCTION__));
                                 cacc2sdp_data_ptr = (uint32_t*)(cc2pp_fifo_->read()); // Read an atom (32B)
                                 memcpy(hls_data_in_, cacc2sdp_data_ptr, sizeof(uint32_t)*CC2PP_PAYLOAD_SIZE);
                                 delete [] cacc2sdp_data_ptr;
                             }
-                            cslDebug((50, "%s, after read data\n", __FUNCTION__));
+                            //cslDebug((50, "%s, after read data\n", __FUNCTION__));
 
                             if (batch_iter == 0) {
                                 SdpLoadPerElementData(round_iter, proc_iter);
@@ -1176,9 +1176,9 @@ void NV_NVDLA_sdp::SdpDataOperationBatch() {
                             int16_t *temp_ptr = new int16_t[16];
                             cslAssert((temp_ptr != NULL));
                             memcpy(temp_ptr, sdp_hls_wrapper_.sdp_data_out, ATOM_CUBE_SIZE);
-                            cslDebug((50, "before write wdma_fifo_\n"));
+                            //cslDebug((50, "before write wdma_fifo_\n"));
                             wdma_fifo_->write(temp_ptr);    //8B
-                            cslDebug((50, "after write wdma_fifo_\n"));
+                            //cslDebug((50, "after write wdma_fifo_\n"));
                         }
                     }
                 }
@@ -1209,7 +1209,7 @@ void NV_NVDLA_sdp::SdpDataOperationWG() {
     proc_num_per_atom = element_per_atom/SDP_PARALLEL_PROC_NUM;
 
 
-    cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationWG started\n"));
+    //cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationWG started\n"));
     width      = sdp_width_+1;
     height     = sdp_height_+1;
     channel    = sdp_channel_+1;
@@ -1228,17 +1228,17 @@ void NV_NVDLA_sdp::SdpDataOperationWG() {
                             cslAssert(NVDLA_SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_ON == sdp_flying_mode_);
 #endif
                             // On-flyingg model, receive data from CACC
-                            cslDebug((50, "%s, before read data\n", __FUNCTION__));
+                            //cslDebug((50, "%s, before read data\n", __FUNCTION__));
                             if (NVDLA_SDP_D_FEATURE_MODE_CFG_0_FLYING_MODE_OFF == sdp_flying_mode_) {
                                 // input data
                                 rdma_data_ptr = reinterpret_cast<int16_t*>(rdma_fifo_->read());
-                                cslDebug((30, "%s: after wait rdma_fifo_, valid:%d\n", __FUNCTION__, rdma_fifo_->num_available()));
+                                //cslDebug((30, "%s: after wait rdma_fifo_, valid:%d\n", __FUNCTION__, rdma_fifo_->num_available()));
                                 if (sdp_proc_precision_ == NVDLA_SDP_D_DATA_FORMAT_0_PROC_PRECISION_FP16 ) {
-                                    cslDebug((30, "%s: SDP_DP, input data before FP16->32\n", __FUNCTION__));
+                                    //cslDebug((30, "%s: SDP_DP, input data before FP16->32\n", __FUNCTION__));
                                     for(int i = 0; i < 16; i++) {
-                                        cslDebug((30, "%08x, ", rdma_data_ptr[i]));
+                                        //cslDebug((30, "%08x, ", rdma_data_ptr[i]));
                                     }
-                                    cslDebug((30, "\n" ));
+                                    //cslDebug((30, "\n" ));
 #pragma CTC SKIP
                                     if (sdp_hls_wrapper_.sdp_cfg_perf_nan_inf_cnt_en) {
                                         for(int i = 0; i < 16; i++) {
@@ -1258,11 +1258,11 @@ void NV_NVDLA_sdp::SdpDataOperationWG() {
                                         hls_data_in_[i] = Fp16ToFp32((ACINTT(16))rdma_data_ptr[i]);
                                     }
 
-                                    cslDebug((30, "%s: SDP_DP, input data after FP16->32\n", __FUNCTION__));
+                                    //cslDebug((30, "%s: SDP_DP, input data after FP16->32\n", __FUNCTION__));
                                     for(int i = 0; i < 16; i++) {
-                                        cslDebug((30, "%08x, ", hls_data_in_[i]));
+                                        //cslDebug((30, "%08x, ", hls_data_in_[i]));
                                     }
-                                    cslDebug((30, "\n" ));
+                                    //cslDebug((30, "\n" ));
 
                                 } else {
                                     for(int i = 0; i < 16; i++) {
@@ -1276,7 +1276,7 @@ void NV_NVDLA_sdp::SdpDataOperationWG() {
                                 memcpy(hls_data_in_, cacc2sdp_data_ptr, sizeof(uint32_t)*CC2PP_PAYLOAD_SIZE);
                                 delete [] cacc2sdp_data_ptr;
                             }
-                            cslDebug((50, "%s, after read data\n", __FUNCTION__));
+                            //cslDebug((50, "%s, after read data\n", __FUNCTION__));
 
                             SdpLoadPerElementData(0, proc_iter);
 
@@ -1289,7 +1289,7 @@ void NV_NVDLA_sdp::SdpDataOperationWG() {
                             if (sdp_ew_alu_algo_ == NVDLA_SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_EQL &&
                                     sdp_ew_bypass_ == NVDLA_SDP_D_DP_EW_CFG_0_EW_BYPASS_NO &&
                                     sdp_ew_alu_bypass_ == NVDLA_SDP_D_DP_EW_CFG_0_EW_ALU_BYPASS_NO) {
-                                cslInfo(("EQL mode is not supported in winograd\n"));
+                                //cslInfo(("EQL mode is not supported in winograd\n"));
                                 cslAssert(false);
 #pragma CTC ENDSKIP
                             } else {
@@ -1297,7 +1297,7 @@ void NV_NVDLA_sdp::SdpDataOperationWG() {
                                 cslAssert((temp_ptr != NULL));
                                 memcpy(temp_ptr, sdp_hls_wrapper_.sdp_data_out, ATOM_CUBE_SIZE);
                                 wdma_fifo_->write(temp_ptr);    //8B
-                                cslDebug((50, " write wdma_fifo_\n"));
+                                //cslDebug((50, " write wdma_fifo_\n"));
                             }
                         }
                     }
@@ -1348,7 +1348,7 @@ void NV_NVDLA_sdp::SdpDataOperationThread () {
                 (uint32_t)0);
         }
 
-        cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationThread, layer operation begin\n"));
+        //cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationThread, layer operation begin\n"));
         // Copy from register value to local config variables, similar with RTL connection, begin
         // # Cube setting
         batch_num       = sdp_batch_number_+1;
@@ -1412,7 +1412,7 @@ void NV_NVDLA_sdp::SdpDataOperationThread () {
                     sdp_consumer_,
                     (uint32_t)sdp_hls_wrapper_.o_nan_cnt);
         }
-        cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationThread, layer operation end\n"));
+        //cslDebug((30, "NV_NVDLA_sdp::SdpDataOperationThread, layer operation end\n"));
 
 #pragma CTC SKIP
         if ((sdp_ew_bypass_ == NVDLA_SDP_D_DP_EW_CFG_0_EW_BYPASS_NO &&
@@ -1420,7 +1420,7 @@ void NV_NVDLA_sdp::SdpDataOperationThread () {
                 sdp_ew_alu_algo_ == NVDLA_SDP_D_DP_EW_CFG_0_EW_ALU_ALGO_EQL) ||
                 NVDLA_SDP_D_FEATURE_MODE_CFG_0_OUTPUT_DST_MEM != sdp_output_dst_) {
 #pragma CTC ENDSKIP
-            cslInfo(("trigger sdp_done as there's no wdma operation\n"));
+            //cslInfo(("trigger sdp_done as there's no wdma operation\n"));
             ack_info *ack = new ack_info;
             ack->is_mc = -1;
             ack->group_id = sdp_consumer_;
@@ -1515,7 +1515,7 @@ void NV_NVDLA_sdp::WdmaSequenceDC() {
                     payload_size        = payload_atom_num*ATOM_CUBE_SIZE;
                     if ( (surface_iter+1 == surface_num)
                             && (line_iter+1==cube_height)) {
-                        cslDebug((30, "SDP dst line_unpacked %s send the last transaction, ack_required=%d\n", __FUNCTION__, is_required_ack));
+                        //cslDebug((30, "SDP dst line_unpacked %s send the last transaction, ack_required=%d\n", __FUNCTION__, is_required_ack));
                         is_required_ack = true;
                     }
                     SendDmaWriteRequest(payload_addr, payload_size, payload_atom_num, is_required_ack);
@@ -1533,7 +1533,7 @@ void NV_NVDLA_sdp::WdmaSequenceDC() {
                         if ( (surface_iter+2 >= surface_num)
                                 && (line_iter+1==cube_height)
                                 && (width_iter + width_step == cube_width) ) {
-                            cslDebug((30, "SDP dst line_unpacked %s send the last transaction, width_iter=%d ack_required=%d\n", __FUNCTION__, width_iter, is_required_ack));
+                            //cslDebug((30, "SDP dst line_unpacked %s send the last transaction, width_iter=%d ack_required=%d\n", __FUNCTION__, width_iter, is_required_ack));
                             is_required_ack = true;
                         }
                         SendDmaWriteRequest(payload_addr, payload_size, width_step, is_required_ack);
@@ -1591,7 +1591,7 @@ void NV_NVDLA_sdp::WdmaSequenceWG() {
     }
 
     if (dst_base_addr%64 != 0) {
-        cslDebug((30, "dst_base_addr:0x%lx is not 64bytes aligned\n", dst_base_addr));
+        //cslDebug((30, "dst_base_addr:0x%lx is not 64bytes aligned\n", dst_base_addr));
     }
 
     // For block sequence looping
@@ -1609,8 +1609,8 @@ void NV_NVDLA_sdp::WdmaSequenceWG() {
                         is_required_ack = true;
                     }
 #pragma CTC SKIP
-                    cslDebug((30, "%s: surf_iter:%d, line_iter:%d, col_iter:%d, wg_line_iter:%d, payload_size:%d, req_ack:%d\n",
-                                __FUNCTION__, surface_iter, line_iter, col_iter, wg_line_iter, payload_size, is_required_ack));
+                    //cslDebug((30, "%s: surf_iter:%d, line_iter:%d, col_iter:%d, wg_line_iter:%d, payload_size:%d, req_ack:%d\n",
+                    //            __FUNCTION__, surface_iter, line_iter, col_iter, wg_line_iter, payload_size, is_required_ack));
 #pragma CTC ENDSKIP
                     SendDmaWriteRequest(payload_addr, payload_size, payload_atom_num, is_required_ack);       
                 }
@@ -1695,8 +1695,8 @@ void NV_NVDLA_sdp::WdmaSequenceBatch() {
                         is_required_ack = true;
                     }
 #pragma CTC SKIP
-                    cslDebug((30, "%s: send %d atoms on surf_iter:%d, line_iter:%d, atom_iter:%d, batch_iter:%d. AckReqired:%d\n", __FUNCTION__,
-                                round_num, surface_iter, line_iter, atom_sent_num, batch_iter, is_required_ack));
+                    //cslDebug((30, "%s: send %d atoms on surf_iter:%d, line_iter:%d, atom_iter:%d, batch_iter:%d. AckReqired:%d\n", __FUNCTION__,
+                    //            round_num, surface_iter, line_iter, atom_sent_num, batch_iter, is_required_ack));
 #pragma CTC ENDSKIP
                     SendDmaWriteRequest(payload_addr, payload_size, round_num, is_required_ack);       
                 }
@@ -1747,7 +1747,7 @@ void NV_NVDLA_sdp::cacc2sdp_b_transport(int ID, nvdla_accu2pp_if_t* payload, sc_
             // It's also possible that cacc starts earlier than sdp and sdp's sdp_flying_mode_ is not set when cacc sends data to sdp.
             // wait next sdp kick off and check sdp_flying_mode_ again.
 #pragma CTC SKIP
-            cslDebug((30, "calling NV_NVDLA_sdp::cacc2sdp_b_transport. sdp_flying_mode_ is OFF\n"));
+            //cslDebug((30, "calling NV_NVDLA_sdp::cacc2sdp_b_transport. sdp_flying_mode_ is OFF\n"));
             wait(sdp_kickoff_);
 #pragma CTC ENDSKIP
         } else {
@@ -1755,12 +1755,12 @@ void NV_NVDLA_sdp::cacc2sdp_b_transport(int ID, nvdla_accu2pp_if_t* payload, sc_
         }
     }
     fifo_data_ptr = new int32_t[CC2PP_PAYLOAD_SIZE];    //CC2PP_PAYLOAD_SIZE=16
-    cslDebug((70, "NV_NVDLA_sdp::cacc2sdp_b_transport:\n"));
+    //cslDebug((70, "NV_NVDLA_sdp::cacc2sdp_b_transport:\n"));
     for(i=0;i<CC2PP_PAYLOAD_SIZE;i++) {
         fifo_data_ptr[i] = payload->pd.nvdla_cc2pp_pkg.data[i];
-        cslDebug((70, "0x%08x ", (int32_t)fifo_data_ptr[i]));
+        //cslDebug((70, "0x%08x ", (int32_t)fifo_data_ptr[i]));
     }
-    cslDebug((70, "\n"));
+    //cslDebug((70, "\n"));
     cc2pp_fifo_->write((int32_t*)fifo_data_ptr);
 }
 
@@ -1780,7 +1780,7 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
     mask = payload->pd.dma_read_data.mask;
     payload_data_ptr_i8    = reinterpret_cast <int8_t *> (payload->pd.dma_read_data.data);
     payload_data_ptr_i16   = reinterpret_cast <int16_t *> (payload->pd.dma_read_data.data);
-    cslDebug((50, "NV_NVDLA_sdp::ExtractRdmaResponsePayload_%d, get a dma read response payload. mask=0x%x\n", eRdDma, (int)mask));
+    //cslDebug((50, "NV_NVDLA_sdp::ExtractRdmaResponsePayload_%d, get a dma read response payload. mask=0x%x\n", eRdDma, (int)mask));
     bool    is_int16_to_int8 = false;
 
     cube_width      = sdp_rdma_width_+1;
@@ -1842,10 +1842,10 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
         is_both = data_use == NVDLA_SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_BOTH;
         if (data_use == NVDLA_SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_ALU) {
             fifo = fifo_alu;
-            cslDebug((50, "fifo_alu\n"));
+            //cslDebug((50, "fifo_alu\n"));
         } else if (data_use == NVDLA_SDP_RDMA_D_BRDMA_CFG_0_BRDMA_DATA_USE_MUL) {
             fifo = fifo_mul;
-            cslDebug((50, "fifo_mul\n"));
+            //cslDebug((50, "fifo_mul\n"));
         }
         if (0 != (mask & (0x1 << payload_iter))) {
             if (is_int16_to_int8 && eRdDma == SDP_RDMA_INPUT) {
@@ -1869,7 +1869,7 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
                     memcpy(ptr1, sdp_internal_buf_[eRdDma] + sdp_buf_rd_ptr_[eRdDma],
                             SDP_PARALLEL_PROC_NUM*bytes_per_element);
                     fifo->write(ptr1);
-                    cslDebug((30, "%s send a payload to alu or mul fifo\n", str));
+                    //cslDebug((30, "%s send a payload to alu or mul fifo\n", str));
                     sdp_buf_rd_ptr_[eRdDma] += ATOM_CUBE_SIZE;
 
                     // send the current received data
@@ -1878,7 +1878,7 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
                     memcpy(ptr1, payload_data_ptr_i16,
                             SDP_PARALLEL_PROC_NUM*bytes_per_element);
                     fifo->write(ptr1);
-                    cslDebug((30, "%s send a payload to alu or mul fifo\n", str));
+                    //cslDebug((30, "%s send a payload to alu or mul fifo\n", str));
 
                     if (sdp_buf_rd_ptr_[eRdDma] == buf_surf_stride) {
                         // all the buffered data are read out;
@@ -1893,9 +1893,9 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
                     }
                 }
 #pragma CTC SKIP
-                cslDebug((50, "fifo_available:%d, sdp_buf_wr_ptr_[%d]=%d, sdp_buf_rd_ptr_[%d]=%d, expect:%d\n",
-                            fifo->num_available(), eRdDma, sdp_buf_wr_ptr_[eRdDma], 
-                            eRdDma, sdp_buf_rd_ptr_[eRdDma], buf_surf_stride));
+                //cslDebug((50, "fifo_available:%d, sdp_buf_wr_ptr_[%d]=%d, sdp_buf_rd_ptr_[%d]=%d, expect:%d\n",
+                //            fifo->num_available(), eRdDma, sdp_buf_wr_ptr_[eRdDma],
+                //            eRdDma, sdp_buf_rd_ptr_[eRdDma], buf_surf_stride));
 #pragma CTC ENDSKIP
             } else {
                 if (is_int8) {
@@ -1906,9 +1906,9 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
                             for( int i = 0; i < SDP_PARALLEL_PROC_NUM; i++) {
                                 ptr1[i] = static_cast<int16_t>(payload_data_ptr_i8[i + SDP_PARALLEL_PROC_NUM*atom]);
                             }
-                            cslDebug((30, "%s send a payload to alu or mul fifo, nb_free:%d\n", str, fifo->num_free()));
+                            //cslDebug((30, "%s send a payload to alu or mul fifo, nb_free:%d\n", str, fifo->num_free()));
                             fifo->write(ptr1);
-                            cslDebug((30, "after %s send a payload to alu or mul fifo\n", str));
+                            //cslDebug((30, "after %s send a payload to alu or mul fifo\n", str));
                         }
                     } else {
                         int16_t *ptr1 = new int16_t[SDP_PARALLEL_PROC_NUM];
@@ -1921,7 +1921,7 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
                         }
                         fifo_alu->write(ptr1);
                         fifo_mul->write(ptr2);
-                        cslDebug((30, "%s send a payload to both alu/mul fifo\n", str));
+                        //cslDebug((30, "%s send a payload to both alu/mul fifo\n", str));
                     }
                 } else {
                     if (is_both == false) {
@@ -1930,7 +1930,7 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
 
                         memcpy(ptr1, payload_data_ptr_i16, ATOM_CUBE_SIZE);
                         fifo->write(ptr1);
-                        cslDebug((30, "%s send a payload to alu or mul fifo\n", str));
+                        //cslDebug((30, "%s send a payload to alu or mul fifo\n", str));
                     } else {
                         if (payload_alu_ == NULL) {
                             payload_alu_ = new int16_t[SDP_PARALLEL_PROC_NUM];
@@ -1957,7 +1957,7 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
                             payload_alu_ = NULL;
                             payload_mul_ = NULL;
 
-                            cslDebug((30, "%s send a payload to both alu/mul fifo\n", str));
+                            //cslDebug((30, "%s send a payload to both alu/mul fifo\n", str));
                         }
                     }
                 }
@@ -1969,8 +1969,8 @@ void NV_NVDLA_sdp::ExtractRdmaResponsePayloadCore(te_rdma_type eRdDma, nvdla_dma
     rdma_atom_recieved_[eRdDma] += ((mask&0x3) == 0x3)? 2:1;
     if (rdma_atom_recieved_[eRdDma] == rdma_atom_total_[eRdDma]) {
 #pragma CTC SKIP
-        cslDebug((30, "dma:%d, atom_recieved:%d, total:%d\n",
-                    eRdDma, rdma_atom_recieved_[eRdDma], rdma_atom_total_[eRdDma]));
+        //cslDebug((30, "dma:%d, atom_recieved:%d, total:%d\n",
+        //            eRdDma, rdma_atom_recieved_[eRdDma], rdma_atom_total_[eRdDma]));
 #pragma CTC ENDSKIP
         rdma_atom_recieved_[eRdDma] = 0;
         if (eRdDma == SDP_RDMA_INPUT) {
@@ -2035,34 +2035,34 @@ void NV_NVDLA_sdp::WaitUntilRdmaFifoFreeSizeGreaterThan(uint32_t num) {
 void NV_NVDLA_sdp::SendDmaReadRequest(te_rdma_type eRdDma, nvdla_dma_rd_req_t* payload, sc_time& delay) {
     if (eRdDma == SDP_RDMA_INPUT) {
         if ( (NVDLA_SDP_RDMA_D_SRC_DMA_CFG_0_SRC_RAM_TYPE_MC) == sdp_rdma_src_ram_type_) {
-            cslDebug((50, "NV_NVDLA_sdp::%s on SDP_RDMA MC port start.\n", __FUNCTION__));
+            //cslDebug((50, "NV_NVDLA_sdp::%s on SDP_RDMA MC port start.\n", __FUNCTION__));
             NV_NVDLA_sdp_base::sdp2mcif_rd_req_b_transport(payload, dma_delay_);
         } else {
-            cslDebug((50, "NV_NVDLA_sdp::%s on SDP_RDMA CV port start.\n", __FUNCTION__));
+            //cslDebug((50, "NV_NVDLA_sdp::%s on SDP_RDMA CV port start.\n", __FUNCTION__));
             NV_NVDLA_sdp_base::sdp2cvif_rd_req_b_transport(payload, dma_delay_);
         }
     } else if (eRdDma == SDP_RDMA_X1_INPUT) {
          if ( (NVDLA_SDP_RDMA_D_BRDMA_CFG_0_BRDMA_RAM_TYPE_MC) == sdp_rdma_brdma_ram_type_) {
-            cslDebug((50, "NV_NVDLA_sdp::%s on SDP_BRDMA MC port start.\n", __FUNCTION__));
+            //cslDebug((50, "NV_NVDLA_sdp::%s on SDP_BRDMA MC port start.\n", __FUNCTION__));
             NV_NVDLA_sdp_base::sdp_b2mcif_rd_req_b_transport(payload, dma_delay_);
         } else {
-            cslDebug((50, "NV_NVDLA_sdp::%s on SDP_BRDMA CV port start.\n", __FUNCTION__));
+            //cslDebug((50, "NV_NVDLA_sdp::%s on SDP_BRDMA CV port start.\n", __FUNCTION__));
             NV_NVDLA_sdp_base::sdp_b2cvif_rd_req_b_transport(payload, dma_delay_);
         }
     } else if (eRdDma == SDP_RDMA_X2_INPUT) {
          if ( (NVDLA_SDP_RDMA_D_NRDMA_CFG_0_NRDMA_RAM_TYPE_MC) == sdp_rdma_nrdma_ram_type_) {
-            cslDebug((50, "NV_NVDLA_sdp::%s on SDP_NRDMA MC port start.\n", __FUNCTION__));
+            //cslDebug((50, "NV_NVDLA_sdp::%s on SDP_NRDMA MC port start.\n", __FUNCTION__));
             NV_NVDLA_sdp_base::sdp_n2mcif_rd_req_b_transport(payload, dma_delay_);
         } else {
-            cslDebug((50, "NV_NVDLA_sdp::%s on SDP_NRDMA CV port start.\n", __FUNCTION__));
+            //cslDebug((50, "NV_NVDLA_sdp::%s on SDP_NRDMA CV port start.\n", __FUNCTION__));
             NV_NVDLA_sdp_base::sdp_n2cvif_rd_req_b_transport(payload, dma_delay_);
         }
     } else {
          if ( (NVDLA_SDP_RDMA_D_ERDMA_CFG_0_ERDMA_RAM_TYPE_MC) == sdp_rdma_erdma_ram_type_) {
-            cslDebug((50, "NV_NVDLA_sdp::%s on SDP_ERDMA MC port start.\n", __FUNCTION__));
+            //cslDebug((50, "NV_NVDLA_sdp::%s on SDP_ERDMA MC port start.\n", __FUNCTION__));
             NV_NVDLA_sdp_base::sdp_e2mcif_rd_req_b_transport(payload, dma_delay_);
         } else {
-            cslDebug((50, "NV_NVDLA_sdp::%s on SDP_ERDMA CV port start.\n", __FUNCTION__));
+            //cslDebug((50, "NV_NVDLA_sdp::%s on SDP_ERDMA CV port start.\n", __FUNCTION__));
             NV_NVDLA_sdp_base::sdp_e2cvif_rd_req_b_transport(payload, dma_delay_);
         }
     }
@@ -2083,9 +2083,9 @@ void NV_NVDLA_sdp::SendDmaWriteRequest(uint64_t payload_addr, uint32_t payload_s
         dma_wr_req_cmd_payload_->pd.dma_write_cmd.size = payload_atom_num-1;
         // WaitUntilWdmaBufferAvailableSizeGreaterThan(payload_atom_num);
         // Send write command
-        cslDebug((50, "NV_NVDLA_sdp::SendDmaWriteRequest before CMD addr=0x%lx payload_atom_num=%d\n", payload_addr, payload_atom_num));
+        //cslDebug((50, "NV_NVDLA_sdp::SendDmaWriteRequest before CMD addr=0x%lx payload_atom_num=%d\n", payload_addr, payload_atom_num));
         SendDmaWriteRequest(dma_wr_req_cmd_payload_, dma_delay_, ack_required);
-        cslDebug((50, "NV_NVDLA_sdp::SendDmaWriteRequest after CMD addr=0x%lx payload_atom_num=%d\n", payload_addr, payload_atom_num));
+        //cslDebug((50, "NV_NVDLA_sdp::SendDmaWriteRequest after CMD addr=0x%lx payload_atom_num=%d\n", payload_addr, payload_atom_num));
     }
     if (sdp_out_precision_ == DATA_FORMAT_IS_INT8) {
         int8_t *payload_data_ptr;
@@ -2095,9 +2095,9 @@ void NV_NVDLA_sdp::SendDmaWriteRequest(uint64_t payload_addr, uint32_t payload_s
             // each transaction from DP is 16 elements, for INT8, we have to combine 2 transactions
             // to pack one output atom
             for(channel_iter = 0; channel_iter < ATOM_CUBE_SIZE/SDP_PARALLEL_PROC_NUM; channel_iter++) {
-                cslDebug((70, "%s: before read wdma_fifo\n", __FUNCTION__));
+                //cslDebug((70, "%s: before read wdma_fifo\n", __FUNCTION__));
                 dma_write_data_ptr = reinterpret_cast <int16_t *>(wdma_fifo_->read());    //16*32bits(64B)
-                cslDebug((70, "%s: after read wdma_fifo\n", __FUNCTION__));
+                //cslDebug((70, "%s: after read wdma_fifo\n", __FUNCTION__));
                 for( int i = 0; i < SDP_PARALLEL_PROC_NUM; i++) {
                     payload_data_ptr[(atom_iter%2)*ATOM_CUBE_SIZE + channel_iter*SDP_PARALLEL_PROC_NUM + i] =
                         static_cast<int8_t>(dma_write_data_ptr[i]);
@@ -2107,11 +2107,11 @@ void NV_NVDLA_sdp::SendDmaWriteRequest(uint64_t payload_addr, uint32_t payload_s
             // Send write data (64B)
             if ( (atom_iter%2) == 1 ) {
                 SendDmaWriteRequest (dma_wr_req_data_payload_, dma_delay_);
-                cslDebug((70, "NV_NVDLA_sdp::SendDmaWriteRequest, dma_wr_req_data_payload_, atoms_sent=%d\n", atom_iter+1));
+                //cslDebug((70, "NV_NVDLA_sdp::SendDmaWriteRequest, dma_wr_req_data_payload_, atoms_sent=%d\n", atom_iter+1));
                 for(i=0;i<64;i++) {
-                    cslDebug((70, "0x%x ", (unsigned int)payload_data_ptr[i]));
+                    //cslDebug((70, "0x%x ", (unsigned int)payload_data_ptr[i]));
                 }
-                cslDebug((70, "\n"));
+                //cslDebug((70, "\n"));
             }
         }
         ptr = reinterpret_cast<uint8_t *>(payload_data_ptr);
@@ -2120,18 +2120,18 @@ void NV_NVDLA_sdp::SendDmaWriteRequest(uint64_t payload_addr, uint32_t payload_s
             int16_t *payload_data_ptr;
             payload_data_ptr = reinterpret_cast <int16_t *>  (dma_wr_req_data_payload_->pd.dma_write_data.data);
             for (atom_iter = 0; atom_iter < payload_atom_num; atom_iter++) {
-                cslDebug((70, "%s: before read wdma_fifo\n", __FUNCTION__));
+                //cslDebug((70, "%s: before read wdma_fifo\n", __FUNCTION__));
                 dma_write_data_ptr = wdma_fifo_->read();    //16*32bits(64B)
-                cslDebug((70, "%s: after read wdma_fifo\n", __FUNCTION__));
+                //cslDebug((70, "%s: after read wdma_fifo\n", __FUNCTION__));
                 memcpy (&payload_data_ptr[SDP_PARALLEL_PROC_NUM*(atom_iter%2)], dma_write_data_ptr, ATOM_CUBE_SIZE);
                 // Send write data (64B)
                 if ( (atom_iter%2) == 1 ) {
                     SendDmaWriteRequest (dma_wr_req_data_payload_, dma_delay_);
-                    cslDebug((70, "NV_NVDLA_sdp::SendDmaWriteRequest, dma_wr_req_data_payload_, atoms_sent=%d\n", atom_iter+1));
+                    //cslDebug((70, "NV_NVDLA_sdp::SendDmaWriteRequest, dma_wr_req_data_payload_, atoms_sent=%d\n", atom_iter+1));
                     for(i=0;i<32;i++) {
-                        cslDebug((70, "0x%x ", (unsigned int)payload_data_ptr[i]));
+                        //cslDebug((70, "0x%x ", (unsigned int)payload_data_ptr[i]));
                     }
-                    cslDebug((70, "\n"));
+                    //cslDebug((70, "\n"));
                 }
                 delete [] dma_write_data_ptr;
             }
@@ -2141,9 +2141,9 @@ void NV_NVDLA_sdp::SendDmaWriteRequest(uint64_t payload_addr, uint32_t payload_s
             //cslAssert(payload_atom_num <= 2);
             for (atom_iter = 0; atom_iter < payload_atom_num; atom_iter++) {
                 for(int surf_internal_iter = 0; surf_internal_iter < 2; surf_internal_iter++) {
-                    cslDebug((70, "%s: before read wdma_fifo\n", __FUNCTION__));
+                    //cslDebug((70, "%s: before read wdma_fifo\n", __FUNCTION__));
                     dma_write_data_ptr = wdma_fifo_->read();    //16*2(32B)
-                    cslDebug((70, "%s: after read wdma_fifo\n", __FUNCTION__));
+                    //cslDebug((70, "%s: after read wdma_fifo\n", __FUNCTION__));
                     memcpy (sdp_internal_buf_[0] + surf_internal_iter*DMA_TRANSACTION_SIZE + atom_iter*ATOM_CUBE_SIZE,
                             dma_write_data_ptr, ATOM_CUBE_SIZE);
 
@@ -2160,19 +2160,19 @@ void NV_NVDLA_sdp::SendDmaWriteRequest(uint64_t payload_addr, uint32_t payload_s
                 // WaitUntilWdmaBufferAvailableSizeGreaterThan(payload_atom_num);
                 // Send write command
 #pragma CTC SKIP
-                cslDebug((50, "NV_NVDLA_sdp::SendDmaWriteRequest addr=0x%lx payload_atom_num=%d\n",
-                            dma_wr_req_cmd_payload_->pd.dma_write_cmd.addr, payload_atom_num));
+                //cslDebug((50, "NV_NVDLA_sdp::SendDmaWriteRequest addr=0x%lx payload_atom_num=%d\n",
+                //            dma_wr_req_cmd_payload_->pd.dma_write_cmd.addr, payload_atom_num));
 #pragma CTC ENDSKIP
                 SendDmaWriteRequest(dma_wr_req_cmd_payload_, dma_delay_, ack_required && (surf_internal_iter == 1));
                 SendDmaWriteRequest (dma_wr_req_data_payload_, dma_delay_);
-                cslDebug((50, "%s send payload success\n", __FUNCTION__));
+                //cslDebug((50, "%s send payload success\n", __FUNCTION__));
             }
         }
     }
     // payload_atom_num is a odd number
     if ( (payload_atom_num%2) == 1 && (!is_int8_to_int16)) {
         // Fill the last 32 byte with 0
-        cslDebug((30, "%s filling 0s to last invalid atom\n", __FUNCTION__));
+        //cslDebug((30, "%s filling 0s to last invalid atom\n", __FUNCTION__));
         memset (&ptr[ATOM_CUBE_SIZE], 0, ATOM_CUBE_SIZE);
         SendDmaWriteRequest (dma_wr_req_data_payload_, dma_delay_);
     }
@@ -2181,12 +2181,12 @@ void NV_NVDLA_sdp::SendDmaWriteRequest(uint64_t payload_addr, uint32_t payload_s
         ack_info *ack = new ack_info;
         ack->is_mc = sdp_dst_ram_type_ == NVDLA_SDP_D_DST_DMA_CFG_0_DST_RAM_TYPE_MC;
         ack->group_id = sdp_consumer_;
-        cslDebug((30, "%s: notify write complete on group:%d, is_mc:%d\n",
-                    __FUNCTION__, sdp_consumer_, ack->is_mc));
+        //cslDebug((30, "%s: notify write complete on group:%d, is_mc:%d\n",
+        //            __FUNCTION__, sdp_consumer_, ack->is_mc));
         sdp_ack_fifo_->write(ack);
         sdp_done_.notify();
     }
-    cslDebug((70, "exit:%s\n", __FUNCTION__));
+    //cslDebug((70, "exit:%s\n", __FUNCTION__));
 }
 
 void NV_NVDLA_sdp::SendDmaWriteRequest(nvdla_dma_wr_req_t* payload, sc_time& delay, bool ack_required) {
@@ -2207,9 +2207,9 @@ void NV_NVDLA_sdp::SendDmaWriteRequest(nvdla_dma_wr_req_t* payload, sc_time& del
                 payload->pd.dma_write_cmd.require_ack = 0;
             }
         }
-        cslDebug((70, "before: sdp2cvif_wr_req_b_transport\n"));
+        //cslDebug((70, "before: sdp2cvif_wr_req_b_transport\n"));
         sdp2cvif_wr_req_b_transport(payload, dma_delay_);
-        cslDebug((70, "after: sdp2cvif_wr_req_b_transport\n"));
+        //cslDebug((70, "after: sdp2cvif_wr_req_b_transport\n"));
     }
 }
 
@@ -2223,11 +2223,11 @@ void NV_NVDLA_sdp::write_lut() {
 }
 
 void NV_NVDLA_sdp::WriteResponseThreadMc() {
-    cslDebug((50, "NV_NVDLA_sdp::WriteResponseThreadMc is called\n"));
+    //cslDebug((50, "NV_NVDLA_sdp::WriteResponseThreadMc is called\n"));
     if ( true == mcif2sdp_wr_rsp.read() ) {
         is_mc_ack_done_ = true;
         sdp_mc_ack_.notify();
-        cslDebug((50, "NV_NVDLA_sdp::WriteResponseThreadMc, sent sdp_done notification\n"));
+        //cslDebug((50, "NV_NVDLA_sdp::WriteResponseThreadMc, sent sdp_done notification\n"));
     }
 }
 
@@ -2235,7 +2235,7 @@ void NV_NVDLA_sdp::WriteResponseThreadCv() {
     if ( true == cvif2sdp_wr_rsp.read() ) {
         is_cv_ack_done_ = true;
         sdp_cv_ack_.notify();
-        cslDebug((50, "NV_NVDLA_sdp::WriteResponseThreadCv, sent sdp_done notification\n"));
+        //cslDebug((50, "NV_NVDLA_sdp::WriteResponseThreadCv, sent sdp_done notification\n"));
     }
 }
 
diff --git a/cmod/sdp/gen/sdp_rdma_reg_model.cpp b/cmod/sdp/gen/sdp_rdma_reg_model.cpp
index 30bb0b8..a38b67d 100644
--- a/cmod/sdp/gen/sdp_rdma_reg_model.cpp
+++ b/cmod/sdp/gen/sdp_rdma_reg_model.cpp
@@ -85,7 +85,7 @@ bool sdp_rdma_reg_model::SdpRdmaAccessRegister(uint32_t reg_addr, uint32_t & dat
                 sdp_rdma_register_group_0->SetWritable(offset, data);
                 if (sdp_rdma_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_sdp_rdma_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "sdp_rdma_reg_model::SdpRdmaAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "sdp_rdma_reg_model::SdpRdmaAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -97,7 +97,7 @@ bool sdp_rdma_reg_model::SdpRdmaAccessRegister(uint32_t reg_addr, uint32_t & dat
                 sdp_rdma_register_group_1->SetWritable(offset, data);
                 if (sdp_rdma_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_sdp_rdma_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "sdp_rdma_reg_model::SdpRdmaAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "sdp_rdma_reg_model::SdpRdmaAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/cmod/sdp/gen/sdp_reg_model.cpp b/cmod/sdp/gen/sdp_reg_model.cpp
index 117d26e..db5cbd2 100644
--- a/cmod/sdp/gen/sdp_reg_model.cpp
+++ b/cmod/sdp/gen/sdp_reg_model.cpp
@@ -88,7 +88,7 @@ bool sdp_reg_model::SdpAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 sdp_register_group_0->SetWritable(offset, data);
                 if (sdp_register_group_0->rD_OP_ENABLE.uOP_EN()) {
                     event_sdp_reg_group_0_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "sdp_reg_model::SdpAccessRegister, notified op_en for group 0.\x0A"));
+                    //cslDebug((30, "sdp_reg_model::SdpAccessRegister, notified op_en for group 0.\x0A"));
                 }
             } else {
                 // The invertion of valid bit served as write enable
@@ -100,7 +100,7 @@ bool sdp_reg_model::SdpAccessRegister(uint32_t reg_addr, uint32_t & data, bool i
                 sdp_register_group_1->SetWritable(offset, data);
                 if (sdp_register_group_1->rD_OP_ENABLE.uOP_EN()) {
                     event_sdp_reg_group_1_operation_enable.notify(SC_ZERO_TIME);
-                    cslDebug((30, "sdp_reg_model::SdpAccessRegister, notified op_en for group 1.\x0A"));
+                    //cslDebug((30, "sdp_reg_model::SdpAccessRegister, notified op_en for group 1.\x0A"));
                 }
             }
         } else { // Registers which have only one entity
diff --git a/verif/traces/traceplayer/cc_alexnet_conv5_relu5_int16_dtest_cvsram/input.txn b/verif/traces/traceplayer/cc_alexnet_conv5_relu5_int16_dtest_cvsram/input.txn
index a5d574b..8e704de 100644
--- a/verif/traces/traceplayer/cc_alexnet_conv5_relu5_int16_dtest_cvsram/input.txn
+++ b/verif/traces/traceplayer/cc_alexnet_conv5_relu5_int16_dtest_cvsram/input.txn
@@ -183,7 +183,7 @@ read_reg 0xffff1400 0x00030003 0x00000000 #NVDLA_CDMA.S_STATUS_0
 write_reg 0xffff1416 0x0 #NVDLA_CDMA.D_BATCH_NUMBER_0
 read_reg 0xffff1416 0x0000001f 0x00000000 #NVDLA_CDMA.D_BATCH_NUMBER_0
 write_reg 0xffff1403 0x0 #NVDLA_CDMA.S_CBUF_FLUSH_STATUS_0
-read_reg 0xffff1403 0x00000001 0x00000000 #NVDLA_CDMA.S_CBUF_FLUSH_STATUS_0
+read_reg 0xffff1403 0x00000001 0x00000001 #NVDLA_CDMA.S_CBUF_FLUSH_STATUS_0
 write_reg 0xffff141a 0x0 #NVDLA_CDMA.D_WEIGHT_FORMAT_0
 read_reg 0xffff141a 0x00000001 0x00000000 #NVDLA_CDMA.D_WEIGHT_FORMAT_0
 write_reg 0xffff143a 0x7841af46 #NVDLA_CDMA.D_CYA_0
diff --git a/verif/traces/traceplayer/conv_8x8_fc_int16/input.txn b/verif/traces/traceplayer/conv_8x8_fc_int16/input.txn
index c867edc..d889e81 100644
--- a/verif/traces/traceplayer/conv_8x8_fc_int16/input.txn
+++ b/verif/traces/traceplayer/conv_8x8_fc_int16/input.txn
@@ -1,7 +1,7 @@
 # load_mem(addr, offset,  file)
 # write_reg(reg_addr, reg_data, misc_bits)
-load_mem 0x80000000 0x1000 input_feature_map.dat #0x1000 (4KB)  8*8*32*2
-load_mem 0x80100000 0x10000 input_weight.dat #0x2400(18KB)  16 kernels, each kernel is 3*3*32*2
+load_mem 0xc0000000 0x1000 input_feature_map.dat #0x1000 (4KB)  8*8*32*2
+load_mem 0xc0100000 0x10000 input_weight.dat #0x2400(18KB)  16 kernels, each kernel is 3*3*32*2
 write_reg 0xffff1401 0x0 #NVDLA_CDMA.S_POINTER_0CONSUMER: GROUP_0, PRODUCER: GROUP_0
 read_reg 0xffff1401 0x00010001 0x00000000 #NVDLA_CDMA.S_POINTER_0CONSUMER: GROUP_0, PRODUCER: GROUP_0
 write_reg 0xffff1402 0x3000f #NVDLA_CDMA.S_ARBITER_0ARB_WEIGHT=15, ARB_WMB=3
@@ -20,8 +20,8 @@ write_reg 0xffff140b 0x1 #NVDLA_CDMA.D_DAIN_RAM_TYPE_0MC
 read_reg 0xffff140b 0x00000001 0x00000001 #NVDLA_CDMA.D_DAIN_RAM_TYPE_0MC
 write_reg 0xffff140c 0x0 #NVDLA_CDMA.D_DAIN_ADDR_HIGH_0_0
 read_reg 0xffff140c 0x000000ff 0x00000000 #NVDLA_CDMA.D_DAIN_ADDR_HIGH_0_0
-write_reg 0xffff140d 0x80000000 #NVDLA_CDMA.D_DAIN_ADDR_LOW_0_00MB
-read_reg 0xffff140d 0xffffffe0 0x80000000 #NVDLA_CDMA.D_DAIN_ADDR_LOW_0_00MB
+write_reg 0xffff140d 0xc0000000 #NVDLA_CDMA.D_DAIN_ADDR_LOW_0_00MB
+read_reg 0xffff140d 0xffffffe0 0xc0000000 #NVDLA_CDMA.D_DAIN_ADDR_LOW_0_00MB
 write_reg 0xffff140e 0x0 #NVDLA_CDMA.D_DAIN_ADDR_HIGH_1_0
 read_reg 0xffff140e 0x000000ff 0x00000000 #NVDLA_CDMA.D_DAIN_ADDR_HIGH_1_0
 write_reg 0xffff140f 0x0 #NVDLA_CDMA.D_DAIN_ADDR_LOW_1_0
@@ -50,8 +50,8 @@ write_reg 0xffff141d 0x1 #NVDLA_CDMA.D_WEIGHT_RAM_TYPE_0MC
 read_reg 0xffff141d 0x00000001 0x00000001 #NVDLA_CDMA.D_WEIGHT_RAM_TYPE_0MC
 write_reg 0xffff141e 0x0 #NVDLA_CDMA.D_WEIGHT_ADDR_HIGH_0
 read_reg 0xffff141e 0x000000ff 0x00000000 #NVDLA_CDMA.D_WEIGHT_ADDR_HIGH_0
-write_reg 0xffff141f 0x80100000 #NVDLA_CDMA.D_WEIGHT_ADDR_LOW_01MB
-read_reg 0xffff141f 0xffffffe0 0x80100000 #NVDLA_CDMA.D_WEIGHT_ADDR_LOW_01MB
+write_reg 0xffff141f 0xc0100000 #NVDLA_CDMA.D_WEIGHT_ADDR_LOW_01MB
+read_reg 0xffff141f 0xffffffe0 0xc0100000 #NVDLA_CDMA.D_WEIGHT_ADDR_LOW_01MB
 write_reg 0xffff1420 0x10000 #NVDLA_CDMA.D_WEIGHT_BYTES_0
 read_reg 0xffff1420 0xffffff80 0x00010000 #NVDLA_CDMA.D_WEIGHT_BYTES_0
 write_reg 0xffff1421 0x0 #NVDLA_CDMA.D_WGS_ADDR_HIGH_0
@@ -138,8 +138,8 @@ write_reg 0xffff2404 0x0 #NVDLA_CACC.D_DATAOUT_SIZE_0_0
 read_reg 0xffff2404 0x1fff1fff 0x00000000 #NVDLA_CACC.D_DATAOUT_SIZE_0_0
 write_reg 0xffff2405 0xf #NVDLA_CACC.D_DATAOUT_SIZE_1_0
 read_reg 0xffff2405 0x00001fff 0x0000000f #NVDLA_CACC.D_DATAOUT_SIZE_1_0
-write_reg 0xffff2406 0x80400000 #NVDLA_CACC.D_DATAOUT_ADDR_0
-read_reg 0xffff2406 0xffffffe0 0x80400000 #NVDLA_CACC.D_DATAOUT_ADDR_0
+write_reg 0xffff2406 0xc0400000 #NVDLA_CACC.D_DATAOUT_ADDR_0
+read_reg 0xffff2406 0xffffffe0 0xc0400000 #NVDLA_CACC.D_DATAOUT_ADDR_0
 write_reg 0xffff2407 0x0 #NVDLA_CACC.D_BATCH_NUMBER_0
 read_reg 0xffff2407 0x0000001f 0x00000000 #NVDLA_CACC.D_BATCH_NUMBER_0
 write_reg 0xffff2408 0x20 #NVDLA_CACC.D_LINE_STRIDE_0
@@ -172,8 +172,8 @@ write_reg 0xffff2c10 0x0 #NVDLA_SDP.D_DATA_CUBE_HEIGHT_0
 read_reg 0xffff2c10 0x00001fff 0x00000000 #NVDLA_SDP.D_DATA_CUBE_HEIGHT_0
 write_reg 0xffff2c11 0xf #NVDLA_SDP.D_DATA_CUBE_CHANNEL_0
 read_reg 0xffff2c11 0x00001fff 0x0000000f #NVDLA_SDP.D_DATA_CUBE_CHANNEL_0
-write_reg 0xffff2c12 0x80400000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_04MB
-read_reg 0xffff2c12 0xffffffe0 0x80400000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_04MB
+write_reg 0xffff2c12 0xc0400000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_04MB
+read_reg 0xffff2c12 0xffffffe0 0xc0400000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_04MB
 write_reg 0xffff2c13 0x0 #NVDLA_SDP.D_DST_BASE_ADDR_HIGH_0
 read_reg 0xffff2c13 0x000000ff 0x00000000 #NVDLA_SDP.D_DST_BASE_ADDR_HIGH_0
 write_reg 0xffff2c14 0x20 #NVDLA_SDP.D_DST_LINE_STRIDE_0
@@ -238,4 +238,4 @@ wait
 read_reg 0xffff0003 0x00000001 0x00000001 #NVDLA_GLB.S_INTR_STATUS_0.SDP_DONE_STATUS0mask #data
 write_reg 0xffff0003 0xffffffff #NVDLA_GLB.S_INTR_STATUS_0clear interrupts
 read_reg 0xffff0003 0x00000001 0x00000000 #NVDLA_GLB.S_INTR_STATUS_0.CDMA_DAT_DONE_STATUS0mask #data
-dump_mem 0x80400000 0x20 output_feature_map.dat
+dump_mem 0xc0400000 0x20 output_feature_map.dat
diff --git a/verif/traces/traceplayer/conv_8x8_fc_int16/output_feature_map.dat b/verif/traces/traceplayer/conv_8x8_fc_int16/output_feature_map.dat
index 55c15f0..505219e 100644
--- a/verif/traces/traceplayer/conv_8x8_fc_int16/output_feature_map.dat
+++ b/verif/traces/traceplayer/conv_8x8_fc_int16/output_feature_map.dat
@@ -1,4 +1,4 @@
-dumped memory,start_address=0x80400000 size=0x20
+dumped memory,start_address=0xc0400000 size=0x20
 memory type:dram
 ==============================
 
diff --git a/verif/traces/traceplayer/googlenet_conv2_3x3_int16/input.txn b/verif/traces/traceplayer/googlenet_conv2_3x3_int16/input.txn
index bf56ddf..d3f126c 100644
--- a/verif/traces/traceplayer/googlenet_conv2_3x3_int16/input.txn
+++ b/verif/traces/traceplayer/googlenet_conv2_3x3_int16/input.txn
@@ -132,7 +132,7 @@ read_reg 0xffff141d 0x00000001 0x00000000 #NVDLA_CDMA.D_WEIGHT_RAM_TYPE_0
 write_reg 0xffff1439 0x0 #NVDLA_CDMA.D_PERF_WT_READ_LATENCY_0
 read_reg 0xffff1439 0xffffffff 0x00000000 #NVDLA_CDMA.D_PERF_WT_READ_LATENCY_0
 write_reg 0xffff1403 0x0 #NVDLA_CDMA.S_CBUF_FLUSH_STATUS_0
-read_reg 0xffff1403 0x00000001 0x00000000 #NVDLA_CDMA.S_CBUF_FLUSH_STATUS_0
+read_reg 0xffff1403 0x00000001 0x00000001 #NVDLA_CDMA.S_CBUF_FLUSH_STATUS_0
 write_reg 0xffff1437 0x0 #NVDLA_CDMA.D_PERF_WT_READ_STALL_0
 read_reg 0xffff1437 0xffffffff 0x00000000 #NVDLA_CDMA.D_PERF_WT_READ_STALL_0
 write_reg 0xffff1422 0x92eabbc0 #NVDLA_CDMA.D_WGS_ADDR_LOW_0
diff --git a/verif/traces/traceplayer/pdp_max_pooling_int16/input.txn b/verif/traces/traceplayer/pdp_max_pooling_int16/input.txn
index 717da37..975dfec 100644
--- a/verif/traces/traceplayer/pdp_max_pooling_int16/input.txn
+++ b/verif/traces/traceplayer/pdp_max_pooling_int16/input.txn
@@ -56,17 +56,17 @@ write_reg 0xffff3405 0x3f #NVDLA_PDP.D_DATA_CUBE_IN_CHANNEL_0
 read_reg 0xffff3405 0x00001fff 0x0000003f #NVDLA_PDP.D_DATA_CUBE_IN_CHANNEL_0
 write_reg 0xffff3005 0x3f #NVDLA_PDP_RDMA.D_DATA_CUBE_IN_CHANNEL_0
 read_reg 0xffff3005 0x00001fff 0x0000003f #NVDLA_PDP_RDMA.D_DATA_CUBE_IN_CHANNEL_0
-load_mem 0x80000000 0x2000 input_feature_map.dat 
-write_reg 0xffff3007 0x80000000 #NVDLA_PDP_RDMA.D_SRC_BASE_ADDR_LOW_0
-read_reg 0xffff3007 0xffffffe0 0x80000000 #NVDLA_PDP_RDMA.D_SRC_BASE_ADDR_LOW_0
+load_mem 0xc0000000 0x2000 input_feature_map.dat
+write_reg 0xffff3007 0xc0000000 #NVDLA_PDP_RDMA.D_SRC_BASE_ADDR_LOW_0
+read_reg 0xffff3007 0xffffffe0 0xc0000000 #NVDLA_PDP_RDMA.D_SRC_BASE_ADDR_LOW_0
 write_reg 0xffff3008 0x0 #NVDLA_PDP_RDMA.D_SRC_BASE_ADDR_HIGH_0
 read_reg 0xffff3008 0xffffffff 0x00000000 #NVDLA_PDP_RDMA.D_SRC_BASE_ADDR_HIGH_0
-write_reg 0xffff3418 0x80000000 #NVDLA_PDP.D_SRC_BASE_ADDR_LOW_0
-read_reg 0xffff3418 0xffffffe0 0x80000000 #NVDLA_PDP.D_SRC_BASE_ADDR_LOW_0
+write_reg 0xffff3418 0xc0000000 #NVDLA_PDP.D_SRC_BASE_ADDR_LOW_0
+read_reg 0xffff3418 0xffffffe0 0xc0000000 #NVDLA_PDP.D_SRC_BASE_ADDR_LOW_0
 write_reg 0xffff3419 0x0 #NVDLA_PDP.D_SRC_BASE_ADDR_HIGH_0
 read_reg 0xffff3419 0xffffffff 0x00000000 #NVDLA_PDP.D_SRC_BASE_ADDR_HIGH_0
-write_reg 0xffff341c 0x80100000 #NVDLA_PDP.D_DST_BASE_ADDR_LOW_0
-read_reg 0xffff341c 0xffffffe0 0x80100000 #NVDLA_PDP.D_DST_BASE_ADDR_LOW_0
+write_reg 0xffff341c 0xc0100000 #NVDLA_PDP.D_DST_BASE_ADDR_LOW_0
+read_reg 0xffff341c 0xffffffe0 0xc0100000 #NVDLA_PDP.D_DST_BASE_ADDR_LOW_0
 write_reg 0xffff341d 0x0 #NVDLA_PDP.D_DST_BASE_ADDR_HIGH_0
 read_reg 0xffff341d 0xffffffff 0x00000000 #NVDLA_PDP.D_DST_BASE_ADDR_HIGH_0
 write_reg 0xffff3002 0x1 #NVDLA_PDP_RDMA.D_OP_ENABLE_0
@@ -75,4 +75,4 @@ write_reg 0xffff3402 0x1 #NVDLA_PDP.D_OP_ENABLE_0
 read_reg 0xffff3402 0x00000001 0x00000001 #NVDLA_PDP.D_OP_ENABLE_0
 wait
 write_reg 0xffff0003 0xffffffff #NVDLA_GLB.S_INTR_STATUS_0
-dump_mem 0x80100000 0x1880 output_feature_map.dat 
+dump_mem 0xc0100000 0x1880 output_feature_map.dat
diff --git a/verif/traces/traceplayer/pdp_max_pooling_int16/output_feature_map.dat b/verif/traces/traceplayer/pdp_max_pooling_int16/output_feature_map.dat
index 2e3c15d..25be0f9 100644
--- a/verif/traces/traceplayer/pdp_max_pooling_int16/output_feature_map.dat
+++ b/verif/traces/traceplayer/pdp_max_pooling_int16/output_feature_map.dat
@@ -1,4 +1,4 @@
-dumped memory,start_address=0x80100000 size=0x1880
+dumped memory,start_address=0xc0100000 size=0x1880
 memory type:dram
 ==============================
 
diff --git a/verif/traces/traceplayer/sanity1/input.txn b/verif/traces/traceplayer/sanity1/input.txn
index e2d4730..8031da9 100644
--- a/verif/traces/traceplayer/sanity1/input.txn
+++ b/verif/traces/traceplayer/sanity1/input.txn
@@ -1,6 +1,6 @@
 # load_mem(addr, offset,  file)
 # write_reg(reg_addr, reg_data, misc_bits)
-load_mem 0x80000000 0x1000 sample_surf.dat 
+load_mem 0xc0000000 0x1000 sample_surf.dat
 write_reg 0xffff100b 0x800 #NVDLA_BDMA.CFG_DST_SURF_0
 read_reg 0xffff100b 0xffffffe0 0x00000800 #NVDLA_BDMA.CFG_DST_SURF_0
 write_reg 0xffff1008 0x100 #NVDLA_BDMA.CFG_DST_LINE_0
@@ -19,12 +19,12 @@ write_reg 0xffff1005 0x3 #NVDLA_BDMA.CFG_CMD_0
 read_reg 0xffff1005 0x00000003 0x00000003 #NVDLA_BDMA.CFG_CMD_0
 write_reg 0xffff1001 0x0 #NVDLA_BDMA.CFG_SRC_ADDR_HIGH_080000000>>32=0x0
 read_reg 0xffff1001 0x000000ff 0x00000000 #NVDLA_BDMA.CFG_SRC_ADDR_HIGH_080000000>>32=0x0
-write_reg 0xffff1000 0x80000000 #NVDLA_BDMA.CFG_SRC_ADDR_LOW_080000000&32'b1=0x8000
-read_reg 0xffff1000 0xffffffe0 0x80000000 #NVDLA_BDMA.CFG_SRC_ADDR_LOW_080000000&32'b1=0x8000
+write_reg 0xffff1000 0xc0000000 #NVDLA_BDMA.CFG_SRC_ADDR_LOW_0c0000000&32'b1=0xc000
+read_reg 0xffff1000 0xffffffe0 0xc0000000 #NVDLA_BDMA.CFG_SRC_ADDR_LOW_080000000&32'b1=0xc000
 write_reg 0xffff1003 0x0 #NVDLA_BDMA.CFG_DST_ADDR_HIGH_081000000>>32=0x0
 read_reg 0xffff1003 0x000000ff 0x00000000 #NVDLA_BDMA.CFG_DST_ADDR_HIGH_081000000>>32=0x0
-write_reg 0xffff1002 0x81000000 #NVDLA_BDMA.CFG_DST_ADDR_LOW_081000000&32'b1=0x8100
-read_reg 0xffff1002 0xffffffe0 0x81000000 #NVDLA_BDMA.CFG_DST_ADDR_LOW_081000000&32'b1=0x8100
+write_reg 0xffff1002 0xc1000000 #NVDLA_BDMA.CFG_DST_ADDR_LOW_0c1000000&32'b1=0xc100
+read_reg 0xffff1002 0xffffffe0 0xc1000000 #NVDLA_BDMA.CFG_DST_ADDR_LOW_081000000&32'b1=0xc100
 write_reg 0xffff100c 0x1 #NVDLA_BDMA.CFG_OP_0
 read_reg 0xffff100c 0x00000001 0x00000001 #NVDLA_BDMA.CFG_OP_0
 write_reg 0xffff100d 0x1 #NVDLA_BDMA.CFG_LAUNCH0_0
diff --git a/verif/traces/traceplayer/sanity2/input.txn b/verif/traces/traceplayer/sanity2/input.txn
index 3ea26e9..5c442bc 100644
--- a/verif/traces/traceplayer/sanity2/input.txn
+++ b/verif/traces/traceplayer/sanity2/input.txn
@@ -1,6 +1,6 @@
 # load_mem(addr, offset,  file)
 # write_reg(reg_addr, reg_data, misc_bits)
-load_mem 0x80000000 0x1000 sample_surf.dat 
+load_mem 0xc0000000 0x1000 sample_surf.dat
 write_reg 0xffff100b 0x800 #NVDLA_BDMA.CFG_DST_SURF_0
 read_reg 0xffff100b 0xffffffe0 0x00000800 #NVDLA_BDMA.CFG_DST_SURF_0
 write_reg 0xffff1008 0x100 #NVDLA_BDMA.CFG_DST_LINE_0
@@ -17,14 +17,14 @@ write_reg 0xffff1004 0x7 #NVDLA_BDMA.CFG_LINE_0
 read_reg 0xffff1004 0x00001fff 0x00000007 #NVDLA_BDMA.CFG_LINE_0
 write_reg 0xffff1005 0x3 #NVDLA_BDMA.CFG_CMD_0
 read_reg 0xffff1005 0x00000003 0x00000003 #NVDLA_BDMA.CFG_CMD_0
-write_reg 0xffff1001 0x0 #NVDLA_BDMA.CFG_SRC_ADDR_HIGH_080000000>>32=0x0
-read_reg 0xffff1001 0x000000ff 0x00000000 #NVDLA_BDMA.CFG_SRC_ADDR_HIGH_080000000>>32=0x0
-write_reg 0xffff1000 0x80000000 #NVDLA_BDMA.CFG_SRC_ADDR_LOW_080000000&32'b1=0x8000
-read_reg 0xffff1000 0xffffffe0 0x80000000 #NVDLA_BDMA.CFG_SRC_ADDR_LOW_080000000&32'b1=0x8000
-write_reg 0xffff1003 0x0 #NVDLA_BDMA.CFG_DST_ADDR_HIGH_081000000>>32=0x0
-read_reg 0xffff1003 0x000000ff 0x00000000 #NVDLA_BDMA.CFG_DST_ADDR_HIGH_081000000>>32=0x0
-write_reg 0xffff1002 0x81000000 #NVDLA_BDMA.CFG_DST_ADDR_LOW_081000000&32'b1=0x8100
-read_reg 0xffff1002 0xffffffe0 0x81000000 #NVDLA_BDMA.CFG_DST_ADDR_LOW_081000000&32'b1=0x8100
+write_reg 0xffff1001 0x0 #NVDLA_BDMA.CFG_SRC_ADDR_HIGH_0c0000000>>32=0x0
+read_reg 0xffff1001 0x000000ff 0x00000000 #NVDLA_BDMA.CFG_SRC_ADDR_HIGH_0c0000000>>32=0x0
+write_reg 0xffff1000 0xc0000000 #NVDLA_BDMA.CFG_SRC_ADDR_LOW_080000000&32'b1=0xc000
+read_reg 0xffff1000 0xffffffe0 0xc0000000 #NVDLA_BDMA.CFG_SRC_ADDR_LOW_0c0000000&32'b1=0xc000
+write_reg 0xffff1003 0x0 #NVDLA_BDMA.CFG_DST_ADDR_HIGH_0c1000000>>32=0x0
+read_reg 0xffff1003 0x000000ff 0x00000000 #NVDLA_BDMA.CFG_DST_ADDR_HIGH_0c1000000>>32=0x0
+write_reg 0xffff1002 0xc1000000 #NVDLA_BDMA.CFG_DST_ADDR_LOW_0c1000000&32'b1=0xc100
+read_reg 0xffff1002 0xffffffe0 0xc1000000 #NVDLA_BDMA.CFG_DST_ADDR_LOW_0c1000000&32'b1=0xc100
 write_reg 0xffff100c 0x1 #NVDLA_BDMA.CFG_OP_0
 read_reg 0xffff100c 0x00000001 0x00000001 #NVDLA_BDMA.CFG_OP_0
 write_reg 0xffff100d 0x1 #NVDLA_BDMA.CFG_LAUNCH0_0
diff --git a/verif/traces/traceplayer/sanity3/golden_output_memory.dat b/verif/traces/traceplayer/sanity3/golden_output_memory.dat
index 55c15f0..505219e 100644
--- a/verif/traces/traceplayer/sanity3/golden_output_memory.dat
+++ b/verif/traces/traceplayer/sanity3/golden_output_memory.dat
@@ -1,4 +1,4 @@
-dumped memory,start_address=0x80400000 size=0x20
+dumped memory,start_address=0xc0400000 size=0x20
 memory type:dram
 ==============================
 
diff --git a/verif/traces/traceplayer/sanity3/input.txn b/verif/traces/traceplayer/sanity3/input.txn
index 2b31af7..ee78f0c 100644
--- a/verif/traces/traceplayer/sanity3/input.txn
+++ b/verif/traces/traceplayer/sanity3/input.txn
@@ -1,7 +1,7 @@
 # load_mem(addr, offset,  file)
 # write_reg(reg_addr, reg_data, misc_bits)
-load_mem 0x80000000 0x00001000 sample_surf.dat #0x1000 (4KB)  8*8*32*2
-load_mem 0x80100000 0x00010000 weight.dat #0x2400(18KB)  16 kernels, each kernel is 3*3*32*2
+load_mem 0xc0000000 0x00001000 sample_surf.dat #0x1000 (4KB)  8*8*32*2
+load_mem 0xc0100000 0x00010000 weight.dat #0x2400(18KB)  16 kernels, each kernel is 3*3*32*2
 write_reg 0xffff1401 0x0 #NVDLA_CDMA.S_POINTER_0CONSUMER: GROUP_0, PRODUCER: GROUP_0
 read_reg 0xffff1401 0xffffffff 0x00000000 #NVDLA_CDMA.S_POINTER_0CONSUMER: GROUP_0, PRODUCER: GROUP_0
 write_reg 0xffff1402 0x3000f #NVDLA_CDMA.S_ARBITER_0ARB_WEIGHT=15, ARB_WMB=3
@@ -20,8 +20,8 @@ write_reg 0xffff140b 0x1 #NVDLA_CDMA.D_DAIN_RAM_TYPE_0MC
 read_reg 0xffff140b 0xffffffff 0x00000001 #NVDLA_CDMA.D_DAIN_RAM_TYPE_0MC
 write_reg 0xffff140c 0x0 #NVDLA_CDMA.D_DAIN_ADDR_HIGH_0_0
 read_reg 0xffff140c 0xffffffff 0x00000000 #NVDLA_CDMA.D_DAIN_ADDR_HIGH_0_0
-write_reg 0xffff140d 0x80000000 #NVDLA_CDMA.D_DAIN_ADDR_LOW_0_00MB
-read_reg 0xffff140d 0xffffffff 0x80000000 #NVDLA_CDMA.D_DAIN_ADDR_LOW_0_00MB
+write_reg 0xffff140d 0xc0000000 #NVDLA_CDMA.D_DAIN_ADDR_LOW_0_00MB
+read_reg 0xffff140d 0xffffffff 0xc0000000 #NVDLA_CDMA.D_DAIN_ADDR_LOW_0_00MB
 write_reg 0xffff140e 0x0 #NVDLA_CDMA.D_DAIN_ADDR_HIGH_1_0
 read_reg 0xffff140e 0xffffffff 0x00000000 #NVDLA_CDMA.D_DAIN_ADDR_HIGH_1_0
 write_reg 0xffff140f 0x0 #NVDLA_CDMA.D_DAIN_ADDR_LOW_1_0
@@ -50,8 +50,8 @@ write_reg 0xffff141d 0x1 #NVDLA_CDMA.D_WEIGHT_RAM_TYPE_0MC
 read_reg 0xffff141d 0xffffffff 0x00000001 #NVDLA_CDMA.D_WEIGHT_RAM_TYPE_0MC
 write_reg 0xffff141e 0x0 #NVDLA_CDMA.D_WEIGHT_ADDR_HIGH_0
 read_reg 0xffff141e 0xffffffff 0x00000000 #NVDLA_CDMA.D_WEIGHT_ADDR_HIGH_0
-write_reg 0xffff141f 0x80100000 #NVDLA_CDMA.D_WEIGHT_ADDR_LOW_01MB
-read_reg 0xffff141f 0xffffffff 0x80100000 #NVDLA_CDMA.D_WEIGHT_ADDR_LOW_01MB
+write_reg 0xffff141f 0xc0100000 #NVDLA_CDMA.D_WEIGHT_ADDR_LOW_01MB
+read_reg 0xffff141f 0xffffffff 0xc0100000 #NVDLA_CDMA.D_WEIGHT_ADDR_LOW_01MB
 write_reg 0xffff1420 0x10000 #NVDLA_CDMA.D_WEIGHT_BYTES_0
 read_reg 0xffff1420 0xffffffff 0x00010000 #NVDLA_CDMA.D_WEIGHT_BYTES_0
 write_reg 0xffff1421 0x0 #NVDLA_CDMA.D_WGS_ADDR_HIGH_0
@@ -138,8 +138,8 @@ write_reg 0xffff2404 0x0 #NVDLA_CACC.D_DATAOUT_SIZE_0_0
 read_reg 0xffff2404 0xffffffff 0x00000000 #NVDLA_CACC.D_DATAOUT_SIZE_0_0
 write_reg 0xffff2405 0xf #NVDLA_CACC.D_DATAOUT_SIZE_1_0
 read_reg 0xffff2405 0xffffffff 0x0000000f #NVDLA_CACC.D_DATAOUT_SIZE_1_0
-write_reg 0xffff2406 0x80400000 #NVDLA_CACC.D_DATAOUT_ADDR_0
-read_reg 0xffff2406 0xffffffff 0x80400000 #NVDLA_CACC.D_DATAOUT_ADDR_0
+write_reg 0xffff2406 0xc0400000 #NVDLA_CACC.D_DATAOUT_ADDR_0
+read_reg 0xffff2406 0xffffffff 0xc0400000 #NVDLA_CACC.D_DATAOUT_ADDR_0
 write_reg 0xffff2407 0x0 #NVDLA_CACC.D_BATCH_NUMBER_0
 read_reg 0xffff2407 0xffffffff 0x00000000 #NVDLA_CACC.D_BATCH_NUMBER_0
 write_reg 0xffff2408 0x20 #NVDLA_CACC.D_LINE_STRIDE_0
@@ -172,8 +172,8 @@ write_reg 0xffff2c10 0x0 #NVDLA_SDP.D_DATA_CUBE_HEIGHT_0
 read_reg 0xffff2c10 0xffffffff 0x00000000 #NVDLA_SDP.D_DATA_CUBE_HEIGHT_0
 write_reg 0xffff2c11 0xf #NVDLA_SDP.D_DATA_CUBE_CHANNEL_0
 read_reg 0xffff2c11 0xffffffff 0x0000000f #NVDLA_SDP.D_DATA_CUBE_CHANNEL_0
-write_reg 0xffff2c12 0x80400000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_04MB
-read_reg 0xffff2c12 0xffffffff 0x80400000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_04MB
+write_reg 0xffff2c12 0xc0400000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_04MB
+read_reg 0xffff2c12 0xffffffff 0xc0400000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_04MB
 write_reg 0xffff2c13 0x0 #NVDLA_SDP.D_DST_BASE_ADDR_HIGH_0
 read_reg 0xffff2c13 0xffffffff 0x00000000 #NVDLA_SDP.D_DST_BASE_ADDR_HIGH_0
 write_reg 0xffff2c14 0x20 #NVDLA_SDP.D_DST_LINE_STRIDE_0
@@ -234,4 +234,4 @@ read_reg 0xffff0003 0xffffffff 0x0
 wait
 write_reg 0xffff0003 0xffffffff #NVDLA_GLB.S_INTR_STATUS_0clear interrupts
 read_reg 0xffff0003 0xffffffff 0x0
-dump_mem 0x80400000 0x20 golden_output_memory.dat
+dump_mem 0xc0400000 0x20 golden_output_memory.dat
diff --git a/verif/traces/traceplayer/sdp_relu_int16/input.txn b/verif/traces/traceplayer/sdp_relu_int16/input.txn
index 4ca7927..ce44953 100644
--- a/verif/traces/traceplayer/sdp_relu_int16/input.txn
+++ b/verif/traces/traceplayer/sdp_relu_int16/input.txn
@@ -1,14 +1,14 @@
 # load_mem(addr, offset,  file)
 # write_reg(reg_addr, reg_data, misc_bits)
-load_mem 0x80200000 0x1000 input_feature_map.dat 
+load_mem 0xc0200000 0x1000 input_feature_map.dat
 write_reg 0xffff2803 0x7 #NVDLA_SDP_RDMA.D_DATA_CUBE_WIDTH_0
 read_reg 0xffff2803 0x00001fff 0x00000007 #NVDLA_SDP_RDMA.D_DATA_CUBE_WIDTH_0
 write_reg 0xffff2804 0x7 #NVDLA_SDP_RDMA.D_DATA_CUBE_HEIGHT_0
 read_reg 0xffff2804 0x00001fff 0x00000007 #NVDLA_SDP_RDMA.D_DATA_CUBE_HEIGHT_0
 write_reg 0xffff2805 0x1f #NVDLA_SDP_RDMA.D_DATA_CUBE_CHANNEL_0
 read_reg 0xffff2805 0x00001fff 0x0000001f #NVDLA_SDP_RDMA.D_DATA_CUBE_CHANNEL_0
-write_reg 0xffff2806 0x80200000 #NVDLA_SDP_RDMA.D_SRC_BASE_ADDR_LOW_0
-read_reg 0xffff2806 0xffffffe0 0x80200000 #NVDLA_SDP_RDMA.D_SRC_BASE_ADDR_LOW_0
+write_reg 0xffff2806 0xc0200000 #NVDLA_SDP_RDMA.D_SRC_BASE_ADDR_LOW_0
+read_reg 0xffff2806 0xffffffe0 0xc0200000 #NVDLA_SDP_RDMA.D_SRC_BASE_ADDR_LOW_0
 write_reg 0xffff2807 0x0 #NVDLA_SDP_RDMA.D_SRC_BASE_ADDR_HIGH_0
 read_reg 0xffff2807 0xffffffff 0x00000000 #NVDLA_SDP_RDMA.D_SRC_BASE_ADDR_HIGH_0
 write_reg 0xffff2808 0x100 #NVDLA_SDP_RDMA.D_SRC_LINE_STRIDE_0
@@ -17,8 +17,8 @@ write_reg 0xffff2809 0x800 #NVDLA_SDP_RDMA.D_SRC_SURFACE_STRIDE_0
 read_reg 0xffff2809 0xffffffe0 0x00000800 #NVDLA_SDP_RDMA.D_SRC_SURFACE_STRIDE_0
 write_reg 0xffff280a 0x1b #NVDLA_SDP_RDMA.D_BRDMA_CFG_0BRDMA_DATA_MODE=PER_ELEMENT, BRDMA_DATA_SIZE=TWO_BYTE, BRDMA_DATA_USE=ALU, BRDMA_DISABLE=YES
 read_reg 0xffff280a 0x0000003f 0x0000001b #NVDLA_SDP_RDMA.D_BRDMA_CFG_0BRDMA_DATA_MODE=PER_ELEMENT, BRDMA_DATA_SIZE=TWO_BYTE, BRDMA_DATA_USE=ALU, BRDMA_DISABLE=YES
-write_reg 0xffff280b 0x80300000 #NVDLA_SDP_RDMA.D_BS_BASE_ADDR_LOW_0
-read_reg 0xffff280b 0xffffffe0 0x80300000 #NVDLA_SDP_RDMA.D_BS_BASE_ADDR_LOW_0
+write_reg 0xffff280b 0xc0300000 #NVDLA_SDP_RDMA.D_BS_BASE_ADDR_LOW_0
+read_reg 0xffff280b 0xffffffe0 0xc0300000 #NVDLA_SDP_RDMA.D_BS_BASE_ADDR_LOW_0
 write_reg 0xffff280c 0x0 #NVDLA_SDP_RDMA.D_BS_BASE_ADDR_HIGH_0
 read_reg 0xffff280c 0xffffffff 0x00000000 #NVDLA_SDP_RDMA.D_BS_BASE_ADDR_HIGH_0
 write_reg 0xffff281c 0x54 #NVDLA_SDP_RDMA.D_FEATURE_MODE_CFG_0FLYING_MODE=0(OFF), WINOGRAD=0(OFF), INT16
@@ -43,8 +43,8 @@ write_reg 0xffff2c10 0x7 #NVDLA_SDP.D_DATA_CUBE_HEIGHT_0
 read_reg 0xffff2c10 0x00001fff 0x00000007 #NVDLA_SDP.D_DATA_CUBE_HEIGHT_0
 write_reg 0xffff2c11 0x1f #NVDLA_SDP.D_DATA_CUBE_CHANNEL_0
 read_reg 0xffff2c11 0x00001fff 0x0000001f #NVDLA_SDP.D_DATA_CUBE_CHANNEL_0
-write_reg 0xffff2c12 0x80800000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_08MB
-read_reg 0xffff2c12 0xffffffe0 0x80800000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_08MB
+write_reg 0xffff2c12 0xc0800000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_08MB
+read_reg 0xffff2c12 0xffffffe0 0xc0800000 #NVDLA_SDP.D_DST_BASE_ADDR_LOW_08MB
 write_reg 0xffff2c13 0x0 #NVDLA_SDP.D_DST_BASE_ADDR_HIGH_0
 read_reg 0xffff2c13 0xffffffff 0x00000000 #NVDLA_SDP.D_DST_BASE_ADDR_HIGH_0
 write_reg 0xffff2c14 0x100 #NVDLA_SDP.D_DST_LINE_STRIDE_0
@@ -85,4 +85,4 @@ write_reg 0xffff2c0e 0x1 #NVDLA_SDP.D_OP_ENABLE_0
 read_reg 0xffff2c0e 0x00000001 0x00000001 #NVDLA_SDP.D_OP_ENABLE_0
 wait
 write_reg 0xffff0003 0xffffffff #NVDLA_GLB.S_INTR_STATUS_0
-dump_mem 0x80800000 0x1000 output_feature_map.dat 
+dump_mem 0xc0800000 0x1000 output_feature_map.dat
diff --git a/verif/traces/traceplayer/sdp_relu_int16/output_feature_map.dat b/verif/traces/traceplayer/sdp_relu_int16/output_feature_map.dat
index f983830..4740f0c 100644
--- a/verif/traces/traceplayer/sdp_relu_int16/output_feature_map.dat
+++ b/verif/traces/traceplayer/sdp_relu_int16/output_feature_map.dat
@@ -1,4 +1,4 @@
-dumped memory,start_address=0x80800000 size=0x1000
+dumped memory,start_address=0xc0800000 size=0x1000
 memory type:dram
 ==============================
 
diff --git a/verif/verilator/Makefile b/verif/verilator/Makefile
index aa73fac..acaaaea 100644
--- a/verif/verilator/Makefile
+++ b/verif/verilator/Makefile
@@ -6,29 +6,133 @@
 # Hardware License.  For more information, see the "LICENSE" file that came
 # with this distribution.
 
+MULTI_THREAD = 1
+THREAD_PGO = 0
+
+
+# DIRS_NEED_MTPROF = verilator_mt_prof verilator_mt
+# DIRS_N_NEED_MTPROF = verilator verilator_prof verilator_mtprof
 DEPTH = ../..
+ROOT_PATH := $(abspath $(DEPTH))
 include $(DEPTH)/tools/make/common.make
 
-default: $(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator/VNV_nvdla
 
-VERILATOR_PARAMS ?= --compiler clang --output-split 250000000
+ifeq ($(MULTI_THREAD), 1)
+	ifeq ($(THREAD_PGO), 1)
+		DIRS_NEED_MTPROF = verilator_mt_prof verilator_mt
+		DIRS_N_NEED_MTPROF = verilator_mtprof
+		VLT_PATH = $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/profile.vlt
+	else
+		DIRS_NEED_MTPROF =
+		DIRS_N_NEED_MTPROF = verilator_mtprof verilator_mt_prof verilator_mt
+		VLT_PATH = 
+	endif
+else
+	DIRS_N_NEED_MTPROF = verilator verilator_prof
+endif
+DIRS = verilator verilator_prof verilator_mtprof verilator_mt_prof verilator_mt
+
+LLVM_PROF_DIRS = verilator_prof verilator_mt_prof
+LLVM_PROF_TESTS = lenet cc_alexnet_conv5_relu5_int16_dtest_cvsram googlenet_conv2_3x3_int16
+
+ifeq ($(MULTI_THREAD), 1)
+default: $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt/VNV_nvdla
+else
+default: $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator/VNV_nvdla
+endif
+
+
+VERILATOR_PARAMS_NO_PROF ?= --compiler clang --output-split 30000 --output-split-cfuncs 90000 --noassert -O3 -UVL_DEBUG -Wno-TIMESCALEMOD -CFLAGS "-std=gnu++14 -fPIC -DNDEBUG -O3 -Ofast" -LDFLAGS "--static"    # without profiling-guided optimization
+
+VERILATOR_PROF_PARAMS ?= --compiler clang --output-split 30000 --output-split-cfuncs 90000 --noassert -O3 -UVL_DEBUG -Wno-TIMESCALEMOD -CFLAGS "-std=gnu++14 -fPIC -DNDEBUG -O3 -Ofast -fprofile-generate" -LDFLAGS "--static -fprofile-generate"    # perform first-round profiling data collection
+VERILATOR_PARAMS ?= --compiler clang --output-split 30000 --output-split-cfuncs 90000 --noassert -O3 -UVL_DEBUG -Wno-TIMESCALEMOD -CFLAGS "-std=gnu++14 -fPIC -DNDEBUG -O3 -Ofast -fprofile-use=$(ROOT_PATH)/verilator_prof_LAG.profdata" -LDFLAGS "--static"    # after collecting data with "llvm-profdata merge xxx", use this command
+
+VERILATOR_MTPROF_PARAMS ?= --compiler clang --output-split 30000 --output-split-cfuncs 90000 --noassert --threads 4 --prof-pgo -O3 -UVL_DEBUG -Wno-TIMESCALEMOD -CFLAGS "-std=gnu++14 -fPIC -DNDEBUG -O3 -Ofast" -LDFLAGS "--static"
+VERILATOR_MT_PROF_PARAMS ?= --compiler clang --output-split 30000 --output-split-cfuncs 90000 --noassert --threads 4 $(VLT_PATH) -O3 -UVL_DEBUG -Wno-TIMESCALEMOD -CFLAGS "-std=gnu++14 -fPIC -DNDEBUG -O3 -Ofast -fprofile-generate" -LDFLAGS "--static -fprofile-generate" 
+VERILATOR_MT_PARAMS ?= --compiler clang --output-split 30000 --output-split-cfuncs 90000 --noassert --threads 4 $(VLT_PATH) -O3 -UVL_DEBUG -Wno-TIMESCALEMOD -CFLAGS "-std=gnu++14 -fPIC -DNDEBUG -O3 -Ofast -fprofile-use=$(ROOT_PATH)/verilator_mt_prof_LAG.profdata" -LDFLAGS "--static" 
 # Perhaps you need to trace?
 #   VERILATOR_PARAMS += --trace --trace-depth 7 --trace-max-array 8
 
 # We end up hardcoding this, because the .f file applies only to nv_full,
 # living in outdir, right now.  Otherwise, you're on your own...
-$(DEPTH)/outdir/nv_full/verilator/VNV_nvdla.mk: verilator.f ../../outdir/nv_full/vmod # and a lot of RTL...
-	$(VERILATOR) --cc --exe -f verilator.f --Mdir ../../outdir/nv_full/verilator/ nvdla.cpp --compiler clang --output-split 250000000
 
-$(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator/VNV_nvdla: $(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator/VNV_nvdla.mk nvdla.cpp
-	rm -f $(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator/nvdla.cpp
-	cp nvdla.cpp $(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator/nvdla.cpp
-	make -C $(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator -f VNV_nvdla.mk CC=$(CLANG) CXX=$(CLANG)++ VM_PARALLEL_BUILDS=1
 
-$(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator/test/%/trace.bin: $(DEPTH)/verif/traces/traceplayer/% input_txn_to_verilator.pl
-	rm -rf $@
-	mkdir -p $(dir $@)
-	$(PERL) input_txn_to_verilator.pl $< $@
+define VNV_nvdla_mk_rules
+$(ROOT_PATH)/outdir/$(PROJECT)/$(1)/VNV_nvdla.mk: verilator.f ../../outdir/$(PROJECT)/vmod
+	@$(VERILATOR) --cc --exe -f verilator.f --Mdir ../../outdir/$(PROJECT)/$(1)/ nvdla.cpp $$($(shell echo $(1) | tr a-z- A-Z_)_PARAMS)
+endef
+
+$(foreach dirname,$(DIRS_N_NEED_MTPROF),$(eval $(call VNV_nvdla_mk_rules,$(dirname))))
+
+
+define VNV_nvdla_mk_need_mtprof_rules
+$(ROOT_PATH)/outdir/$(PROJECT)/$(1)/VNV_nvdla.mk: verilator.f ../../outdir/$(PROJECT)/vmod $(VLT_PATH)
+	@$(VERILATOR) --cc --exe -f verilator.f --Mdir ../../outdir/$(PROJECT)/$(1)/ nvdla.cpp $$($(shell echo $(1) | tr a-z- A-Z_)_PARAMS)
+endef
+
+$(foreach dirname,$(DIRS_NEED_MTPROF),$(eval $(call VNV_nvdla_mk_need_mtprof_rules,$(dirname))))
+
+
+
+define profdata_rules
+$(ROOT_PATH)/$(1)_LAG.profdata : $(foreach testname,$(LLVM_PROF_TESTS),$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/$(1)/test/$(testname)/trace.bin) $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/$(1)/VNV_nvdla_prof
+	rm -f $(foreach testname,$(LLVM_PROF_TESTS),$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/$(1)/test/$(testname)/*.profraw)
+	$(foreach testname,$(LLVM_PROF_TESTS),cd $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/$(1)/test/$(testname) && ../../VNV_nvdla_prof trace.bin > /dev/null && cd $(ROOT_PATH)/verif/verilator;)
+	$(LLVM_PROFDATA) merge -output=$(ROOT_PATH)/$(1)_LAG.profdata $(foreach testname,$(LLVM_PROF_TESTS),$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/$(1)/test/$(testname)/*.profraw)
+endef
+
+$(foreach llvm_prof_dir,$(LLVM_PROF_DIRS),$(eval $(call profdata_rules,$(llvm_prof_dir))))
+
+
+
+
+$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_prof/VNV_nvdla_prof: $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_prof/VNV_nvdla.mk nvdla.cpp
+	rm -f $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_prof/nvdla.cpp    # don't require clang profdata
+	cp nvdla.cpp $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_prof/nvdla.cpp
+	make -C $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_prof -j24 -f VNV_nvdla.mk CC=$(CLANG) CXX=$(CLANGXX) OPT_FAST="" VM_PARALLEL_BUILDS=1
+	mv $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_prof/VNV_nvdla $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_prof/VNV_nvdla_prof    # rename
+$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator/VNV_nvdla: $(ROOT_PATH)/verilator_prof_LAG.profdata $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator/VNV_nvdla.mk nvdla.cpp
+	rm -f $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator/nvdla.cpp    # require profdata
+	cp nvdla.cpp $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator/nvdla.cpp
+	make -C $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator -j24 -f VNV_nvdla.mk CC=$(CLANG) CXX=$(CLANGXX) OPT_FAST="" VM_PARALLEL_BUILDS=1
+
+
+
+
+$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/VNV_nvdla_mtprof: $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/VNV_nvdla.mk nvdla.cpp
+	rm -f $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/nvdla.cpp    # don't require clang profdata
+	cp nvdla.cpp $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/nvdla.cpp
+	make -C $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof -j24 -f VNV_nvdla.mk CC=$(CLANG) CXX=$(CLANGXX) OPT_FAST="" VM_PARALLEL_BUILDS=1
+	mv $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/VNV_nvdla $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/VNV_nvdla_mtprof    # rename
+$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt_prof/VNV_nvdla_prof: $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt_prof/VNV_nvdla.mk nvdla.cpp $(VLT_PATH)
+	rm -f $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt_prof/nvdla.cpp    # don't require clang profdata, but require verilator multi-thread profile.vlt
+	cp nvdla.cpp $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt_prof/nvdla.cpp
+	make -C $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt_prof -j24 -f VNV_nvdla.mk CC=$(CLANG) CXX=$(CLANGXX) OPT_FAST="" VM_PARALLEL_BUILDS=1
+	mv $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt_prof/VNV_nvdla $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt_prof/VNV_nvdla_prof    # rename
+$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt/VNV_nvdla: $(ROOT_PATH)/verilator_mt_prof_LAG.profdata $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt/VNV_nvdla.mk nvdla.cpp
+	rm -f $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt/nvdla.cpp    # require clang profdata
+	cp nvdla.cpp $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt/nvdla.cpp
+	make -C $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mt -j24 -f VNV_nvdla.mk CC=$(CLANG) CXX=$(CLANGXX) OPT_FAST="" VM_PARALLEL_BUILDS=1
+
+
+ifneq ($(VLT_PATH),)
+$(VLT_PATH): $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/VNV_nvdla_mtprof $(foreach testname,$(LLVM_PROF_TESTS),$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/test/$(testname)/trace.bin)
+	rm -f $(VLT_PATH)
+	# $(foreach testname,$(LLVM_PROF_TESTS),cd $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof && ./VNV_nvdla_mtprof test/$(testname)/trace.bin > /dev/null;)
+	cd $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator_mtprof/ && ./VNV_nvdla_mtprof test/lenet/trace.bin > /dev/null
+endif
+
+
+
+define trace_bin_rules
+$(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/$(1)/test/%/trace.bin : $(ROOT_PATH)/verif/traces/traceplayer/% input_txn_to_verilator.pl
+	rm -rf $$@
+	mkdir -p $$(dir $$@)
+	$(PERL) input_txn_to_verilator.pl $$</input.txn $$@
+endef
+
+$(foreach prj_dir,$(DIRS),$(eval $(call trace_bin_rules,$(prj_dir))))
+
 
-run: $(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator/test/$(TEST)/trace.bin $(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator/VNV_nvdla
-	cd $(DEPTH)/$(OUTDIR)/$(PROJECT)/verilator/test/$(TEST) && ../../VNV_nvdla trace.bin
+run: $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator/test/$(TEST)/trace.bin $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator/VNV_nvdla
+	cd $(ROOT_PATH)/$(OUTDIR)/$(PROJECT)/verilator/test/$(TEST) && ../../VNV_nvdla trace.bin
diff --git a/verif/verilator/input_txn_to_verilator.pl b/verif/verilator/input_txn_to_verilator.pl
index 0c2f7e0..f33667d 100755
--- a/verif/verilator/input_txn_to_verilator.pl
+++ b/verif/verilator/input_txn_to_verilator.pl
@@ -1,11 +1,13 @@
 #!/usr/bin/env perl
 
 use strict;
+use File::Basename;
 
 # Configurable parameters
 my $read_reg_poll_retries = 50000;
 my $test_dir = '.';
-$test_dir = $ARGV[0];
+$test_dir = dirname($ARGV[0]);
+
 
 # Creating a hash for the above - command - hex val
 my %command_hash = (
@@ -19,7 +21,7 @@ my %command_hash = (
 );
 
 
-my $input_file = "$test_dir/input.txn";
+my $input_file = $ARGV[0];
 my $output_file = $ARGV[1];
 
 my $inf;
@@ -82,6 +84,16 @@ while(<$inf>)
     if ($values[0] =~ /wait/) {
       print $ouf pack("C", 1);
     }
+
+    if ($values[0] =~ /until/) {
+      if($size != 3) { die "\nERROR: in write_reg command: $input_line\n" };
+
+      my $addr = $values[1];
+      my $data = $values[2];
+
+      print $ouf pack("CLL", 6, hex($addr), hex($data));
+    }
+
     elsif($values[0] =~ /write_reg/) {
       if($size != 3) { die "\nERROR: in write_reg command: $input_line\n" };
 
@@ -131,14 +143,14 @@ while(<$inf>)
            my $line = $_;
            next if ($line !~ m/^ ?0x/);
            $line =~ s/ ?0x//g;
-           #assuming 32 bytes per line. 1st byte on line goes to addr0
-           # So we split into groups of 8 nums (4 bytes) then reverse each byte
+           # allowing each line to have x bytes, 0 < x <= 32.
+           # each byte is in 2 hex chars
            my @bytes = ($line =~ m/([0-9a-z]{2})/g);
-           die "Can't parse $line into 32 groups of 2 hex numbers. Got ".scalar(@bytes)." groups" if (scalar(@bytes) != 32);
+           die "$line is ill-formatted. Got ".scalar(@bytes)." groups of 2 hex numbers" if (scalar(@bytes) == 0 || scalar(@bytes) > 32);
            foreach my $byte (@bytes) {
              print $ouf pack("C", hex($byte));
            }
-           $totbytes += 32;
+           $totbytes += scalar(@bytes);
            if ($totbytes == hex($offset)) {
              print "okay, that's all the bytes I expected -- I'm stopping here\n";
              last;
diff --git a/verif/verilator/nvdla.cpp b/verif/verilator/nvdla.cpp
old mode 100644
new mode 100755
index e24becf..a160020
--- a/verif/verilator/nvdla.cpp
+++ b/verif/verilator/nvdla.cpp
@@ -31,829 +31,873 @@ void _close_trace() {
 uint64_t ticks = 0;
 
 double sc_time_stamp() {
-	return (double) ticks;
+    return (double) ticks;
 }
 
 class CSBMaster {
-	struct csb_op {
-		int is_ext;
-		int write;
-		int tries;
-		int reading;
-		uint32_t addr;
-		uint32_t mask;
-		uint32_t data;
-	};
-	
-	std::queue<csb_op> opq;
-	
-	VNV_nvdla *dla;
-	
-	int _test_passed;
-	
+    struct csb_op {
+        int is_ext;
+        int write;
+        int tries;
+        int reading;
+        int wait_until;
+        uint32_t addr;
+        uint32_t mask;
+        uint32_t data;
+    };
+
+    std::queue<csb_op> opq;
+
+    VNV_nvdla *dla;
+
+    int _test_passed;
+
 public:
-	CSBMaster(VNV_nvdla *_dla) {
-		dla = _dla;
-		
-		dla->csb2nvdla_valid = 0;
-		_test_passed = 1;
-	}
-
-	void read(uint32_t addr, uint32_t mask, uint32_t data) {
-		csb_op op;
-	
-		op.is_ext = 0;
-		op.write = 0;
-		op.addr = addr;
-		op.mask = mask;
-		op.data = data;
-		op.tries = 10;
-		op.reading = 0;
-	
-		opq.push(op);
-	}
-	
-	void write(uint32_t addr, uint32_t data) {
-		csb_op op;
-	
-		op.is_ext = 0;
-		op.write = 1;
-		op.addr = addr;
-		op.data = data;
-	
-		opq.push(op);
-	}
-	
-	void ext_event(int ext) {
-		csb_op op;
-		
-		op.is_ext = ext;
-		opq.push(op);
-	}
-	
-	int eval(int noop) {
-		if (dla->nvdla2csb_wr_complete)
-			printf("(%lu) write complete from CSB\n", ticks);
-		
-		dla->csb2nvdla_valid = 0;
-		if (opq.empty())
-			return 0;
-
-		csb_op &op = opq.front();
-		
-		if (op.is_ext && !noop) {
-			int ext = op.is_ext;
-			opq.pop();
-			
-			return ext;
-		}
-		
-		if (!op.write && op.reading && dla->nvdla2csb_valid) {
-			printf("(%lu) read response from nvdla: %08x\n", ticks, dla->nvdla2csb_data);
-			
-			if ((dla->nvdla2csb_data & op.mask) != (op.data & op.mask)) {
-				op.reading = 0;
-				op.tries--;
-				printf("(%lu) invalid response -- trying again\n", ticks);
-				if (!op.tries) {
-					printf("(%lu) ERROR: timed out reading response\n", ticks);
-					_test_passed = 0;
-					opq.pop();
-				}
-			} else
-				opq.pop();
-		}
-		
-		if (!op.write && op.reading)
-			return 0;
-		
-		if (noop)
-			return 0;
-		
-		if (!dla->csb2nvdla_ready) {
-			printf("(%lu) CSB stalled...\n", ticks);
-			return 0;
-		}
-		
-		if (op.write) {
-			dla->csb2nvdla_valid = 1;
-			dla->csb2nvdla_addr = op.addr;
-			dla->csb2nvdla_wdat = op.data;
-			dla->csb2nvdla_write = 1;
-			dla->csb2nvdla_nposted = 0;
-			printf("(%lu) write to nvdla: addr %08x, data %08x\n", ticks, op.addr, op.data);
-			opq.pop();
-		} else {
-			dla->csb2nvdla_valid = 1;
-			dla->csb2nvdla_addr = op.addr;
-			dla->csb2nvdla_write = 0;
-			printf("(%lu) read from nvdla: addr %08x\n", ticks, op.addr);
-			
-			op.reading = 1;
-		}
-		
-		return 0;
-	}
-	
-	bool done() {
-		return opq.empty();
-	}
-	
-	int test_passed() {
-		return _test_passed;
-	}
+    CSBMaster(VNV_nvdla *_dla) {
+        dla = _dla;
+
+        dla->csb2nvdla_valid = 0;
+        _test_passed = 1;
+    }
+
+    void read(uint32_t addr, uint32_t mask, uint32_t data) {
+        csb_op op;
+
+        op.is_ext = 0;
+        op.write = 0;
+        op.addr = addr;
+        op.mask = mask;
+        op.data = data;
+        op.tries = 10;
+        op.reading = 0;
+        op.wait_until = 0;
+
+        opq.push(op);
+    }
+
+    void wait_until(uint32_t addr, uint32_t mask, uint32_t data) {
+        csb_op op;
+
+        op.is_ext = 0;
+        op.write = 0;
+        op.addr = addr;
+        op.mask = mask;
+        op.data = data;
+        op.tries = 10;
+        op.reading = 0;
+        op.wait_until = 1;
+
+        opq.push(op);
+    }
+
+    void write(uint32_t addr, uint32_t data) {
+        csb_op op;
+
+        op.is_ext = 0;
+        op.write = 1;
+        op.addr = addr;
+        op.data = data;
+        op.wait_until = 0;
+
+        opq.push(op);
+    }
+
+    void ext_event(int ext) {
+        csb_op op;
+
+        op.is_ext = ext;
+        opq.push(op);
+    }
+
+    int eval(int noop) {
+        if (dla->nvdla2csb_wr_complete)
+            printf("(%lu) write complete from CSB\n", ticks);
+
+        dla->csb2nvdla_valid = 0;
+        if (opq.empty())
+            return 0;
+
+        csb_op &op = opq.front();
+
+        if (op.is_ext && !noop) {
+            int ext = op.is_ext;
+            opq.pop();
+
+            return ext;
+        }
+
+        if (!op.write && op.reading && dla->nvdla2csb_valid) {
+            if(op.wait_until == 0) printf("(%lu) read response from nvdla: %08x\n", ticks, dla->nvdla2csb_data);
+
+            if ((dla->nvdla2csb_data & op.mask) != (op.data & op.mask)) {
+                op.reading = 0;
+
+                if(op.wait_until == 0) {
+                    if(op.write == 0 && op.addr == 0xffff0003 && op.data == 0x0 && dla->nvdla2csb_data != 0) {
+                        printf("new interrupts come too early, so ignore this reg txn\n");
+                        opq.pop();
+                    } else {
+                        op.tries--;
+                        printf("(%lu) invalid response -- trying again\n", ticks);
+                        if (!op.tries) {
+                            printf("(%lu) ERROR: timed out reading response\n", ticks);
+                            printf("op.write = %d, op.addr = 0x%08x, op.data = %08x, received = 0x%08x\n", op.write,
+                                   op.addr, op.data, (dla->nvdla2csb_data & op.mask));
+                            _test_passed = 0;
+                            opq.pop();
+                        }
+                    }
+                } else if(((dla->nvdla2csb_data & op.mask) & op.data) == op.data) {
+                    printf("(%lu) Intr reg 0x%08x has the expected bit 0x%08x\n", ticks, dla->nvdla2csb_data, op.data);
+                    opq.pop();
+                }
+            } else {
+                if(op.wait_until) printf("(%lu) Intr reg got the expected response 0x%08x\n", ticks, op.data);
+                opq.pop();
+            }
+        }
+
+        if (!op.write && op.reading)
+            return 0;
+
+        if (noop)
+            return 0;
+
+        if (!dla->csb2nvdla_ready) {
+            printf("(%lu) CSB stalled...\n", ticks);
+            return 0;
+        }
+
+        if (op.write) {
+            dla->csb2nvdla_valid = 1;
+            dla->csb2nvdla_addr = op.addr;
+            dla->csb2nvdla_wdat = op.data;
+            dla->csb2nvdla_write = 1;
+            dla->csb2nvdla_nposted = 0;
+            printf("(%lu) write to nvdla: addr %08x, data %08x\n", ticks, op.addr, op.data);
+            opq.pop();
+        } else {
+            dla->csb2nvdla_valid = 1;
+            dla->csb2nvdla_addr = op.addr;
+            dla->csb2nvdla_write = 0;
+            if(op.wait_until == 0) printf("(%lu) read from nvdla: addr %08x\n", ticks, op.addr);
+
+            op.reading = 1;
+        }
+
+        return 0;
+    }
+
+    bool done() {
+        return opq.empty();
+    }
+
+    int test_passed() {
+        return _test_passed;
+    }
 };
 
 template <typename ADDRTYPE>
 class AXIResponder {
 public:
-	struct connections {
-		uint8_t *aw_awvalid;
-		uint8_t *aw_awready;
-		uint8_t *aw_awid;
-		uint8_t *aw_awlen;
-		ADDRTYPE *aw_awaddr;
-		
-		uint8_t *w_wvalid;
-		uint8_t *w_wready;
-		uint32_t *w_wdata;
-		uint64_t *w_wstrb;
-		uint8_t *w_wlast;
-		
-		uint8_t *b_bvalid;
-		uint8_t *b_bready;
-		uint8_t *b_bid;
-		
-		uint8_t *ar_arvalid;
-		uint8_t *ar_arready;
-		uint8_t *ar_arid;
-		uint8_t *ar_arlen;
-		ADDRTYPE *ar_araddr;
-		
-		uint8_t *r_rvalid;
-		uint8_t *r_rready;
-		uint8_t *r_rid;
-		uint8_t *r_rlast;
-		uint32_t *r_rdata;
-	};
+    struct connections {
+        uint8_t *aw_awvalid;
+        uint8_t *aw_awready;
+        uint8_t *aw_awid;
+        uint8_t *aw_awlen;
+        ADDRTYPE *aw_awaddr;
+
+        uint8_t *w_wvalid;
+        uint8_t *w_wready;
+        uint32_t *w_wdata;
+        uint64_t *w_wstrb;
+        uint8_t *w_wlast;
+
+        uint8_t *b_bvalid;
+        uint8_t *b_bready;
+        uint8_t *b_bid;
+
+        uint8_t *ar_arvalid;
+        uint8_t *ar_arready;
+        uint8_t *ar_arid;
+        uint8_t *ar_arlen;
+        ADDRTYPE *ar_araddr;
+
+        uint8_t *r_rvalid;
+        uint8_t *r_rready;
+        uint8_t *r_rid;
+        uint8_t *r_rlast;
+        uint32_t *r_rdata;
+    };
 
 private:
 
 #define AXI_BLOCK_SIZE 4096
 #define AXI_WIDTH 512
 
-	const static int AXI_R_LATENCY = 32;
-	const static int AXI_R_DELAY = 0;
-
-	struct axi_r_txn {
-		int rvalid;
-		int rlast;
-		uint32_t rdata[AXI_WIDTH / 32];
-		uint8_t rid;
-	};
-	std::queue<axi_r_txn> r_fifo;
-	std::queue<axi_r_txn> r0_fifo;
-	
-	struct axi_aw_txn {
-		uint8_t awid;
-		uint32_t awaddr;
-		uint8_t awlen;
-	};
-	std::queue<axi_aw_txn> aw_fifo;
-	
-	struct axi_w_txn {
-		uint32_t wdata[AXI_WIDTH / 32];
-		uint64_t wstrb;
-		uint8_t wlast;
-	};
-	std::queue<axi_w_txn> w_fifo;
-	
-	struct axi_b_txn {
-		uint8_t bid;
-	};
-	std::queue<axi_b_txn> b_fifo;
-	
-	std::map<uint32_t, std::vector<uint8_t> > ram;
-	
-	struct connections dla;
-	const char *name;
-	
-public:	
-	AXIResponder(struct connections _dla, const char *_name) {
-		dla = _dla;
-		
-		*dla.aw_awready = 1;
-		*dla.w_wready = 1;
-		*dla.b_bvalid = 0;
-		*dla.ar_arready = 1;
-		*dla.r_rvalid = 0;
-		
-		name = _name;
-		
-		/* add some latency... */
-		for (int i = 0; i < AXI_R_LATENCY; i++) {
-			axi_r_txn txn;
-			
-			txn.rvalid = 0;
-			txn.rvalid = 0;
-			txn.rid = 0;
-			txn.rlast = 0;
-			for (int i = 0; i < AXI_WIDTH / 32; i++) {
-				txn.rdata[i] = 0xAAAAAAAA;
-			}
-			
-			r0_fifo.push(txn);
-		}
-	}
-
-	uint8_t read(uint32_t addr) {
-		ram[addr / AXI_BLOCK_SIZE].resize(AXI_BLOCK_SIZE, 0);
-		return ram[addr / AXI_BLOCK_SIZE][addr % AXI_BLOCK_SIZE];
-	}
-	
-	void write(uint32_t addr, uint8_t data) {
-		ram[addr / AXI_BLOCK_SIZE].resize(AXI_BLOCK_SIZE, 0);
-		ram[addr / AXI_BLOCK_SIZE][addr % AXI_BLOCK_SIZE] = data;
-	}
-	
-	void eval() {
-		/* write request */
-		if (*dla.aw_awvalid && *dla.aw_awready) {
-			printf("(%lu) %s: write request from dla, addr %08lx id %d\n", ticks, name, *dla.aw_awaddr, *dla.aw_awid);
-			
-			axi_aw_txn txn;
-			
-			txn.awid = *dla.aw_awid;
-			txn.awaddr = *dla.aw_awaddr & ~(ADDRTYPE)(AXI_WIDTH / 8 - 1);
-			txn.awlen = *dla.aw_awlen;
-			aw_fifo.push(txn);
-			
-			*dla.aw_awready = 0;
-		} else
-			*dla.aw_awready = 1;
-		
-		/* write data */
-		if (*dla.w_wvalid) {
-			printf("(%lu) %s: write data from dla (%08x %08x...)\n", ticks, name, dla.w_wdata[0], dla.w_wdata[1]);
-			
-			axi_w_txn txn;
-			
-			for (int i = 0; i < AXI_WIDTH / 32; i++)
-				txn.wdata[i] = dla.w_wdata[i];
-			txn.wstrb = *dla.w_wstrb;
-			txn.wlast = *dla.w_wlast;
-			w_fifo.push(txn);
-		}
-		
-		/* read request */
-		if (*dla.ar_arvalid && *dla.ar_arready) {
-			ADDRTYPE addr = *dla.ar_araddr & ~(ADDRTYPE)(AXI_WIDTH / 8 - 1);
-			uint8_t len = *dla.ar_arlen;
-
-			printf("(%lu) %s: read request from dla, addr %08lx burst %d id %d\n", ticks, name, *dla.ar_araddr, *dla.ar_arlen, *dla.ar_arid);
-			
-			do {
-				axi_r_txn txn;
-
-				txn.rvalid = 1;
-				txn.rlast = len == 0;
-				txn.rid = *dla.ar_arid;
-			
-				for (int i = 0; i < AXI_WIDTH / 32; i++) {
-					uint32_t da = read(addr + i * 4) + 
-					              (read(addr + i * 4 + 1) << 8) + 
-					              (read(addr + i * 4 + 2) << 16) + 
-					              (read(addr + i * 4 + 3) << 24);
-					txn.rdata[i] = da;
-				}
-
-				r_fifo.push(txn);
-				
-				addr += AXI_WIDTH / 8;
-			} while (len--);
-			
-			axi_r_txn txn;
-			
-			txn.rvalid = 0;
-			txn.rid = 0;
-			txn.rlast = 0;
-			for (int i = 0; i < AXI_WIDTH / 32; i++) {
-				txn.rdata[i] = 0x55555555;
-			}
-			
-			for (int i = 0; i < AXI_R_DELAY; i++)
-				r_fifo.push(txn);
-			
-			*dla.ar_arready = 0;
-		} else
-			*dla.ar_arready = 1;
-		
-		/* now handle the write FIFOs ... */
-		if (!aw_fifo.empty() && !w_fifo.empty()) {
-			axi_aw_txn &awtxn = aw_fifo.front();
-			axi_w_txn &wtxn = w_fifo.front();
-			
-			if (wtxn.wlast != (awtxn.awlen == 0)) {
-				printf("(%lu) %s: wlast / awlen mismatch\n", ticks, name);
-				abort();
-			}
-			
-			for (int i = 0; i < AXI_WIDTH / 8; i++) {
-				if (!((wtxn.wstrb >> i) & 1))
-					continue;
-				
-				write(awtxn.awaddr + i, (wtxn.wdata[i / 4] >> ((i % 4) * 8)) & 0xFF);
-			}
-			
-			
-			if (wtxn.wlast) {
-				printf("(%lu) %s: write, last tick\n", ticks, name);
-				aw_fifo.pop();
-
-				axi_b_txn btxn;
-				btxn.bid = awtxn.awid;
-				b_fifo.push(btxn);
-			} else {
-				printf("(%lu) %s: write, ticks remaining\n", ticks, name);
-
-				awtxn.awlen--;
-				awtxn.awaddr += AXI_WIDTH / 8;
-			}
-			
-			w_fifo.pop();
-		}
-		
-		/* read response */
-		if (!r_fifo.empty()) {
-			axi_r_txn &txn = r_fifo.front();
-			
-			r0_fifo.push(txn);
-			r_fifo.pop();
-		} else {
-			axi_r_txn txn;
-			
-			txn.rvalid = 0;
-			txn.rid = 0;
-			txn.rlast = 0;
-			for (int i = 0; i < AXI_WIDTH / 32; i++) {
-				txn.rdata[i] = 0xAAAAAAAA;
-			}
-			
-			r0_fifo.push(txn);
-		}
-
-		*dla.r_rvalid = 0;
-		if (*dla.r_rready && !r0_fifo.empty()) {
-			axi_r_txn &txn = r0_fifo.front();
-			
-			*dla.r_rvalid = txn.rvalid;
-			*dla.r_rid = txn.rid;
-			*dla.r_rlast = txn.rlast;
-			for (int i = 0; i < AXI_WIDTH / 32; i++) {
-				dla.r_rdata[i] = txn.rdata[i];
-			}
-			
-			if (txn.rvalid)
-				printf("(%lu) %s: read push: id %d, da %08x %08x %08x %08x\n",
-					ticks, name, txn.rid, txn.rdata[0], txn.rdata[1], txn.rdata[2], txn.rdata[3]);
-			
-			r0_fifo.pop();
-		}
-		
-		/* write response */
-		*dla.b_bvalid = 0;
-		if (*dla.b_bready && !b_fifo.empty()) {
-			*dla.b_bvalid = 1;
-			
-			axi_b_txn &txn = b_fifo.front();
-			*dla.b_bid = txn.bid;
-			b_fifo.pop();
-		}
-	}
+    const static int AXI_R_LATENCY = 32;
+    const static int AXI_R_DELAY = 0;
+
+    struct axi_r_txn {
+        int rvalid;
+        int rlast;
+        uint32_t rdata[AXI_WIDTH / 32];
+        uint8_t rid;
+    };
+    std::queue<axi_r_txn> r_fifo;
+    std::queue<axi_r_txn> r0_fifo;
+
+    struct axi_aw_txn {
+        uint8_t awid;
+        uint32_t awaddr;
+        uint8_t awlen;
+    };
+    std::queue<axi_aw_txn> aw_fifo;
+
+    struct axi_w_txn {
+        uint32_t wdata[AXI_WIDTH / 32];
+        uint64_t wstrb;
+        uint8_t wlast;
+    };
+    std::queue<axi_w_txn> w_fifo;
+
+    struct axi_b_txn {
+        uint8_t bid;
+    };
+    std::queue<axi_b_txn> b_fifo;
+
+    std::map<uint32_t, std::vector<uint8_t> > ram;
+
+    struct connections dla;
+    const char *name;
+
+public:
+    AXIResponder(struct connections _dla, const char *_name) {
+        dla = _dla;
+
+        *dla.aw_awready = 1;
+        *dla.w_wready = 1;
+        *dla.b_bvalid = 0;
+        *dla.ar_arready = 1;
+        *dla.r_rvalid = 0;
+
+        name = _name;
+
+        /* add some latency... */
+        for (int i = 0; i < AXI_R_LATENCY; i++) {
+            axi_r_txn txn;
+
+            txn.rvalid = 0;
+            txn.rvalid = 0;
+            txn.rid = 0;
+            txn.rlast = 0;
+            for (int i = 0; i < AXI_WIDTH / 32; i++) {
+                txn.rdata[i] = 0xAAAAAAAA;
+            }
+
+            r0_fifo.push(txn);
+        }
+    }
+
+    uint8_t read(uint32_t addr) {
+        ram[addr / AXI_BLOCK_SIZE].resize(AXI_BLOCK_SIZE, 0);
+        return ram[addr / AXI_BLOCK_SIZE][addr % AXI_BLOCK_SIZE];
+    }
+
+    void write(uint32_t addr, uint8_t data) {
+        ram[addr / AXI_BLOCK_SIZE].resize(AXI_BLOCK_SIZE, 0);
+        ram[addr / AXI_BLOCK_SIZE][addr % AXI_BLOCK_SIZE] = data;
+    }
+
+    void eval() {
+        /* write request */
+        if (*dla.aw_awvalid && *dla.aw_awready) {
+            printf("(%lu) %s: write request from dla, addr %08lx id %d\n", ticks, name, *dla.aw_awaddr, *dla.aw_awid);
+
+            axi_aw_txn txn;
+
+            txn.awid = *dla.aw_awid;
+            txn.awaddr = *dla.aw_awaddr & ~(ADDRTYPE)(AXI_WIDTH / 8 - 1);
+            txn.awlen = *dla.aw_awlen;
+            aw_fifo.push(txn);
+
+            *dla.aw_awready = 0;
+        } else
+            *dla.aw_awready = 1;
+
+        /* write data */
+        if (*dla.w_wvalid) {
+            printf("(%lu) %s: write data from dla (%08x %08x...)\n", ticks, name, dla.w_wdata[0], dla.w_wdata[1]);
+
+            axi_w_txn txn;
+
+            for (int i = 0; i < AXI_WIDTH / 32; i++)
+                txn.wdata[i] = dla.w_wdata[i];
+            txn.wstrb = *dla.w_wstrb;
+            txn.wlast = *dla.w_wlast;
+            w_fifo.push(txn);
+        }
+
+        /* read request */
+        if (*dla.ar_arvalid && *dla.ar_arready) {
+            ADDRTYPE addr = *dla.ar_araddr & ~(ADDRTYPE)(AXI_WIDTH / 8 - 1);
+            uint8_t len = *dla.ar_arlen;
+
+            printf("(%lu) %s: read request from dla, addr %08lx burst %d id %d\n", ticks, name, *dla.ar_araddr, *dla.ar_arlen, *dla.ar_arid);
+
+            do {
+                axi_r_txn txn;
+
+                txn.rvalid = 1;
+                txn.rlast = len == 0;
+                txn.rid = *dla.ar_arid;
+
+                for (int i = 0; i < AXI_WIDTH / 32; i++) {
+                    uint32_t da = read(addr + i * 4) +
+                                  (read(addr + i * 4 + 1) << 8) +
+                                  (read(addr + i * 4 + 2) << 16) +
+                                  (read(addr + i * 4 + 3) << 24);
+                    txn.rdata[i] = da;
+                }
+
+                r_fifo.push(txn);
+
+                addr += AXI_WIDTH / 8;
+            } while (len--);
+
+            axi_r_txn txn;
+
+            txn.rvalid = 0;
+            txn.rid = 0;
+            txn.rlast = 0;
+            for (int i = 0; i < AXI_WIDTH / 32; i++) {
+                txn.rdata[i] = 0x55555555;
+            }
+
+            for (int i = 0; i < AXI_R_DELAY; i++)
+                r_fifo.push(txn);
+
+            *dla.ar_arready = 0;
+        } else
+            *dla.ar_arready = 1;
+
+        /* now handle the write FIFOs ... */
+        if (!aw_fifo.empty() && !w_fifo.empty()) {
+            axi_aw_txn &awtxn = aw_fifo.front();
+            axi_w_txn &wtxn = w_fifo.front();
+
+            if (wtxn.wlast != (awtxn.awlen == 0)) {
+                printf("(%lu) %s: wlast / awlen mismatch\n", ticks, name);
+                abort();
+            }
+
+            for (int i = 0; i < AXI_WIDTH / 8; i++) {
+                if (!((wtxn.wstrb >> i) & 1))
+                    continue;
+
+                write(awtxn.awaddr + i, (wtxn.wdata[i / 4] >> ((i % 4) * 8)) & 0xFF);
+            }
+
+
+            if (wtxn.wlast) {
+                printf("(%lu) %s: write, last tick\n", ticks, name);
+                aw_fifo.pop();
+
+                axi_b_txn btxn;
+                btxn.bid = awtxn.awid;
+                b_fifo.push(btxn);
+            } else {
+                printf("(%lu) %s: write, ticks remaining\n", ticks, name);
+
+                awtxn.awlen--;
+                awtxn.awaddr += AXI_WIDTH / 8;
+            }
+
+            w_fifo.pop();
+        }
+
+        /* read response */
+        if (!r_fifo.empty()) {
+            axi_r_txn &txn = r_fifo.front();
+
+            r0_fifo.push(txn);
+            r_fifo.pop();
+        } else {
+            axi_r_txn txn;
+
+            txn.rvalid = 0;
+            txn.rid = 0;
+            txn.rlast = 0;
+            for (int i = 0; i < AXI_WIDTH / 32; i++) {
+                txn.rdata[i] = 0xAAAAAAAA;
+            }
+
+            r0_fifo.push(txn);
+        }
+
+        *dla.r_rvalid = 0;
+        if (*dla.r_rready && !r0_fifo.empty()) {
+            axi_r_txn &txn = r0_fifo.front();
+
+            *dla.r_rvalid = txn.rvalid;
+            *dla.r_rid = txn.rid;
+            *dla.r_rlast = txn.rlast;
+            for (int i = 0; i < AXI_WIDTH / 32; i++) {
+                dla.r_rdata[i] = txn.rdata[i];
+            }
+
+            if (txn.rvalid)
+                printf("(%lu) %s: read push: id %d, da %08x %08x %08x %08x\n",
+                       ticks, name, txn.rid, txn.rdata[0], txn.rdata[1], txn.rdata[2], txn.rdata[3]);
+
+            r0_fifo.pop();
+        }
+
+        /* write response */
+        *dla.b_bvalid = 0;
+        if (*dla.b_bready && !b_fifo.empty()) {
+            *dla.b_bvalid = 1;
+
+            axi_b_txn &txn = b_fifo.front();
+            *dla.b_bid = txn.bid;
+            b_fifo.pop();
+        }
+    }
 };
 
 class TraceLoader {
-	enum axi_opc {
-		AXI_LOADMEM,
-		AXI_DUMPMEM
-	};
-
-	struct axi_op {
-		axi_opc opcode;
-		uint32_t addr;
-		uint32_t len;
-		const uint8_t *buf;
-		const char *fname;
-	};
-	std::queue<axi_op> opq;
-	
-	CSBMaster *csb;
-	AXIResponder<uint64_t> *axi_dbb, *axi_cvsram;
-	
-	int _test_passed;
+    enum axi_opc {
+        AXI_LOADMEM,
+        AXI_DUMPMEM
+    };
+
+    struct axi_op {
+        axi_opc opcode;
+        uint32_t addr;
+        uint32_t len;
+        const uint8_t *buf;
+        const char *fname;
+    };
+    std::queue<axi_op> opq;
+
+    CSBMaster *csb;
+    AXIResponder<uint64_t> *axi_dbb, *axi_cvsram;
+
+    int _test_passed;
 
 public:
-	enum stop_type {	
-		TRACE_CONTINUE = 0,
-		TRACE_AXIEVENT,
-		TRACE_WFI
-	};
-
-	TraceLoader(CSBMaster *_csb, AXIResponder<uint64_t> *_axi_dbb, AXIResponder<uint64_t> *_axi_cvsram) {
-		csb = _csb;
-		axi_dbb = _axi_dbb;
-		axi_cvsram = _axi_cvsram;
-		_test_passed = 1;
-	}
-	
-	void load(const char *fname) {
-		int fd;
-		fd = open(fname, O_RDONLY);
-		if (fd < 0) {
-			perror("open(trace file)");
-			abort();
-		}
-	
-		unsigned char cmd;
-		int rv;
+    enum stop_type {
+        TRACE_CONTINUE = 0,
+        TRACE_AXIEVENT,
+        TRACE_WFI
+    };
+
+    TraceLoader(CSBMaster *_csb, AXIResponder<uint64_t> *_axi_dbb, AXIResponder<uint64_t> *_axi_cvsram) {
+        csb = _csb;
+        axi_dbb = _axi_dbb;
+        axi_cvsram = _axi_cvsram;
+        _test_passed = 1;
+    }
+
+    void load(const char *fname) {
+        int fd;
+        fd = open(fname, O_RDONLY);
+        if (fd < 0) {
+            perror("open(trace file)");
+            abort();
+        }
+
+        unsigned char cmd;
+        int rv;
 #define VERILY_READ(p, n) do { if (read(fd, (p), (n)) != (n)) { perror("short read"); abort(); } } while(0)
-		do {
-			VERILY_READ(&cmd, 1);
-			
-			switch (cmd) {
-			case 1:
-				printf("CMD: wait\n");
-				csb->ext_event(TRACE_WFI);
-				break;
-			case 2: {
-				uint32_t addr;
-				uint32_t data;
-			
-				VERILY_READ(&addr, 4);
-				VERILY_READ(&data, 4);
-				printf("CMD: write_reg %08x %08x\n", addr, data);
-				csb->write(addr, data);
-				break;
-			}
-			case 3: {
-				uint32_t addr;
-				uint32_t mask;
-				uint32_t data;
-				
-				VERILY_READ(&addr, 4);
-				VERILY_READ(&mask, 4);
-				VERILY_READ(&data, 4);
-				printf("CMD: read_reg %08x %08x %08x\n", addr, mask, data);
-				csb->read(addr, mask, data);
-				break;
-			}
-			case 4: {
-				uint32_t addr;
-				uint32_t len;
-				uint8_t *buf;
-				uint32_t namelen;
-				char *fname;
-				axi_op op;
-				
-				VERILY_READ(&addr, 4);
-				VERILY_READ(&len, 4);
-				buf = (uint8_t *)malloc(len);
-				VERILY_READ(buf, len);
-				
-				VERILY_READ(&namelen, 4);
-				fname = (char *) malloc(namelen+1);
-				VERILY_READ(fname, namelen);
-				fname[namelen] = 0;
-				
-				op.opcode = AXI_DUMPMEM;
-				op.addr = addr;
-				op.len = len;
-				op.buf = buf;
-				op.fname = fname;
-				opq.push(op);
-				csb->ext_event(TRACE_AXIEVENT);
-				
-				printf("CMD: dump_mem %08x bytes from %08x -> %s\n", len, addr, fname);
-				break;
-			}
-			case 5: {
-				uint32_t addr;
-				uint32_t len;
-				uint8_t *buf;
-				axi_op op;
-				
-				VERILY_READ(&addr, 4);
-				VERILY_READ(&len, 4);
-				buf = (uint8_t *)malloc(len);
-				VERILY_READ(buf, len);
-				
-				op.opcode = AXI_LOADMEM;
-				op.addr = addr;
-				op.len = len;
-				op.buf = buf;
-				opq.push(op);
-				csb->ext_event(TRACE_AXIEVENT);
-				
-				printf("CMD: load_mem %08x bytes to %08x\n", len, addr);
-				break;
-			}
-			case 0xFF:
-				printf("CMD: done\n");
-				break;
-			default:
-				printf("unknown command %c\n", cmd);
-				abort();
-			}
-		} while (cmd != 0xFF);
-		
-		close(fd);
-	}
-	
-	void axievent() {
-		if (opq.empty()) {
-			printf("extevent with nothing in the queue?\n");
-			abort();
-		}
-		
-		axi_op &op = opq.front();
-		
-		AXIResponder<uint64_t> *axi;
-		if ((op.addr & 0xF0000000) == 0x50000000)
-			axi = axi_cvsram;
-		else if ((op.addr & 0xF0000000) == 0x80000000)
-			axi = axi_dbb;
-		else {
-			printf("AXI event to bad offset\n");
-			abort();
-		}
-		
-		switch(op.opcode) {
-		case AXI_LOADMEM: {
-			const uint8_t *buf = op.buf;
-			
-			printf("AXI: loading memory at 0x%08x\n", op.addr);
-			while (op.len) {
-				axi->write(op.addr, *buf);
-				buf++;
-				op.addr++;
-				op.len--;
-			}
-			break;
-		}
-		case AXI_DUMPMEM: {
-			int fd;
-			const uint8_t *buf = op.buf;
-			int matched = 1;
-			
-			printf("AXI: dumping memory to %s\n", op.fname);
-			fd = creat(op.fname, 0666);
-			if (!fd) {
-				perror("creat(dumpmem)");
-				break;
-			}
-			while (op.len) {
-				uint8_t da = axi->read(op.addr);
-				write(fd, &da, 1);
-				if (da != *buf && matched) {
-					printf("AXI: FAIL: mismatch at memory address %08x (exp 0x%02x, got 0x%02x), and maybe others too\n", op.addr, *buf, da);
-					matched = 0;
-					_test_passed = 0;
-				}
-				buf++;
-				op.addr++;
-				op.len--;
-			}
-			close(fd);
-			
-			if (matched)
-				printf("AXI: memory dump matched reference\n");
-			break;
-		}
-		default:
-			abort();
-		}
-		
-		opq.pop();
-	}
-	
-	int test_passed() {
-		return _test_passed;
-	}
+        do {
+            VERILY_READ(&cmd, 1);
+
+            switch (cmd) {
+                case 1:
+                    printf("CMD: wait\n");
+                    csb->ext_event(TRACE_WFI);
+                    break;
+                case 2: {
+                    uint32_t addr;
+                    uint32_t data;
+
+                    VERILY_READ(&addr, 4);
+                    VERILY_READ(&data, 4);
+                    printf("CMD: write_reg %08x %08x\n", addr, data);
+                    csb->write(addr, data);
+                    break;
+                }
+                case 3: {
+                    uint32_t addr;
+                    uint32_t mask;
+                    uint32_t data;
+
+                    VERILY_READ(&addr, 4);
+                    VERILY_READ(&mask, 4);
+                    VERILY_READ(&data, 4);
+                    printf("CMD: read_reg %08x %08x %08x\n", addr, mask, data);
+                    csb->read(addr, mask, data);
+                    break;
+                }
+                case 4: {
+                    uint32_t addr;
+                    uint32_t len;
+                    uint8_t *buf;
+                    uint32_t namelen;
+                    char *fname;
+                    axi_op op;
+
+                    VERILY_READ(&addr, 4);
+                    VERILY_READ(&len, 4);
+                    buf = (uint8_t *)malloc(len);
+                    VERILY_READ(buf, len);
+
+                    VERILY_READ(&namelen, 4);
+                    fname = (char *) malloc(namelen+1);
+                    VERILY_READ(fname, namelen);
+                    fname[namelen] = 0;
+
+                    op.opcode = AXI_DUMPMEM;
+                    op.addr = addr;
+                    op.len = len;
+                    op.buf = buf;
+                    op.fname = fname;
+                    opq.push(op);
+                    csb->ext_event(TRACE_AXIEVENT);
+
+                    printf("CMD: dump_mem %08x bytes from %08x -> %s\n", len, addr, fname);
+                    break;
+                }
+                case 5: {
+                    uint32_t addr;
+                    uint32_t len;
+                    uint8_t *buf;
+                    axi_op op;
+
+                    VERILY_READ(&addr, 4);
+                    VERILY_READ(&len, 4);
+                    buf = (uint8_t *)malloc(len);
+                    VERILY_READ(buf, len);
+
+                    op.opcode = AXI_LOADMEM;
+                    op.addr = addr;
+                    op.len = len;
+                    op.buf = buf;
+                    opq.push(op);
+                    csb->ext_event(TRACE_AXIEVENT);
+
+                    printf("CMD: load_mem %08x bytes to %08x\n", len, addr);
+                    break;
+                }
+                case 6: {
+                    uint32_t addr;
+                    uint32_t data;
+
+                    VERILY_READ(&addr, 4);
+                    VERILY_READ(&data, 4);
+                    printf("CMD: until %08x %08x\n", addr, data);
+                    csb->wait_until(addr, uint32_t(0xffffffff), data);
+                    break;
+                }
+                case 0xFF:
+                    printf("CMD: done\n");
+                    break;
+                default:
+                    printf("unknown command %c\n", cmd);
+                    abort();
+            }
+        } while (cmd != 0xFF);
+
+        close(fd);
+    }
+
+    void axievent() {
+        if (opq.empty()) {
+            printf("extevent with nothing in the queue?\n");
+            abort();
+        }
+
+        axi_op &op = opq.front();
+
+        AXIResponder<uint64_t> *axi;
+        if ((op.addr & 0xF0000000) == 0x50000000)
+            axi = axi_cvsram;
+        else if ((op.addr & 0xF0000000) == 0xc0000000)
+            axi = axi_dbb;
+        else {
+            printf("AXI event to bad offset\n");
+            abort();
+        }
+
+        switch(op.opcode) {
+            case AXI_LOADMEM: {
+                const uint8_t *buf = op.buf;
+
+                printf("AXI: loading memory at 0x%08x\n", op.addr);
+                while (op.len) {
+                    axi->write(op.addr, *buf);
+                    buf++;
+                    op.addr++;
+                    op.len--;
+                }
+                break;
+            }
+            case AXI_DUMPMEM: {
+                int fd;
+                const uint8_t *buf = op.buf;
+                int matched = 1;
+
+                printf("AXI: dumping memory to %s\n", op.fname);
+                fd = creat(op.fname, 0666);
+                if (!fd) {
+                    perror("creat(dumpmem)");
+                    break;
+                }
+                while (op.len) {
+                    uint8_t da = axi->read(op.addr);
+                    write(fd, &da, 1);
+                    if (da != *buf && matched) {
+                        printf("AXI: FAIL: mismatch at memory address %08x (exp 0x%02x, got 0x%02x), and maybe others too\n", op.addr, *buf, da);
+                        matched = 0;
+                        _test_passed = 0;
+                    }
+                    buf++;
+                    op.addr++;
+                    op.len--;
+                }
+                close(fd);
+
+                if (matched)
+                    printf("AXI: memory dump matched reference\n");
+                break;
+            }
+            default:
+                abort();
+        }
+
+        opq.pop();
+    }
+
+    int test_passed() {
+        return _test_passed;
+    }
 };
 
 int main(int argc, const char **argv, char **env) {
-	VNV_nvdla *dla = new VNV_nvdla;
-	CSBMaster *csb = new CSBMaster(dla);
-	
-	AXIResponder<uint64_t>::connections dbbconn = {
-		.aw_awvalid = &dla->nvdla_core2dbb_aw_awvalid,
-		.aw_awready = &dla->nvdla_core2dbb_aw_awready,
-		.aw_awid = &dla->nvdla_core2dbb_aw_awid,
-		.aw_awlen = &dla->nvdla_core2dbb_aw_awlen,
-		.aw_awaddr = &dla->nvdla_core2dbb_aw_awaddr,
-		
-		.w_wvalid = &dla->nvdla_core2dbb_w_wvalid,
-		.w_wready = &dla->nvdla_core2dbb_w_wready,
-		.w_wdata = dla->nvdla_core2dbb_w_wdata,
-		.w_wstrb = &dla->nvdla_core2dbb_w_wstrb,
-		.w_wlast = &dla->nvdla_core2dbb_w_wlast,
-		
-		.b_bvalid = &dla->nvdla_core2dbb_b_bvalid,
-		.b_bready = &dla->nvdla_core2dbb_b_bready,
-		.b_bid = &dla->nvdla_core2dbb_b_bid,
-
-		.ar_arvalid = &dla->nvdla_core2dbb_ar_arvalid,
-		.ar_arready = &dla->nvdla_core2dbb_ar_arready,
-		.ar_arid = &dla->nvdla_core2dbb_ar_arid,
-		.ar_arlen = &dla->nvdla_core2dbb_ar_arlen,
-		.ar_araddr = &dla->nvdla_core2dbb_ar_araddr,
-	
-		.r_rvalid = &dla->nvdla_core2dbb_r_rvalid,
-		.r_rready = &dla->nvdla_core2dbb_r_rready,
-		.r_rid = &dla->nvdla_core2dbb_r_rid,
-		.r_rlast = &dla->nvdla_core2dbb_r_rlast,
-		.r_rdata = dla->nvdla_core2dbb_r_rdata,
-	};
-	AXIResponder<uint64_t> *axi_dbb = new AXIResponder<uint64_t>(dbbconn, "DBB");
-
-	AXIResponder<uint64_t>::connections cvsramconn = {
-		.aw_awvalid = &dla->nvdla_core2cvsram_aw_awvalid,
-		.aw_awready = &dla->nvdla_core2cvsram_aw_awready,
-		.aw_awid = &dla->nvdla_core2cvsram_aw_awid,
-		.aw_awlen = &dla->nvdla_core2cvsram_aw_awlen,
-		.aw_awaddr = &dla->nvdla_core2cvsram_aw_awaddr,
-		
-		.w_wvalid = &dla->nvdla_core2cvsram_w_wvalid,
-		.w_wready = &dla->nvdla_core2cvsram_w_wready,
-		.w_wdata = dla->nvdla_core2cvsram_w_wdata,
-		.w_wstrb = &dla->nvdla_core2cvsram_w_wstrb,
-		.w_wlast = &dla->nvdla_core2cvsram_w_wlast,
-		
-		.b_bvalid = &dla->nvdla_core2cvsram_b_bvalid,
-		.b_bready = &dla->nvdla_core2cvsram_b_bready,
-		.b_bid = &dla->nvdla_core2cvsram_b_bid,
-
-		.ar_arvalid = &dla->nvdla_core2cvsram_ar_arvalid,
-		.ar_arready = &dla->nvdla_core2cvsram_ar_arready,
-		.ar_arid = &dla->nvdla_core2cvsram_ar_arid,
-		.ar_arlen = &dla->nvdla_core2cvsram_ar_arlen,
-		.ar_araddr = &dla->nvdla_core2cvsram_ar_araddr,
-	
-		.r_rvalid = &dla->nvdla_core2cvsram_r_rvalid,
-		.r_rready = &dla->nvdla_core2cvsram_r_rready,
-		.r_rid = &dla->nvdla_core2cvsram_r_rid,
-		.r_rlast = &dla->nvdla_core2cvsram_r_rlast,
-		.r_rdata = dla->nvdla_core2cvsram_r_rdata,
-	};
-	AXIResponder<uint64_t> *axi_cvsram = new AXIResponder<uint64_t>(cvsramconn, "CVSRAM");
-
-	TraceLoader *trace = new TraceLoader(csb, axi_dbb, axi_cvsram);
+    VNV_nvdla *dla = new VNV_nvdla;
+    CSBMaster *csb = new CSBMaster(dla);
+
+    AXIResponder<uint64_t>::connections dbbconn = {
+            .aw_awvalid = &dla->nvdla_core2dbb_aw_awvalid,
+            .aw_awready = &dla->nvdla_core2dbb_aw_awready,
+            .aw_awid = &dla->nvdla_core2dbb_aw_awid,
+            .aw_awlen = &dla->nvdla_core2dbb_aw_awlen,
+            .aw_awaddr = &dla->nvdla_core2dbb_aw_awaddr,
+
+            .w_wvalid = &dla->nvdla_core2dbb_w_wvalid,
+            .w_wready = &dla->nvdla_core2dbb_w_wready,
+            .w_wdata = dla->nvdla_core2dbb_w_wdata,
+            .w_wstrb = &dla->nvdla_core2dbb_w_wstrb,
+            .w_wlast = &dla->nvdla_core2dbb_w_wlast,
+
+            .b_bvalid = &dla->nvdla_core2dbb_b_bvalid,
+            .b_bready = &dla->nvdla_core2dbb_b_bready,
+            .b_bid = &dla->nvdla_core2dbb_b_bid,
+
+            .ar_arvalid = &dla->nvdla_core2dbb_ar_arvalid,
+            .ar_arready = &dla->nvdla_core2dbb_ar_arready,
+            .ar_arid = &dla->nvdla_core2dbb_ar_arid,
+            .ar_arlen = &dla->nvdla_core2dbb_ar_arlen,
+            .ar_araddr = &dla->nvdla_core2dbb_ar_araddr,
+
+            .r_rvalid = &dla->nvdla_core2dbb_r_rvalid,
+            .r_rready = &dla->nvdla_core2dbb_r_rready,
+            .r_rid = &dla->nvdla_core2dbb_r_rid,
+            .r_rlast = &dla->nvdla_core2dbb_r_rlast,
+            .r_rdata = dla->nvdla_core2dbb_r_rdata,
+    };
+    AXIResponder<uint64_t> *axi_dbb = new AXIResponder<uint64_t>(dbbconn, "DBB");
+
+    AXIResponder<uint64_t>::connections cvsramconn = {
+            .aw_awvalid = &dla->nvdla_core2cvsram_aw_awvalid,
+            .aw_awready = &dla->nvdla_core2cvsram_aw_awready,
+            .aw_awid = &dla->nvdla_core2cvsram_aw_awid,
+            .aw_awlen = &dla->nvdla_core2cvsram_aw_awlen,
+            .aw_awaddr = &dla->nvdla_core2cvsram_aw_awaddr,
+
+            .w_wvalid = &dla->nvdla_core2cvsram_w_wvalid,
+            .w_wready = &dla->nvdla_core2cvsram_w_wready,
+            .w_wdata = dla->nvdla_core2cvsram_w_wdata,
+            .w_wstrb = &dla->nvdla_core2cvsram_w_wstrb,
+            .w_wlast = &dla->nvdla_core2cvsram_w_wlast,
+
+            .b_bvalid = &dla->nvdla_core2cvsram_b_bvalid,
+            .b_bready = &dla->nvdla_core2cvsram_b_bready,
+            .b_bid = &dla->nvdla_core2cvsram_b_bid,
+
+            .ar_arvalid = &dla->nvdla_core2cvsram_ar_arvalid,
+            .ar_arready = &dla->nvdla_core2cvsram_ar_arready,
+            .ar_arid = &dla->nvdla_core2cvsram_ar_arid,
+            .ar_arlen = &dla->nvdla_core2cvsram_ar_arlen,
+            .ar_araddr = &dla->nvdla_core2cvsram_ar_araddr,
+
+            .r_rvalid = &dla->nvdla_core2cvsram_r_rvalid,
+            .r_rready = &dla->nvdla_core2cvsram_r_rready,
+            .r_rid = &dla->nvdla_core2cvsram_r_rid,
+            .r_rlast = &dla->nvdla_core2cvsram_r_rlast,
+            .r_rdata = dla->nvdla_core2cvsram_r_rdata,
+    };
+    AXIResponder<uint64_t> *axi_cvsram = new AXIResponder<uint64_t>(cvsramconn, "CVSRAM");
+
+    TraceLoader *trace = new TraceLoader(csb, axi_dbb, axi_cvsram);
 
 #if VM_TRACE
-	Verilated::traceEverOn(true);
+    Verilated::traceEverOn(true);
 	tfp = new VerilatedVcdC;
 	dla->trace(tfp, 99);
 	tfp->open("trace.vcd");
 	atexit(_close_trace);
 #endif
-	
-	dla->global_clk_ovr_on = 0;
-	dla->tmc2slcg_disable_clock_gating = 0;
-	dla->test_mode = 0;
-	dla->nvdla_pwrbus_ram_c_pd = 0;
-	dla->nvdla_pwrbus_ram_ma_pd = 0;
-	dla->nvdla_pwrbus_ram_mb_pd = 0;
-	dla->nvdla_pwrbus_ram_p_pd = 0;
-	dla->nvdla_pwrbus_ram_o_pd = 0;
-	dla->nvdla_pwrbus_ram_a_pd = 0;
-
-	Verilated::commandArgs(argc, argv);
-	if (argc != 2) {
-		fprintf(stderr, "nvdla requires exactly one parameter (a trace file)\n");
-		return 1;
-	}
-	
-	trace->load(argv[1]);
-
-	printf("reset...\n");
-	dla->dla_reset_rstn = 1;
-	dla->direct_reset_ = 1;
-	dla->eval();
-	for (int i = 0; i < 20; i++) {
-		dla->dla_core_clk = 1;
-		dla->dla_csb_clk = 1;
-		dla->eval();
-		ticks++;
+
+    dla->global_clk_ovr_on = 0;
+    dla->tmc2slcg_disable_clock_gating = 0;
+    dla->test_mode = 0;
+    dla->nvdla_pwrbus_ram_c_pd = 0;
+    dla->nvdla_pwrbus_ram_ma_pd = 0;
+    dla->nvdla_pwrbus_ram_mb_pd = 0;
+    dla->nvdla_pwrbus_ram_p_pd = 0;
+    dla->nvdla_pwrbus_ram_o_pd = 0;
+    dla->nvdla_pwrbus_ram_a_pd = 0;
+
+    Verilated::commandArgs(argc, argv);
+    if (argc != 2) {
+        fprintf(stderr, "nvdla requires exactly one parameter (a trace file)\n");
+        return 1;
+    }
+
+    trace->load(argv[1]);
+
+    printf("reset...\n");
+    dla->dla_reset_rstn = 1;
+    dla->direct_reset_ = 1;
+    dla->eval();
+    for (int i = 0; i < 20; i++) {
+        dla->dla_core_clk = 1;
+        dla->dla_csb_clk = 1;
+        dla->eval();
+        ticks++;
 #if VM_TRACE
-		tfp->dump(ticks);
+        tfp->dump(ticks);
 #endif
-		
-		dla->dla_core_clk = 0;
-		dla->dla_csb_clk = 0;
-		dla->eval();
-		ticks++;
+
+        dla->dla_core_clk = 0;
+        dla->dla_csb_clk = 0;
+        dla->eval();
+        ticks++;
 #if VM_TRACE
-		tfp->dump(ticks);
+        tfp->dump(ticks);
 #endif
-	}
-
-	dla->dla_reset_rstn = 0;
-	dla->direct_reset_ = 0;
-	dla->eval();
-	
-	for (int i = 0; i < 20; i++) {
-		dla->dla_core_clk = 1;
-		dla->dla_csb_clk = 1;
-		dla->eval();
-		ticks++;
+    }
+
+    dla->dla_reset_rstn = 0;
+    dla->direct_reset_ = 0;
+    dla->eval();
+
+    for (int i = 0; i < 20; i++) {
+        dla->dla_core_clk = 1;
+        dla->dla_csb_clk = 1;
+        dla->eval();
+        ticks++;
 #if VM_TRACE
-		tfp->dump(ticks);
+        tfp->dump(ticks);
 #endif
-		
-		dla->dla_core_clk = 0;
-		dla->dla_csb_clk = 0;
-		dla->eval();
-		ticks++;
+
+        dla->dla_core_clk = 0;
+        dla->dla_csb_clk = 0;
+        dla->eval();
+        ticks++;
 #if VM_TRACE
-		tfp->dump(ticks);
+        tfp->dump(ticks);
 #endif
-	}
-	
-	dla->dla_reset_rstn = 1;
-	dla->direct_reset_ = 1;
-	
-	printf("letting buffers clear after reset...\n");
-	for (int i = 0; i < 4096; i++) {
-		dla->dla_core_clk = 1;
-		dla->dla_csb_clk = 1;
-		dla->eval();
-		ticks++;
+    }
+
+    dla->dla_reset_rstn = 1;
+    dla->direct_reset_ = 1;
+
+    printf("letting buffers clear after reset...\n");
+    for (int i = 0; i < 4096; i++) {
+        dla->dla_core_clk = 1;
+        dla->dla_csb_clk = 1;
+        dla->eval();
+        ticks++;
 #if VM_TRACE
-		tfp->dump(ticks);
+        tfp->dump(ticks);
 #endif
-		
-		dla->dla_core_clk = 0;
-		dla->dla_csb_clk = 0;
-		dla->eval();
-		ticks++;
+
+        dla->dla_core_clk = 0;
+        dla->dla_csb_clk = 0;
+        dla->eval();
+        ticks++;
 #if VM_TRACE
-		tfp->dump(ticks);
+        tfp->dump(ticks);
 #endif
-	}
-
-	printf("running trace...\n");
-	uint32_t quiesc_timer = 200;
-	int waiting = 0;
-	while (!csb->done() || (quiesc_timer--)) {
-		int extevent;
-		
-		extevent = csb->eval(waiting);
-		
-		if (extevent == TraceLoader::TRACE_AXIEVENT)
-			trace->axievent();
-		else if (extevent == TraceLoader::TRACE_WFI) {
-			waiting = 1;
-			printf("(%lu) waiting for interrupt...\n", ticks);
-		}
-		
-		if (waiting && dla->dla_intr) {
-			printf("(%lu) interrupt!\n", ticks);
-			waiting = 0;
-		}
-			
-		axi_dbb->eval();
-		axi_cvsram->eval();
-
-		dla->dla_core_clk = 1;
-		dla->dla_csb_clk = 1;
-		dla->eval();
-		ticks++;
+    }
+
+    printf("running trace...\n");
+    uint32_t quiesc_timer = 200;
+    int waiting = 0;
+    while (!csb->done() || (quiesc_timer--)) {
+        int extevent;
+
+        extevent = csb->eval(waiting);
+
+        if (extevent == TraceLoader::TRACE_AXIEVENT)
+            trace->axievent();
+        else if (extevent == TraceLoader::TRACE_WFI) {
+            waiting = 1;
+            printf("(%lu) waiting for interrupt...\n", ticks);
+        }
+
+        if (waiting && dla->dla_intr) {
+            printf("(%lu) interrupt!\n", ticks);
+            waiting = 0;
+        }
+
+        axi_dbb->eval();
+        axi_cvsram->eval();
+
+        dla->dla_core_clk = 1;
+        dla->dla_csb_clk = 1;
+        dla->eval();
+        ticks++;
 #if VM_TRACE
-		tfp->dump(ticks);
+        tfp->dump(ticks);
 #endif
-		
-		dla->dla_core_clk = 0;
-		dla->dla_csb_clk = 0;
-		dla->eval();
-		ticks++;
+
+        dla->dla_core_clk = 0;
+        dla->dla_csb_clk = 0;
+        dla->eval();
+        ticks++;
 #if VM_TRACE
-		tfp->dump(ticks);
+        tfp->dump(ticks);
 #endif
-	}
-	
-	printf("done at %lu ticks\n", ticks);
-
-	if (!trace->test_passed()) {
-		printf("*** FAIL: test failed due to output mismatch\n");
-		return 1;
-	}
-	
-	if (!csb->test_passed()) {
-		printf("*** FAIL: test failed due to CSB read mismatch\n");
-		return 2;
-	}
-	
-	printf("*** PASS\n");
-	
-	return 0;
+    }
+
+    printf("done at %lu ticks\n", ticks);
+    delete dla;
+
+    if (!trace->test_passed()) {
+        printf("*** FAIL: test failed due to output mismatch\n");
+        return 1;
+    }
+
+    if (!csb->test_passed()) {
+        printf("*** FAIL: test failed due to CSB read mismatch\n");
+        return 2;
+    }
+
+    printf("*** PASS\n");
+
+    return 0;
 }
diff --git a/vmod/nvdla/cmac/NV_NVDLA_CMAC_CORE_mac.v b/vmod/nvdla/cmac/NV_NVDLA_CMAC_CORE_mac.v
index 677f92d..76ef6d1 100644
--- a/vmod/nvdla/cmac/NV_NVDLA_CMAC_CORE_mac.v
+++ b/vmod/nvdla/cmac/NV_NVDLA_CMAC_CORE_mac.v
@@ -340,14 +340,14 @@ wire      [7:0] ps_n1_in_b4;
 wire      [7:0] ps_n1_in_b5;
 wire      [7:0] ps_n1_in_b6;
 wire      [7:0] ps_n1_in_b7;
-wire      [6:0] ps_n1b0;
-wire      [6:0] ps_n1b1;
-wire      [6:0] ps_n1b2;
-wire      [6:0] ps_n1b3;
-wire      [6:0] ps_n1b4;
-wire      [6:0] ps_n1b5;
-wire      [6:0] ps_n1b6;
-wire      [6:0] ps_n1b7;
+wire      [5:0] ps_n1b0; wire ps_n1b0_6;
+wire      [5:0] ps_n1b1; wire ps_n1b1_6;
+wire      [5:0] ps_n1b2; wire ps_n1b2_6;
+wire      [5:0] ps_n1b3; wire ps_n1b3_6;
+wire      [5:0] ps_n1b4; wire ps_n1b4_6;
+wire      [5:0] ps_n1b5; wire ps_n1b5_6;
+wire      [5:0] ps_n1b6; wire ps_n1b6_6;
+wire      [5:0] ps_n1b7; wire ps_n1b7_6;
 wire      [7:0] ps_n2_in_b0;
 wire      [7:0] ps_n2_in_b1;
 wire      [7:0] ps_n2_in_b2;
@@ -356,14 +356,14 @@ wire      [7:0] ps_n2_in_b4;
 wire      [7:0] ps_n2_in_b5;
 wire      [7:0] ps_n2_in_b6;
 wire      [7:0] ps_n2_in_b7;
-wire      [6:0] ps_n2b0;
-wire      [6:0] ps_n2b1;
-wire      [6:0] ps_n2b2;
-wire      [6:0] ps_n2b3;
-wire      [6:0] ps_n2b4;
-wire      [6:0] ps_n2b5;
-wire      [6:0] ps_n2b6;
-wire      [6:0] ps_n2b7;
+wire      [5:0] ps_n2b0; wire ps_n2b0_6;
+wire      [5:0] ps_n2b1; wire ps_n2b1_6;
+wire      [5:0] ps_n2b2; wire ps_n2b2_6;
+wire      [5:0] ps_n2b3; wire ps_n2b3_6;
+wire      [5:0] ps_n2b4; wire ps_n2b4_6;
+wire      [5:0] ps_n2b5; wire ps_n2b5_6;
+wire      [5:0] ps_n2b6; wire ps_n2b6_6;
+wire      [5:0] ps_n2b7; wire ps_n2b7_6;
 wire      [7:0] ps_n3_in_b0;
 wire      [7:0] ps_n3_in_b1;
 wire      [7:0] ps_n3_in_b2;
@@ -372,14 +372,14 @@ wire      [7:0] ps_n3_in_b4;
 wire      [7:0] ps_n3_in_b5;
 wire      [7:0] ps_n3_in_b6;
 wire      [7:0] ps_n3_in_b7;
-wire      [6:0] ps_n3b0;
-wire      [6:0] ps_n3b1;
-wire      [6:0] ps_n3b2;
-wire      [6:0] ps_n3b3;
-wire      [6:0] ps_n3b4;
-wire      [6:0] ps_n3b5;
-wire      [6:0] ps_n3b6;
-wire      [6:0] ps_n3b7;
+wire      [5:0] ps_n3b0; wire ps_n3b0_6;
+wire      [5:0] ps_n3b1; wire ps_n3b1_6;
+wire      [5:0] ps_n3b2; wire ps_n3b2_6;
+wire      [5:0] ps_n3b3; wire ps_n3b3_6;
+wire      [5:0] ps_n3b4; wire ps_n3b4_6;
+wire      [5:0] ps_n3b5; wire ps_n3b5_6;
+wire      [5:0] ps_n3b6; wire ps_n3b6_6;
+wire      [5:0] ps_n3b7; wire ps_n3b7_6;
 wire     [15:0] ps_out_l1n0_0;
 wire     [15:0] ps_out_l1n0_1;
 wire     [15:0] ps_out_l1n10_0;
@@ -8561,17 +8561,17 @@ assign ps_n0b0[6:0] = (cfg_is_wg_d1[8]) ? {1'b0, ps_n0b0_wg} : ps_n0b0_dc;
 assign ps_n1b0[5:0] = res_tag_b0_sum_1  - res_tag_b0_sum_2  - res_tag_b0_sum_3  +
                          res_tag_b0_sum_5  - res_tag_b0_sum_6  - res_tag_b0_sum_7  +
                          res_tag_b0_sum_9  - res_tag_b0_sum_10 - res_tag_b0_sum_11;
-assign ps_n1b0[6] = ps_n1b0[5];
+assign ps_n1b0_6 = ps_n1b0[5];
 
 assign ps_n2b0[5:0] = res_tag_b0_sum_4  + res_tag_b0_sum_5  + res_tag_b0_sum_6  -
                          res_tag_b0_sum_8  - res_tag_b0_sum_9  - res_tag_b0_sum_10 -
                          res_tag_b0_sum_12 - res_tag_b0_sum_13 - res_tag_b0_sum_14;
-assign ps_n2b0[6] = ps_n2b0[5];
+assign ps_n2b0_6 = ps_n2b0[5];
 
 assign ps_n3b0[5:0] = res_tag_b0_sum_5  - res_tag_b0_sum_6  - res_tag_b0_sum_7  -
                          res_tag_b0_sum_9  + res_tag_b0_sum_10 + res_tag_b0_sum_11 -
                          res_tag_b0_sum_13 + res_tag_b0_sum_14 + res_tag_b0_sum_15;
-assign ps_n3b0[6] = ps_n3b0[5];
+assign ps_n3b0_6 = ps_n3b0[5];
 
 assign ps_n0b1_dc[6:0] = res_tag_b1_sum_15 + res_tag_b1_sum_14 + res_tag_b1_sum_13 + res_tag_b1_sum_12 + res_tag_b1_sum_11 + res_tag_b1_sum_10 + res_tag_b1_sum_9 + res_tag_b1_sum_8 + res_tag_b1_sum_7 + res_tag_b1_sum_6 + res_tag_b1_sum_5 + res_tag_b1_sum_4 + res_tag_b1_sum_3 + res_tag_b1_sum_2 + res_tag_b1_sum_1 + res_tag_b1_sum_0;
 assign ps_n0b1_wg[5:0] = res_tag_b1_sum_0  + res_tag_b1_sum_1  + res_tag_b1_sum_2  +
@@ -8582,17 +8582,17 @@ assign ps_n0b1[6:0] = (cfg_is_wg_d1[9]) ? {1'b0, ps_n0b1_wg} : ps_n0b1_dc;
 assign ps_n1b1[5:0] = res_tag_b1_sum_1  - res_tag_b1_sum_2  - res_tag_b1_sum_3  +
                          res_tag_b1_sum_5  - res_tag_b1_sum_6  - res_tag_b1_sum_7  +
                          res_tag_b1_sum_9  - res_tag_b1_sum_10 - res_tag_b1_sum_11;
-assign ps_n1b1[6] = ps_n1b1[5];
+assign ps_n1b1_6 = ps_n1b1[5];
 
 assign ps_n2b1[5:0] = res_tag_b1_sum_4  + res_tag_b1_sum_5  + res_tag_b1_sum_6  -
                          res_tag_b1_sum_8  - res_tag_b1_sum_9  - res_tag_b1_sum_10 -
                          res_tag_b1_sum_12 - res_tag_b1_sum_13 - res_tag_b1_sum_14;
-assign ps_n2b1[6] = ps_n2b1[5];
+assign ps_n2b1_6 = ps_n2b1[5];
 
 assign ps_n3b1[5:0] = res_tag_b1_sum_5  - res_tag_b1_sum_6  - res_tag_b1_sum_7  -
                          res_tag_b1_sum_9  + res_tag_b1_sum_10 + res_tag_b1_sum_11 -
                          res_tag_b1_sum_13 + res_tag_b1_sum_14 + res_tag_b1_sum_15;
-assign ps_n3b1[6] = ps_n3b1[5];
+assign ps_n3b1_6 = ps_n3b1[5];
 
 assign ps_n0b2_dc[6:0] = res_tag_b2_sum_15 + res_tag_b2_sum_14 + res_tag_b2_sum_13 + res_tag_b2_sum_12 + res_tag_b2_sum_11 + res_tag_b2_sum_10 + res_tag_b2_sum_9 + res_tag_b2_sum_8 + res_tag_b2_sum_7 + res_tag_b2_sum_6 + res_tag_b2_sum_5 + res_tag_b2_sum_4 + res_tag_b2_sum_3 + res_tag_b2_sum_2 + res_tag_b2_sum_1 + res_tag_b2_sum_0;
 assign ps_n0b2_wg[5:0] = res_tag_b2_sum_0  + res_tag_b2_sum_1  + res_tag_b2_sum_2  +
@@ -8603,17 +8603,17 @@ assign ps_n0b2[6:0] = (cfg_is_wg_d1[10]) ? {1'b0, ps_n0b2_wg} : ps_n0b2_dc;
 assign ps_n1b2[5:0] = res_tag_b2_sum_1  - res_tag_b2_sum_2  - res_tag_b2_sum_3  +
                          res_tag_b2_sum_5  - res_tag_b2_sum_6  - res_tag_b2_sum_7  +
                          res_tag_b2_sum_9  - res_tag_b2_sum_10 - res_tag_b2_sum_11;
-assign ps_n1b2[6] = ps_n1b2[5];
+assign ps_n1b2_6 = ps_n1b2[5];
 
 assign ps_n2b2[5:0] = res_tag_b2_sum_4  + res_tag_b2_sum_5  + res_tag_b2_sum_6  -
                          res_tag_b2_sum_8  - res_tag_b2_sum_9  - res_tag_b2_sum_10 -
                          res_tag_b2_sum_12 - res_tag_b2_sum_13 - res_tag_b2_sum_14;
-assign ps_n2b2[6] = ps_n2b2[5];
+assign ps_n2b2_6 = ps_n2b2[5];
 
 assign ps_n3b2[5:0] = res_tag_b2_sum_5  - res_tag_b2_sum_6  - res_tag_b2_sum_7  -
                          res_tag_b2_sum_9  + res_tag_b2_sum_10 + res_tag_b2_sum_11 -
                          res_tag_b2_sum_13 + res_tag_b2_sum_14 + res_tag_b2_sum_15;
-assign ps_n3b2[6] = ps_n3b2[5];
+assign ps_n3b2_6 = ps_n3b2[5];
 
 assign ps_n0b3_dc[6:0] = res_tag_b3_sum_15 + res_tag_b3_sum_14 + res_tag_b3_sum_13 + res_tag_b3_sum_12 + res_tag_b3_sum_11 + res_tag_b3_sum_10 + res_tag_b3_sum_9 + res_tag_b3_sum_8 + res_tag_b3_sum_7 + res_tag_b3_sum_6 + res_tag_b3_sum_5 + res_tag_b3_sum_4 + res_tag_b3_sum_3 + res_tag_b3_sum_2 + res_tag_b3_sum_1 + res_tag_b3_sum_0;
 assign ps_n0b3_wg[5:0] = res_tag_b3_sum_0  + res_tag_b3_sum_1  + res_tag_b3_sum_2  +
@@ -8624,17 +8624,17 @@ assign ps_n0b3[6:0] = (cfg_is_wg_d1[11]) ? {1'b0, ps_n0b3_wg} : ps_n0b3_dc;
 assign ps_n1b3[5:0] = res_tag_b3_sum_1  - res_tag_b3_sum_2  - res_tag_b3_sum_3  +
                          res_tag_b3_sum_5  - res_tag_b3_sum_6  - res_tag_b3_sum_7  +
                          res_tag_b3_sum_9  - res_tag_b3_sum_10 - res_tag_b3_sum_11;
-assign ps_n1b3[6] = ps_n1b3[5];
+assign ps_n1b3_6 = ps_n1b3[5];
 
 assign ps_n2b3[5:0] = res_tag_b3_sum_4  + res_tag_b3_sum_5  + res_tag_b3_sum_6  -
                          res_tag_b3_sum_8  - res_tag_b3_sum_9  - res_tag_b3_sum_10 -
                          res_tag_b3_sum_12 - res_tag_b3_sum_13 - res_tag_b3_sum_14;
-assign ps_n2b3[6] = ps_n2b3[5];
+assign ps_n2b3_6 = ps_n2b3[5];
 
 assign ps_n3b3[5:0] = res_tag_b3_sum_5  - res_tag_b3_sum_6  - res_tag_b3_sum_7  -
                          res_tag_b3_sum_9  + res_tag_b3_sum_10 + res_tag_b3_sum_11 -
                          res_tag_b3_sum_13 + res_tag_b3_sum_14 + res_tag_b3_sum_15;
-assign ps_n3b3[6] = ps_n3b3[5];
+assign ps_n3b3_6 = ps_n3b3[5];
 
 assign ps_n0b4_dc[6:0] = res_tag_b4_sum_15 + res_tag_b4_sum_14 + res_tag_b4_sum_13 + res_tag_b4_sum_12 + res_tag_b4_sum_11 + res_tag_b4_sum_10 + res_tag_b4_sum_9 + res_tag_b4_sum_8 + res_tag_b4_sum_7 + res_tag_b4_sum_6 + res_tag_b4_sum_5 + res_tag_b4_sum_4 + res_tag_b4_sum_3 + res_tag_b4_sum_2 + res_tag_b4_sum_1 + res_tag_b4_sum_0;
 assign ps_n0b4_wg[5:0] = res_tag_b4_sum_0  + res_tag_b4_sum_1  + res_tag_b4_sum_2  +
@@ -8645,17 +8645,17 @@ assign ps_n0b4[6:0] = (cfg_is_wg_d1[12]) ? {1'b0, ps_n0b4_wg} : ps_n0b4_dc;
 assign ps_n1b4[5:0] = res_tag_b4_sum_1  - res_tag_b4_sum_2  - res_tag_b4_sum_3  +
                          res_tag_b4_sum_5  - res_tag_b4_sum_6  - res_tag_b4_sum_7  +
                          res_tag_b4_sum_9  - res_tag_b4_sum_10 - res_tag_b4_sum_11;
-assign ps_n1b4[6] = ps_n1b4[5];
+assign ps_n1b4_6 = ps_n1b4[5];
 
 assign ps_n2b4[5:0] = res_tag_b4_sum_4  + res_tag_b4_sum_5  + res_tag_b4_sum_6  -
                          res_tag_b4_sum_8  - res_tag_b4_sum_9  - res_tag_b4_sum_10 -
                          res_tag_b4_sum_12 - res_tag_b4_sum_13 - res_tag_b4_sum_14;
-assign ps_n2b4[6] = ps_n2b4[5];
+assign ps_n2b4_6 = ps_n2b4[5];
 
 assign ps_n3b4[5:0] = res_tag_b4_sum_5  - res_tag_b4_sum_6  - res_tag_b4_sum_7  -
                          res_tag_b4_sum_9  + res_tag_b4_sum_10 + res_tag_b4_sum_11 -
                          res_tag_b4_sum_13 + res_tag_b4_sum_14 + res_tag_b4_sum_15;
-assign ps_n3b4[6] = ps_n3b4[5];
+assign ps_n3b4_6 = ps_n3b4[5];
 
 assign ps_n0b5_dc[6:0] = res_tag_b5_sum_15 + res_tag_b5_sum_14 + res_tag_b5_sum_13 + res_tag_b5_sum_12 + res_tag_b5_sum_11 + res_tag_b5_sum_10 + res_tag_b5_sum_9 + res_tag_b5_sum_8 + res_tag_b5_sum_7 + res_tag_b5_sum_6 + res_tag_b5_sum_5 + res_tag_b5_sum_4 + res_tag_b5_sum_3 + res_tag_b5_sum_2 + res_tag_b5_sum_1 + res_tag_b5_sum_0;
 assign ps_n0b5_wg[5:0] = res_tag_b5_sum_0  + res_tag_b5_sum_1  + res_tag_b5_sum_2  +
@@ -8666,17 +8666,17 @@ assign ps_n0b5[6:0] = (cfg_is_wg_d1[13]) ? {1'b0, ps_n0b5_wg} : ps_n0b5_dc;
 assign ps_n1b5[5:0] = res_tag_b5_sum_1  - res_tag_b5_sum_2  - res_tag_b5_sum_3  +
                          res_tag_b5_sum_5  - res_tag_b5_sum_6  - res_tag_b5_sum_7  +
                          res_tag_b5_sum_9  - res_tag_b5_sum_10 - res_tag_b5_sum_11;
-assign ps_n1b5[6] = ps_n1b5[5];
+assign ps_n1b5_6 = ps_n1b5[5];
 
 assign ps_n2b5[5:0] = res_tag_b5_sum_4  + res_tag_b5_sum_5  + res_tag_b5_sum_6  -
                          res_tag_b5_sum_8  - res_tag_b5_sum_9  - res_tag_b5_sum_10 -
                          res_tag_b5_sum_12 - res_tag_b5_sum_13 - res_tag_b5_sum_14;
-assign ps_n2b5[6] = ps_n2b5[5];
+assign ps_n2b5_6 = ps_n2b5[5];
 
 assign ps_n3b5[5:0] = res_tag_b5_sum_5  - res_tag_b5_sum_6  - res_tag_b5_sum_7  -
                          res_tag_b5_sum_9  + res_tag_b5_sum_10 + res_tag_b5_sum_11 -
                          res_tag_b5_sum_13 + res_tag_b5_sum_14 + res_tag_b5_sum_15;
-assign ps_n3b5[6] = ps_n3b5[5];
+assign ps_n3b5_6 = ps_n3b5[5];
 
 assign ps_n0b6_dc[6:0] = res_tag_b6_sum_15 + res_tag_b6_sum_14 + res_tag_b6_sum_13 + res_tag_b6_sum_12 + res_tag_b6_sum_11 + res_tag_b6_sum_10 + res_tag_b6_sum_9 + res_tag_b6_sum_8 + res_tag_b6_sum_7 + res_tag_b6_sum_6 + res_tag_b6_sum_5 + res_tag_b6_sum_4 + res_tag_b6_sum_3 + res_tag_b6_sum_2 + res_tag_b6_sum_1 + res_tag_b6_sum_0;
 assign ps_n0b6_wg[5:0] = res_tag_b6_sum_0  + res_tag_b6_sum_1  + res_tag_b6_sum_2  +
@@ -8687,17 +8687,17 @@ assign ps_n0b6[6:0] = (cfg_is_wg_d1[14]) ? {1'b0, ps_n0b6_wg} : ps_n0b6_dc;
 assign ps_n1b6[5:0] = res_tag_b6_sum_1  - res_tag_b6_sum_2  - res_tag_b6_sum_3  +
                          res_tag_b6_sum_5  - res_tag_b6_sum_6  - res_tag_b6_sum_7  +
                          res_tag_b6_sum_9  - res_tag_b6_sum_10 - res_tag_b6_sum_11;
-assign ps_n1b6[6] = ps_n1b6[5];
+assign ps_n1b6_6 = ps_n1b6[5];
 
 assign ps_n2b6[5:0] = res_tag_b6_sum_4  + res_tag_b6_sum_5  + res_tag_b6_sum_6  -
                          res_tag_b6_sum_8  - res_tag_b6_sum_9  - res_tag_b6_sum_10 -
                          res_tag_b6_sum_12 - res_tag_b6_sum_13 - res_tag_b6_sum_14;
-assign ps_n2b6[6] = ps_n2b6[5];
+assign ps_n2b6_6 = ps_n2b6[5];
 
 assign ps_n3b6[5:0] = res_tag_b6_sum_5  - res_tag_b6_sum_6  - res_tag_b6_sum_7  -
                          res_tag_b6_sum_9  + res_tag_b6_sum_10 + res_tag_b6_sum_11 -
                          res_tag_b6_sum_13 + res_tag_b6_sum_14 + res_tag_b6_sum_15;
-assign ps_n3b6[6] = ps_n3b6[5];
+assign ps_n3b6_6 = ps_n3b6[5];
 
 assign ps_n0b7_dc[6:0] = res_tag_b7_sum_15 + res_tag_b7_sum_14 + res_tag_b7_sum_13 + res_tag_b7_sum_12 + res_tag_b7_sum_11 + res_tag_b7_sum_10 + res_tag_b7_sum_9 + res_tag_b7_sum_8 + res_tag_b7_sum_7 + res_tag_b7_sum_6 + res_tag_b7_sum_5 + res_tag_b7_sum_4 + res_tag_b7_sum_3 + res_tag_b7_sum_2 + res_tag_b7_sum_1 + res_tag_b7_sum_0;
 assign ps_n0b7_wg[5:0] = res_tag_b7_sum_0  + res_tag_b7_sum_1  + res_tag_b7_sum_2  +
@@ -8708,17 +8708,17 @@ assign ps_n0b7[6:0] = (cfg_is_wg_d1[15]) ? {1'b0, ps_n0b7_wg} : ps_n0b7_dc;
 assign ps_n1b7[5:0] = res_tag_b7_sum_1  - res_tag_b7_sum_2  - res_tag_b7_sum_3  +
                          res_tag_b7_sum_5  - res_tag_b7_sum_6  - res_tag_b7_sum_7  +
                          res_tag_b7_sum_9  - res_tag_b7_sum_10 - res_tag_b7_sum_11;
-assign ps_n1b7[6] = ps_n1b7[5];
+assign ps_n1b7_6 = ps_n1b7[5];
 
 assign ps_n2b7[5:0] = res_tag_b7_sum_4  + res_tag_b7_sum_5  + res_tag_b7_sum_6  -
                          res_tag_b7_sum_8  - res_tag_b7_sum_9  - res_tag_b7_sum_10 -
                          res_tag_b7_sum_12 - res_tag_b7_sum_13 - res_tag_b7_sum_14;
-assign ps_n2b7[6] = ps_n2b7[5];
+assign ps_n2b7_6 = ps_n2b7[5];
 
 assign ps_n3b7[5:0] = res_tag_b7_sum_5  - res_tag_b7_sum_6  - res_tag_b7_sum_7  -
                          res_tag_b7_sum_9  + res_tag_b7_sum_10 + res_tag_b7_sum_11 -
                          res_tag_b7_sum_13 + res_tag_b7_sum_14 + res_tag_b7_sum_15;
-assign ps_n3b7[6] = ps_n3b7[5];
+assign ps_n3b7_6 = ps_n3b7[5];
 
 
 
diff --git a/vmod/nvdla/sdp/NV_NVDLA_SDP_CORE_Y_core.v b/vmod/nvdla/sdp/NV_NVDLA_SDP_CORE_Y_core.v
index d4f26ff..845b108 100644
--- a/vmod/nvdla/sdp/NV_NVDLA_SDP_CORE_Y_core.v
+++ b/vmod/nvdla/sdp/NV_NVDLA_SDP_CORE_Y_core.v
@@ -620,10 +620,12 @@ module SDP_Y_CORE_mgc_out_fifo_wait_core_v9 (clk, en, arst, srst, ld, vd, d, lz,
         else 
           count_t = n_elem[31:0];
         count = count_t;
+`ifndef VERILATOR
         // synopsys translate_off
         if ( peak < count )
           peak = count;
         // synopsys translate_on
+`endif
       end
 
       if (ph_en) begin: PH_EN_HI
